import { useEffect } from 'react';
import { useChainId, useConfig } from 'wagmi';
import { useMutation, useQuery, } from 'wagmi/query';
import * as Actions from '../Actions/amm.js';
/**
 * Hook for getting the reserves for a liquidity pool.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.amm.usePool({
 *     userToken: '0x...',
 *     validatorToken: '0x...',
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return (
 *     <div>
 *       User Token Reserve: {data?.reserveUserToken.toString()}
 *       Validator Token Reserve: {data?.reserveValidatorToken.toString()}
 *     </div>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the pool reserves.
 */
export function usePool(parameters) {
    const { userToken, validatorToken, query = {} } = parameters;
    const config = useConfig(parameters);
    const chainId = useChainId({ config });
    const options = Actions.getPool.queryOptions(config, {
        ...parameters,
        chainId: parameters.chainId ?? chainId,
        query: undefined,
    });
    const enabled = Boolean(userToken !== undefined &&
        validatorToken !== undefined &&
        (query.enabled ?? true));
    return useQuery({ ...query, ...options, enabled });
}
/**
 * Hook for getting the LP token balance for an account in a specific pool.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data: poolId } = Hooks.amm.usePoolId({
 *     userToken: '0x...',
 *     validatorToken: '0x...',
 *   })
 *
 *   const { data, isLoading } = Hooks.amm.useLiquidityBalance({
 *     poolId,
 *     address: '0x20c...0055',
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>LP Balance: {data?.toString()}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the LP token balance.
 */
export function useLiquidityBalance(parameters = {}) {
    const { address, poolId, userToken, validatorToken, query = {} } = parameters;
    const config = useConfig(parameters);
    const chainId = useChainId({ config });
    const options = Actions.getLiquidityBalance.queryOptions(config, {
        ...parameters,
        chainId: parameters.chainId ?? chainId,
        query: undefined,
    });
    const enabled = Boolean(address &&
        (poolId || (userToken !== undefined && validatorToken !== undefined)) &&
        (query.enabled ?? true));
    return useQuery({ ...query, ...options, enabled });
}
/**
 * Hook for performing a rebalance swap from validator token to user token.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.amm.useRebalanceSwap()
 *
 *   return (
 *     <button
 *       onClick={() =>
 *         mutate({
 *           userToken: '0x...',
 *           validatorToken: '0x...',
 *           amountOut: 100n,
 *           to: '0x...',
 *         })
 *       }
 *       disabled={isPending}
 *     >
 *       Rebalance Swap
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export function useRebalanceSwap(parameters = {}) {
    const { mutation } = parameters;
    const config = useConfig(parameters);
    return useMutation({
        ...mutation,
        async mutationFn(variables) {
            return Actions.rebalanceSwap(config, variables);
        },
        mutationKey: ['rebalanceSwap'],
    });
}
/**
 * Hook for performing a rebalance swap from validator token to user token.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.amm.useRebalanceSwapSync()
 *
 *   return (
 *     <button
 *       onClick={() =>
 *         mutate({
 *           userToken: '0x...',
 *           validatorToken: '0x...',
 *           amountOut: 100n,
 *           to: '0x...',
 *         })
 *       }
 *       disabled={isPending}
 *     >
 *       Rebalance Swap
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export function useRebalanceSwapSync(parameters = {}) {
    const { mutation } = parameters;
    const config = useConfig(parameters);
    return useMutation({
        ...mutation,
        async mutationFn(variables) {
            return Actions.rebalanceSwapSync(config, variables);
        },
        mutationKey: ['rebalanceSwapSync'],
    });
}
/**
 * Hook for adding liquidity to a pool.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.amm.useMint()
 *
 *   return (
 *     <button
 *       onClick={() =>
 *         mutate({
 *           userTokenAddress: '0x20c0...beef',
 *           validatorTokenAddress: '0x20c0...babe',
 *           validatorTokenAmount: 100n,
 *           to: '0xfeed...fede',
 *         })
 *       }
 *       disabled={isPending}
 *     >
 *       Add Liquidity
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export function useMint(parameters = {}) {
    const { mutation } = parameters;
    const config = useConfig(parameters);
    return useMutation({
        ...mutation,
        async mutationFn(variables) {
            return Actions.mint(config, variables);
        },
        mutationKey: ['mint'],
    });
}
/**
 * Hook for adding liquidity to a pool.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.amm.useMintSync()
 *
 *   return (
 *     <button
 *       onClick={() =>
 *         mutate({
 *           userTokenAddress: '0x20c0...beef',
 *           validatorTokenAddress: '0x20c0...babe',
 *           validatorTokenAmount: 100n,
 *           to: '0xfeed...fede',
 *         })
 *       }
 *       disabled={isPending}
 *     >
 *       Add Liquidity
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export function useMintSync(parameters = {}) {
    const { mutation } = parameters;
    const config = useConfig(parameters);
    return useMutation({
        ...mutation,
        async mutationFn(variables) {
            return Actions.mintSync(config, variables);
        },
        mutationKey: ['mintSync'],
    });
}
/**
 * Hook for removing liquidity from a pool.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.amm.useBurn()
 *
 *   return (
 *     <button
 *       onClick={() =>
 *         mutate({
 *           userToken: '0x20c0...beef',
 *           validatorToken: '0x20c0...babe',
 *           liquidity: 50n,
 *           to: '0xfeed...fede',
 *         })
 *       }
 *       disabled={isPending}
 *     >
 *       Remove Liquidity
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export function useBurn(parameters = {}) {
    const { mutation } = parameters;
    const config = useConfig(parameters);
    return useMutation({
        ...mutation,
        async mutationFn(variables) {
            return Actions.burn(config, variables);
        },
        mutationKey: ['burn'],
    });
}
/**
 * Hook for removing liquidity from a pool.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.amm.useBurnSync()
 *
 *   return (
 *     <button
 *       onClick={() =>
 *         mutate({
 *           userToken: '0x20c0...beef',
 *           validatorToken: '0x20c0...babe',
 *           liquidity: 50n,
 *           to: '0xfeed...fede',
 *         })
 *       }
 *       disabled={isPending}
 *     >
 *       Remove Liquidity
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export function useBurnSync(parameters = {}) {
    const { mutation } = parameters;
    const config = useConfig(parameters);
    return useMutation({
        ...mutation,
        async mutationFn(variables) {
            return Actions.burnSync(config, variables);
        },
        mutationKey: ['burnSync'],
    });
}
/**
 * Hook for watching rebalance swap events.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.amm.useWatchRebalanceSwap({
 *     onRebalanceSwap(args) {
 *       console.log('Rebalance swap:', args)
 *     },
 *   })
 *
 *   return <div>Watching for rebalance swaps...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export function useWatchRebalanceSwap(parameters = {}) {
    const { enabled = true, onRebalanceSwap, ...rest } = parameters;
    const config = useConfig({ config: parameters.config });
    const configChainId = useChainId({ config });
    const chainId = parameters.chainId ?? configChainId;
    useEffect(() => {
        if (!enabled)
            return;
        if (!onRebalanceSwap)
            return;
        return Actions.watchRebalanceSwap(config, {
            ...rest,
            chainId,
            onRebalanceSwap,
        });
    }, [config, enabled, onRebalanceSwap, rest, chainId]);
}
/**
 * Hook for watching fee swap events.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.amm.useWatchFeeSwap({
 *     onFeeSwap(args) {
 *       console.log('Fee swap:', args)
 *     },
 *   })
 *
 *   return <div>Watching for fee swaps...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export function useWatchFeeSwap(parameters = {}) {
    const { enabled = true, onFeeSwap, ...rest } = parameters;
    const config = useConfig({ config: parameters.config });
    const configChainId = useChainId({ config });
    const chainId = parameters.chainId ?? configChainId;
    useEffect(() => {
        if (!enabled)
            return;
        if (!onFeeSwap)
            return;
        return Actions.watchFeeSwap(config, {
            ...rest,
            chainId,
            onFeeSwap,
        });
    }, [config, enabled, onFeeSwap, rest, chainId]);
}
/**
 * Hook for watching liquidity mint events.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.amm.useWatchMint({
 *     onMint(args) {
 *       console.log('Liquidity added:', args)
 *     },
 *   })
 *
 *   return <div>Watching for liquidity additions...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export function useWatchMint(parameters = {}) {
    const { enabled = true, onMint, ...rest } = parameters;
    const config = useConfig({ config: parameters.config });
    const configChainId = useChainId({ config });
    const chainId = parameters.chainId ?? configChainId;
    useEffect(() => {
        if (!enabled)
            return;
        if (!onMint)
            return;
        return Actions.watchMint(config, {
            ...rest,
            chainId,
            onMint,
        });
    }, [config, enabled, onMint, rest, chainId]);
}
/**
 * Hook for watching liquidity burn events.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.amm.useWatchBurn({
 *     onBurn(args) {
 *       console.log('Liquidity removed:', args)
 *     },
 *   })
 *
 *   return <div>Watching for liquidity removals...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export function useWatchBurn(parameters = {}) {
    const { enabled = true, onBurn, ...rest } = parameters;
    const config = useConfig({ config: parameters.config });
    const configChainId = useChainId({ config });
    const chainId = parameters.chainId ?? configChainId;
    useEffect(() => {
        if (!enabled)
            return;
        if (!onBurn)
            return;
        return Actions.watchBurn(config, {
            ...rest,
            chainId,
            onBurn,
        });
    }, [config, enabled, onBurn, rest, chainId]);
}
//# sourceMappingURL=amm.js.map