import type { DefaultError } from '@tanstack/query-core';
import type { UseMutationResult } from '@tanstack/react-query';
import type { Config, ResolvedRegister } from '@wagmi/core';
import type { ConfigParameter, QueryParameter } from 'wagmi/internal';
import { type UseMutationParameters, type UseQueryReturnType } from 'wagmi/query';
import type { ExactPartial, UnionCompute } from '../../internal/types.js';
import { buy, buySync, cancel, cancelSync, createPair, createPairSync, getBalance, getBuyQuote, getOrder, getOrderbook, getSellQuote, getTickLevel, place, placeFlip, placeFlipSync, placeSync, sell, sellSync, watchFlipOrderPlaced, watchOrderCancelled, watchOrderFilled, watchOrderPlaced, withdraw, withdrawSync } from '../Actions/dex.js';
/**
 * Hook for buying a specific amount of tokens.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useBuy()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         tokenIn: '0x20c...11',
 *         tokenOut: '0x20c...20',
 *         amountOut: parseUnits('100', 6),
 *         maxAmountIn: parseUnits('105', 6),
 *       })}
 *       disabled={isPending}
 *     >
 *       Buy Tokens
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useBuy<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useBuy.Parameters<config, context>): useBuy.ReturnType<config, context>;
export declare namespace useBuy {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<buy.ReturnValue, buy.ErrorType, buy.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<buy.ReturnValue, buy.ErrorType, buy.Parameters<config>, context>;
}
/**
 * Hook for buying a specific amount of tokens.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useBuySync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         tokenIn: '0x20c...11',
 *         tokenOut: '0x20c...20',
 *         amountOut: parseUnits('100', 6),
 *         maxAmountIn: parseUnits('105', 6),
 *       })}
 *       disabled={isPending}
 *     >
 *       Buy Tokens
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useBuySync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useBuySync.Parameters<config, context>): useBuySync.ReturnType<config, context>;
export declare namespace useBuySync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<buySync.ReturnValue, buySync.ErrorType, buySync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<buySync.ReturnValue, buySync.ErrorType, buySync.Parameters<config>, context>;
}
/**
 * Hook for canceling an order from the orderbook.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useCancel()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({ orderId: 123n })}
 *       disabled={isPending}
 *     >
 *       Cancel Order
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useCancel<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useCancel.Parameters<config, context>): useCancel.ReturnType<config, context>;
export declare namespace useCancel {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<cancel.ReturnValue, cancel.ErrorType, cancel.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<cancel.ReturnValue, cancel.ErrorType, cancel.Parameters<config>, context>;
}
/**
 * Hook for canceling an order from the orderbook.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useCancelSync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({ orderId: 123n })}
 *       disabled={isPending}
 *     >
 *       Cancel Order
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useCancelSync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useCancelSync.Parameters<config, context>): useCancelSync.ReturnType<config, context>;
export declare namespace useCancelSync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<cancelSync.ReturnValue, cancelSync.ErrorType, cancelSync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<cancelSync.ReturnValue, cancelSync.ErrorType, cancelSync.Parameters<config>, context>;
}
/**
 * Hook for creating a new trading pair on the DEX.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useCreatePair()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({ base: '0x20c...11' })}
 *       disabled={isPending}
 *     >
 *       Create Pair
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useCreatePair<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useCreatePair.Parameters<config, context>): useCreatePair.ReturnType<config, context>;
export declare namespace useCreatePair {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<createPair.ReturnValue, createPair.ErrorType, createPair.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<createPair.ReturnValue, createPair.ErrorType, createPair.Parameters<config>, context>;
}
/**
 * Hook for creating a new trading pair on the DEX.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useCreatePairSync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({ base: '0x20c...11' })}
 *       disabled={isPending}
 *     >
 *       Create Pair
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useCreatePairSync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useCreatePairSync.Parameters<config, context>): useCreatePairSync.ReturnType<config, context>;
export declare namespace useCreatePairSync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<createPairSync.ReturnValue, createPairSync.ErrorType, createPairSync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<createPairSync.ReturnValue, createPairSync.ErrorType, createPairSync.Parameters<config>, context>;
}
/**
 * Hook for getting a user's token balance on the DEX.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.dex.useBalance({
 *     account: '0x...',
 *     token: '0x20c...11',
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>Balance: {data}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the user's token balance on the DEX.
 */
export declare function useBalance<config extends Config = ResolvedRegister['config'], selectData = getBalance.ReturnValue>(parameters: useBalance.Parameters<config, selectData>): UseQueryReturnType<selectData, Error>;
export declare namespace useBalance {
    type Parameters<config extends Config = ResolvedRegister['config'], selectData = getBalance.ReturnValue> = ConfigParameter<config> & QueryParameter<getBalance.ReturnValue, DefaultError, selectData, getBalance.QueryKey<config>> & Omit<getBalance.queryOptions.Parameters<config, selectData>, 'query'>;
    type ReturnValue<selectData = getBalance.ReturnValue> = UseQueryReturnType<selectData, Error>;
}
/**
 * Hook for getting the quote for buying a specific amount of tokens.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.dex.useBuyQuote({
 *     amountOut: parseUnits('100', 6),
 *     tokenIn: '0x20c...11',
 *     tokenOut: '0x20c...20',
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>Required Input: {data}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the amount of tokenIn needed.
 */
export declare function useBuyQuote<config extends Config = ResolvedRegister['config'], selectData = getBuyQuote.ReturnValue>(parameters: useBuyQuote.Parameters<config, selectData>): UseQueryReturnType<selectData, Error>;
export declare namespace useBuyQuote {
    type Parameters<config extends Config = ResolvedRegister['config'], selectData = getBuyQuote.ReturnValue> = ConfigParameter<config> & QueryParameter<getBuyQuote.ReturnValue, DefaultError, selectData, getBuyQuote.QueryKey<config>> & Omit<getBuyQuote.queryOptions.Parameters<config, selectData>, 'query'>;
    type ReturnValue<selectData = getBuyQuote.ReturnValue> = UseQueryReturnType<selectData, Error>;
}
/**
 * Hook for getting an order's details from the orderbook.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.dex.useOrder({
 *     orderId: 123n,
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>Order: {JSON.stringify(data)}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the order details.
 */
export declare function useOrder<config extends Config = ResolvedRegister['config'], selectData = getOrder.ReturnValue>(parameters: useOrder.Parameters<config, selectData>): UseQueryReturnType<selectData, Error>;
export declare namespace useOrder {
    type Parameters<config extends Config = ResolvedRegister['config'], selectData = getOrder.ReturnValue> = ConfigParameter<config> & QueryParameter<getOrder.ReturnValue, DefaultError, selectData, getOrder.QueryKey<config>> & Omit<getOrder.queryOptions.Parameters<config, selectData>, 'query'>;
    type ReturnValue<selectData = getOrder.ReturnValue> = UseQueryReturnType<selectData, Error>;
}
/**
 * Hook for getting orderbook information for a trading pair.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.dex.useOrderbook({
 *     base: '0x20c...11',
 *     quote: '0x20c...20',
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>Orderbook: {JSON.stringify(data)}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the orderbook information.
 */
export declare function useOrderbook<config extends Config = ResolvedRegister['config'], selectData = getOrderbook.ReturnValue>(parameters: useOrderbook.Parameters<config, selectData>): UseQueryReturnType<selectData, Error>;
export declare namespace useOrderbook {
    type Parameters<config extends Config = ResolvedRegister['config'], selectData = getOrderbook.ReturnValue> = ConfigParameter<config> & QueryParameter<getOrderbook.ReturnValue, DefaultError, selectData, getOrderbook.QueryKey<config>> & Omit<getOrderbook.queryOptions.Parameters<config, selectData>, 'query'>;
    type ReturnValue<selectData = getOrderbook.ReturnValue> = UseQueryReturnType<selectData, Error>;
}
/**
 * Hook for getting the price level information at a specific tick.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.dex.usePriceLevel({
 *     base: '0x20c...11',
 *     tick: Tick.fromPrice('1.001'),
 *     isBid: true,
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>Price Level: {JSON.stringify(data)}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the price level information.
 */
export declare function usePriceLevel<config extends Config = ResolvedRegister['config'], selectData = getTickLevel.ReturnValue>(parameters: usePriceLevel.Parameters<config, selectData>): UseQueryReturnType<selectData, Error>;
export declare namespace usePriceLevel {
    type Parameters<config extends Config = ResolvedRegister['config'], selectData = getTickLevel.ReturnValue> = ConfigParameter<config> & QueryParameter<getTickLevel.ReturnValue, DefaultError, selectData, getTickLevel.QueryKey<config>> & Omit<getTickLevel.queryOptions.Parameters<config, selectData>, 'query'>;
    type ReturnValue<selectData = getTickLevel.ReturnValue> = UseQueryReturnType<selectData, Error>;
}
/**
 * Hook for getting the quote for selling a specific amount of tokens.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { data, isLoading } = Hooks.dex.useSellQuote({
 *     amountIn: parseUnits('100', 6),
 *     tokenIn: '0x20c...11',
 *     tokenOut: '0x20c...20',
 *   })
 *
 *   if (isLoading) return <div>Loading...</div>
 *   return <div>Expected Output: {data}</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Query result with the amount of tokenOut received.
 */
export declare function useSellQuote<config extends Config = ResolvedRegister['config'], selectData = getSellQuote.ReturnValue>(parameters: useSellQuote.Parameters<config, selectData>): UseQueryReturnType<selectData, Error>;
export declare namespace useSellQuote {
    type Parameters<config extends Config = ResolvedRegister['config'], selectData = getSellQuote.ReturnValue> = ConfigParameter<config> & QueryParameter<getSellQuote.ReturnValue, DefaultError, selectData, getSellQuote.QueryKey<config>> & Omit<getSellQuote.queryOptions.Parameters<config, selectData>, 'query'>;
    type ReturnValue<selectData = getSellQuote.ReturnValue> = UseQueryReturnType<selectData, Error>;
}
/**
 * Hook for placing a limit order on the orderbook.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.usePlace()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amount: parseUnits('100', 6),
 *         tick: Tick.fromPrice('0.99'),
 *         token: '0x20c...11',
 *         type: 'buy',
 *       })}
 *       disabled={isPending}
 *     >
 *       Place Order
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function usePlace<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: usePlace.Parameters<config, context>): usePlace.ReturnType<config, context>;
export declare namespace usePlace {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<place.ReturnValue, place.ErrorType, place.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<place.ReturnValue, place.ErrorType, place.Parameters<config>, context>;
}
/**
 * Hook for placing a flip order that automatically flips when filled.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.usePlaceFlip()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amount: parseUnits('100', 6),
 *         flipTick: Tick.fromPrice('1.01'),
 *         tick: Tick.fromPrice('0.99'),
 *         token: '0x20c...11',
 *         type: 'buy',
 *       })}
 *       disabled={isPending}
 *     >
 *       Place Flip Order
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function usePlaceFlip<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: usePlaceFlip.Parameters<config, context>): usePlaceFlip.ReturnType<config, context>;
export declare namespace usePlaceFlip {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<placeFlip.ReturnValue, placeFlip.ErrorType, placeFlip.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<placeFlip.ReturnValue, placeFlip.ErrorType, placeFlip.Parameters<config>, context>;
}
/**
 * Hook for placing a flip order that automatically flips when filled.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.usePlaceFlipSync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amount: parseUnits('100', 6),
 *         flipTick: Tick.fromPrice('1.01'),
 *         tick: Tick.fromPrice('0.99'),
 *         token: '0x20c...11',
 *         type: 'buy',
 *       })}
 *       disabled={isPending}
 *     >
 *       Place Flip Order
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function usePlaceFlipSync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: usePlaceFlipSync.Parameters<config, context>): usePlaceFlipSync.ReturnType<config, context>;
export declare namespace usePlaceFlipSync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<placeFlipSync.ReturnValue, placeFlipSync.ErrorType, placeFlipSync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<placeFlipSync.ReturnValue, placeFlipSync.ErrorType, placeFlipSync.Parameters<config>, context>;
}
/**
 * Hook for placing a limit order on the orderbook.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.usePlaceSync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amount: parseUnits('100', 6),
 *         tick: Tick.fromPrice('0.99'),
 *         token: '0x20c...11',
 *         type: 'buy',
 *       })}
 *       disabled={isPending}
 *     >
 *       Place Order
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function usePlaceSync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: usePlaceSync.Parameters<config, context>): usePlaceSync.ReturnType<config, context>;
export declare namespace usePlaceSync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<placeSync.ReturnValue, placeSync.ErrorType, placeSync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<placeSync.ReturnValue, placeSync.ErrorType, placeSync.Parameters<config>, context>;
}
/**
 * Hook for selling a specific amount of tokens.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useSell()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amountIn: parseUnits('100', 6),
 *         minAmountOut: parseUnits('95', 6),
 *         tokenIn: '0x20c...11',
 *         tokenOut: '0x20c...20',
 *       })}
 *       disabled={isPending}
 *     >
 *       Sell Tokens
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useSell<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useSell.Parameters<config, context>): useSell.ReturnType<config, context>;
export declare namespace useSell {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<sell.ReturnValue, sell.ErrorType, sell.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<sell.ReturnValue, sell.ErrorType, sell.Parameters<config>, context>;
}
/**
 * Hook for selling a specific amount of tokens.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useSellSync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amountIn: parseUnits('100', 6),
 *         minAmountOut: parseUnits('95', 6),
 *         tokenIn: '0x20c...11',
 *         tokenOut: '0x20c...20',
 *       })}
 *       disabled={isPending}
 *     >
 *       Sell Tokens
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useSellSync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useSellSync.Parameters<config, context>): useSellSync.ReturnType<config, context>;
export declare namespace useSellSync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<sellSync.ReturnValue, sellSync.ErrorType, sellSync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<sellSync.ReturnValue, sellSync.ErrorType, sellSync.Parameters<config>, context>;
}
/**
 * Hook for withdrawing tokens from the DEX to the caller's wallet.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useWithdraw()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amount: 100n,
 *         token: '0x20c...11',
 *       })}
 *       disabled={isPending}
 *     >
 *       Withdraw
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useWithdraw<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useWithdraw.Parameters<config, context>): useWithdraw.ReturnType<config, context>;
export declare namespace useWithdraw {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<withdraw.ReturnValue, withdraw.ErrorType, withdraw.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<withdraw.ReturnValue, withdraw.ErrorType, withdraw.Parameters<config>, context>;
}
/**
 * Hook for withdrawing tokens from the DEX to the caller's wallet.
 *
 * Note: This is a synchronous hook that waits for the transaction
 * to be included on a block before returning a response.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   const { mutate, isPending } = Hooks.dex.useWithdrawSync()
 *
 *   return (
 *     <button
 *       onClick={() => mutate({
 *         amount: 100n,
 *         token: '0x20c...11',
 *       })}
 *       disabled={isPending}
 *     >
 *       Withdraw
 *     </button>
 *   )
 * }
 * ```
 *
 * @param parameters - Parameters.
 * @returns Mutation result.
 */
export declare function useWithdrawSync<config extends Config = ResolvedRegister['config'], context = unknown>(parameters?: useWithdrawSync.Parameters<config, context>): useWithdrawSync.ReturnType<config, context>;
export declare namespace useWithdrawSync {
    type Parameters<config extends Config = Config, context = unknown> = ConfigParameter<config> & {
        mutation?: UseMutationParameters<withdrawSync.ReturnValue, withdrawSync.ErrorType, withdrawSync.Parameters<config>, context> | undefined;
    };
    type ReturnType<config extends Config = Config, context = unknown> = UseMutationResult<withdrawSync.ReturnValue, withdrawSync.ErrorType, withdrawSync.Parameters<config>, context>;
}
/**
 * Hook for watching flip order placement events on the DEX.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.dex.useWatchFlipOrderPlaced({
 *     onFlipOrderPlaced(args) {
 *       console.log('Flip order placed:', args)
 *     },
 *   })
 *
 *   return <div>Watching for flip order placements...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export declare function useWatchFlipOrderPlaced<config extends Config = ResolvedRegister['config']>(parameters?: useWatchFlipOrderPlaced.Parameters<config>): void;
export declare namespace useWatchFlipOrderPlaced {
    type Parameters<config extends Config = Config> = UnionCompute<ExactPartial<watchFlipOrderPlaced.Parameters<config>> & ConfigParameter<config> & {
        enabled?: boolean | undefined;
    }>;
}
/**
 * Hook for watching order cancellation events on the DEX.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.dex.useWatchOrderCancelled({
 *     onOrderCancelled(args) {
 *       console.log('Order cancelled:', args)
 *     },
 *   })
 *
 *   return <div>Watching for order cancellations...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export declare function useWatchOrderCancelled<config extends Config = ResolvedRegister['config']>(parameters?: useWatchOrderCancelled.Parameters<config>): void;
export declare namespace useWatchOrderCancelled {
    type Parameters<config extends Config = Config> = UnionCompute<ExactPartial<watchOrderCancelled.Parameters<config>> & ConfigParameter<config> & {
        enabled?: boolean | undefined;
    }>;
}
/**
 * Hook for watching order filled events on the DEX.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.dex.useWatchOrderFilled({
 *     onOrderFilled(args) {
 *       console.log('Order filled:', args)
 *     },
 *   })
 *
 *   return <div>Watching for order fills...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export declare function useWatchOrderFilled<config extends Config = ResolvedRegister['config']>(parameters?: useWatchOrderFilled.Parameters<config>): void;
export declare namespace useWatchOrderFilled {
    type Parameters<config extends Config = Config> = UnionCompute<ExactPartial<watchOrderFilled.Parameters<config>> & ConfigParameter<config> & {
        enabled?: boolean | undefined;
    }>;
}
/**
 * Hook for watching order placement events on the DEX.
 *
 * @example
 * ```tsx
 * import { Hooks } from 'tempo.ts/wagmi'
 *
 * function App() {
 *   Hooks.dex.useWatchOrderPlaced({
 *     onOrderPlaced(args) {
 *       console.log('Order placed:', args)
 *     },
 *   })
 *
 *   return <div>Watching for order placements...</div>
 * }
 * ```
 *
 * @param parameters - Parameters.
 */
export declare function useWatchOrderPlaced<config extends Config = ResolvedRegister['config']>(parameters?: useWatchOrderPlaced.Parameters<config>): void;
export declare namespace useWatchOrderPlaced {
    type Parameters<config extends Config = Config> = UnionCompute<ExactPartial<watchOrderPlaced.Parameters<config>> & ConfigParameter<config> & {
        enabled?: boolean | undefined;
    }>;
}
//# sourceMappingURL=dex.d.ts.map