import { type Router, type RouterOptions } from '@remix-run/fetch-router';
import { RpcRequest } from 'ox';
import * as Hex from 'ox/Hex';
import type * as WebAuthnP256 from 'ox/WebAuthnP256';
import { type Chain, type Client, type Transport } from 'viem';
import type { LocalAccount } from 'viem/accounts';
import type { OneOf } from '../internal/types.js';
import type * as Kv from './Kv.js';
export type Handler = Router & {
    listener: (req: any, res: any) => void;
};
export declare function compose(handlers: Handler[], options?: compose.Options): Handler;
export declare namespace compose {
    type Options = from.Options & {
        /** The path to use for the handler. */
        path?: string | undefined;
    };
}
/**
 * Instantiates a new request handler.
 *
 * @param options - constructor options
 * @returns Handler instance
 */
export declare function from(options?: from.Options): Handler;
export declare namespace from {
    type Options = RouterOptions & {
        /** Headers to add to the response. */
        headers?: Headers | Record<string, string> | undefined;
    };
}
/**
 * Defines a Key Manager request handler.
 *
 * @example
 * ### Cloudflare Worker
 *
 * ```ts
 * import { env } from 'cloudflare:workers'
 * import { Handler } from 'tempo.ts/server'
 *
 * export default {
 *   fetch(request) {
 *     return Handler.keyManager({
 *       kv: Kv.cloudflare(env.KEY_STORE),
 *     }).fetch(request)
 *   }
 * }
 * ```
 *
 * @example
 * ### Next.js
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * export GET = handler.fetch
 * export POST = handler.fetch
 * ```
 *
 * @example
 * ### Hono
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * const app = new Hono()
 * app.all('*', handler)
 *
 * export default app
 * ```
 *
 * @example
 * ### Node.js
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * const server = createServer(handler.listener)
 * server.listen(3000)
 * ```
 *
 * @example
 * ### Bun
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * Bun.serve(handler)
 * ```
 *
 * @example
 * ### Deno
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * Deno.serve(handler)
 * ```
 *
 * @example
 * ### Express
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * const app = express()
 * app.use(handler.listener)
 * app.listen(3000)
 * ```
 *
 * @param options - Options.
 * @returns Request handler.
 */
export declare function keyManager(options: keyManager.Options): Handler;
export declare namespace keyManager {
    type Options = from.Options & {
        /** The KV store to use for key management. */
        kv: Kv.Kv;
        /** The path to use for the handler. */
        path?: string | undefined;
        /** The RP to use for WebAuthn. */
        rp?: string | {
            id: string;
            name?: string | undefined;
        } | undefined;
    };
    type ChallengeResponse = {
        challenge: Hex.Hex;
        rp?: {
            id: string;
            name: string;
        } | undefined;
    };
    type GetPublicKeyParameters = {
        credential: WebAuthnP256.P256Credential['raw'];
    };
    type SetPublicKeyParameters = {
        credential: WebAuthnP256.P256Credential['raw'];
        publicKey: Hex.Hex;
    };
}
/**
 * Instantiates a fee payer service request handler that can be used to
 * sponsor the fee for user transactions.
 *
 * @example
 * ### Cloudflare Worker
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * export default {
 *   fetch(request) {
 *     return Handler.feePayer({
 *       account: privateKeyToAccount('0x...'),
 *       client,
 *     }).fetch(request)
 *   }
 * }
 * ```
 *
 * @example
 * ### Next.js
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * export GET = handler.fetch
 * export POST = handler.fetch
 * ```
 *
 * @example
 * ### Hono
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * const app = new Hono()
 * app.all('*', handler)
 *
 * export default app
 * ```
 *
 * @example
 * ### Node.js
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * const server = createServer(handler.listener)
 * server.listen(3000)
 * ```
 *
 * @example
 * ### Bun
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   account: privateKeyToAccount('0x...'),
 *   chain: tempoTestnet.extend({
 *     feeToken: '0x20c0000000000000000000000000000000000001',
 *   }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * Bun.serve(handler)
 * ```
 *
 * @example
 * ### Deno
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * Deno.serve(handler)
 * ```
 *
 * @example
 * ### Express
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * const app = express()
 * app.use(handler.listener)
 * app.listen(3000)
 * ```
 *
 * @param options - Options.
 * @returns Request handler.
 */
export declare function feePayer(options: feePayer.Options): Handler;
export declare namespace feePayer {
    type Options = from.Options & {
        /** Account to use as the fee payer. */
        account: LocalAccount;
        /** Function to call before handling the request. */
        onRequest?: (request: RpcRequest.RpcRequest) => Promise<void>;
        /** Path to use for the handler. */
        path?: string | undefined;
    } & OneOf<{
        /** Client to use. */
        client: Client;
    } | {
        /** Chain to use. */
        chain: Chain;
        /** Transport to use. */
        transport: Transport;
    }>;
}
//# sourceMappingURL=Handler.d.ts.map