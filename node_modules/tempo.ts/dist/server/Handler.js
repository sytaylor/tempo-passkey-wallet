import { createRouter, } from '@remix-run/fetch-router';
import { RpcRequest, RpcResponse } from 'ox';
import * as Base64 from 'ox/Base64';
import * as Hex from 'ox/Hex';
import { createClient } from 'viem';
import { signTransaction } from 'viem/actions';
import { Formatters, Transaction } from 'viem/tempo';
import * as RequestListener from './internal/requestListener.js';
export function compose(handlers, options = {}) {
    const path = options.path ?? '/';
    return from({
        ...options,
        async defaultHandler(context) {
            const url = new URL(context.request.url);
            if (!url.pathname.startsWith(path))
                return new Response('Not Found', { status: 404 });
            url.pathname = url.pathname.replace(path, '');
            for (const handler of handlers) {
                const request = new Request(url, context.request.clone());
                const response = await handler.fetch(request);
                if (response.status !== 404)
                    return response;
            }
            return new Response('Not Found', { status: 404 });
        },
    });
}
/**
 * Instantiates a new request handler.
 *
 * @param options - constructor options
 * @returns Handler instance
 */
export function from(options = {}) {
    const router = createRouter({
        ...options,
        middleware: [headers(options.headers), preflight(options.headers)],
    });
    return {
        ...router,
        listener: RequestListener.fromFetchHandler((request) => {
            return router.fetch(request);
        }),
    };
}
/**
 * Defines a Key Manager request handler.
 *
 * @example
 * ### Cloudflare Worker
 *
 * ```ts
 * import { env } from 'cloudflare:workers'
 * import { Handler } from 'tempo.ts/server'
 *
 * export default {
 *   fetch(request) {
 *     return Handler.keyManager({
 *       kv: Kv.cloudflare(env.KEY_STORE),
 *     }).fetch(request)
 *   }
 * }
 * ```
 *
 * @example
 * ### Next.js
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * export GET = handler.fetch
 * export POST = handler.fetch
 * ```
 *
 * @example
 * ### Hono
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * const app = new Hono()
 * app.all('*', handler)
 *
 * export default app
 * ```
 *
 * @example
 * ### Node.js
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * const server = createServer(handler.listener)
 * server.listen(3000)
 * ```
 *
 * @example
 * ### Bun
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * Bun.serve(handler)
 * ```
 *
 * @example
 * ### Deno
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * Deno.serve(handler)
 * ```
 *
 * @example
 * ### Express
 *
 * ```ts
 * import { Handler } from 'tempo.ts/server'
 *
 * const handler = Handler.keyManager({
 *   kv: Kv.memory(),
 * })
 *
 * const app = express()
 * app.use(handler.listener)
 * app.listen(3000)
 * ```
 *
 * @param options - Options.
 * @returns Request handler.
 */
export function keyManager(options) {
    const { kv } = options;
    const path = options.path ?? '';
    const rp = (() => {
        if (typeof options.rp === 'string')
            return { id: options.rp, name: options.rp };
        if (options.rp)
            return {
                id: options.rp.id,
                name: options.rp.name ?? options.rp.id,
            };
        return undefined;
    })();
    const router = from(options);
    // Get challenge for WebAuthn credential creation
    router.get(`${path}/challenge`, async () => {
        // Generate a random challenge
        const challenge = Hex.random(32);
        // Store challenge in KV with 5 minute expiration
        await kv.set(`challenge:${challenge}`, '1');
        return Response.json({
            challenge,
            ...(rp ? { rp } : {}),
        });
    });
    // Get public key for a credential
    router.get(`${path}/:id`, async ({ params }) => {
        const { id } = params;
        const publicKey = await kv.get(`credential:${id}`);
        if (!publicKey)
            return new Response('Credential not found', { status: 404 });
        return Response.json({
            publicKey,
        });
    });
    // Set public key for a credential
    router.post(`${path}/:id`, async ({ params, request }) => {
        const { id } = params;
        const { credential, publicKey } = (await request.json());
        if (!credential)
            return Response.json({ error: 'Missing `credential`' }, { status: 400 });
        if (!publicKey)
            return Response.json({ error: 'Missing `publicKey`' }, { status: 400 });
        // Decode and verify clientDataJSON
        const clientDataJSON = JSON.parse(Base64.toString(credential.response.clientDataJSON));
        // Verify challenge
        const challenge = Base64.toHex(clientDataJSON.challenge);
        if (!(await kv.get(`challenge:${challenge}`)))
            return Response.json({ error: 'Invalid or expired `challenge`' }, { status: 400 });
        // Verify type
        if (clientDataJSON.type !== 'webauthn.create')
            return Response.json({ error: 'Invalid `clientDataJSON.type`' }, { status: 400 });
        // Verify origin
        if (rp?.id &&
            !rp.id.includes('localhost') &&
            clientDataJSON.origin !== new URL(`https://${rp.id}`).origin)
            return Response.json({ error: 'Invalid `clientDataJSON.origin`' }, { status: 400 });
        // Parse authenticatorData
        const authenticatorData = Base64.toBytes(credential.response.authenticatorData);
        // Parse flags (byte 32)
        const flags = authenticatorData[32];
        if (!flags)
            return Response.json({ error: 'Invalid `authenticatorData`' }, { status: 400 });
        // Check User Present (UP) flag (bit 0)
        const userPresent = (flags & 0x01) !== 0;
        if (!userPresent)
            return Response.json({ error: 'User not present' }, { status: 400 });
        // Consume the challenge (delete it so it can't be reused)
        await kv.delete(`challenge:${challenge}`);
        // Store the public key
        await kv.set(`credential:${id}`, publicKey);
        return new Response(null, { status: 204 });
    });
    return router;
}
/**
 * Instantiates a fee payer service request handler that can be used to
 * sponsor the fee for user transactions.
 *
 * @example
 * ### Cloudflare Worker
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * export default {
 *   fetch(request) {
 *     return Handler.feePayer({
 *       account: privateKeyToAccount('0x...'),
 *       client,
 *     }).fetch(request)
 *   }
 * }
 * ```
 *
 * @example
 * ### Next.js
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * export GET = handler.fetch
 * export POST = handler.fetch
 * ```
 *
 * @example
 * ### Hono
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * const app = new Hono()
 * app.all('*', handler)
 *
 * export default app
 * ```
 *
 * @example
 * ### Node.js
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * const server = createServer(handler.listener)
 * server.listen(3000)
 * ```
 *
 * @example
 * ### Bun
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   account: privateKeyToAccount('0x...'),
 *   chain: tempoTestnet.extend({
 *     feeToken: '0x20c0000000000000000000000000000000000001',
 *   }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * Bun.serve(handler)
 * ```
 *
 * @example
 * ### Deno
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * Deno.serve(handler)
 * ```
 *
 * @example
 * ### Express
 *
 * ```ts
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { tempo } from 'viem/chains'
 * import { Handler } from 'tempo.ts/server'
 *
 * const client = createClient({
 *   chain: tempoTestnet.extend({ feeToken: '0x20c0000000000000000000000000000000000001' }),
 *   transport: http(),
 * })
 *
 * const handler = Handler.feePayer({
 *   account: privateKeyToAccount('0x...'),
 *   client,
 * })
 *
 * const app = express()
 * app.use(handler.listener)
 * app.listen(3000)
 * ```
 *
 * @param options - Options.
 * @returns Request handler.
 */
export function feePayer(options) {
    const { account, onRequest, path = '/' } = options;
    const client = (() => {
        if ('client' in options)
            return options.client;
        if ('chain' in options && 'transport' in options)
            return createClient({
                chain: options.chain,
                transport: options.transport,
            });
        throw new Error('No client or chain provided');
    })();
    const router = from(options);
    router.post(path, async ({ request: req }) => {
        const request = RpcRequest.from((await req.json()));
        try {
            await onRequest?.(request);
            if (request.method === 'eth_signTransaction') {
                const transactionRequest = Formatters.formatTransaction(request.params?.[0]);
                const serializedTransaction = await signTransaction(client, {
                    ...transactionRequest,
                    account,
                    // @ts-expect-error
                    feePayer: account,
                });
                return Response.json(RpcResponse.from({ result: serializedTransaction }, { request }));
            }
            if (request.method === 'eth_signRawTransaction') {
                const serialized = request.params?.[0];
                const transaction = Transaction.deserialize(serialized);
                const serializedTransaction = await signTransaction(client, {
                    ...transaction,
                    account,
                    // @ts-expect-error
                    feePayer: account,
                });
                return Response.json(RpcResponse.from({ result: serializedTransaction }, { request }));
            }
            if (request.method === 'eth_sendRawTransaction' ||
                request.method === 'eth_sendRawTransactionSync') {
                const serialized = request.params?.[0];
                const transaction = Transaction.deserialize(serialized);
                const serializedTransaction = await signTransaction(client, {
                    ...transaction,
                    account,
                    // @ts-expect-error
                    feePayer: account,
                });
                const result = await client.request({
                    method: request.method,
                    params: [serializedTransaction],
                });
                return Response.json(RpcResponse.from({ result }, { request }));
            }
            return Response.json(RpcResponse.from({
                error: new RpcResponse.MethodNotSupportedError({
                    message: `Method not supported: ${request.method}`,
                }),
            }, { request }));
        }
        catch (error) {
            return Response.json(RpcResponse.from({
                error: new RpcResponse.InternalError({
                    message: error.message,
                }),
            }, { request }));
        }
    });
    return router;
}
/** @internal */
function normalizeHeaders(headers) {
    if (!headers)
        return new Headers();
    if (headers instanceof Headers)
        return headers;
    return new Headers(headers);
}
/** @internal */
function headers(headers) {
    const normalizedHeaders = normalizeHeaders(headers);
    return async (_, next) => {
        const response = await next();
        const headers = new Headers(response.headers);
        for (const [key, value] of normalizedHeaders.entries())
            headers.set(key, value);
        return new Response(response.body, {
            headers,
            status: response.status,
            statusText: response.statusText,
        });
    };
}
/** @internal */
function preflight(headers) {
    const normalizedHeaders = normalizeHeaders(headers);
    return async (context) => {
        if (context.request.method === 'OPTIONS')
            return new Response(null, { headers: normalizedHeaders });
    };
}
//# sourceMappingURL=Handler.js.map