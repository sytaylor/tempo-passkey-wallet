import { RegExpMatcher, RoutePattern } from '@remix-run/route-pattern';
import { runMiddleware } from "./middleware.js";
import { raceRequestAbort } from "./request-abort.js";
import { RequestContext } from "./request-context.js";
import { hasHandlers, hasHandler } from "./route-handlers.js";
import { Route } from "./route-map.js";
function noMatchHandler({ url }) {
    return new Response(`Not Found: ${url.pathname}`, { status: 404 });
}
/**
 * Create a new router.
 */
export function createRouter(options) {
    let defaultHandler = options?.defaultHandler ?? noMatchHandler;
    let matcher = options?.matcher ?? new RegExpMatcher();
    let middleware = options?.middleware;
    async function dispatch(context) {
        for (let match of matcher.matchAll(context.url)) {
            let { handler, method, middleware } = match.data;
            if (method !== context.method && method !== 'ANY') {
                // Request method does not match, continue to next match
                continue;
            }
            context.params = match.params;
            context.url = match.url;
            if (middleware) {
                return runMiddleware(middleware, context, handler);
            }
            return raceRequestAbort(Promise.resolve(handler(context)), context.request);
        }
        return raceRequestAbort(Promise.resolve(defaultHandler(context)), context.request);
    }
    function addRoute(method, pattern, handler) {
        let routeMiddleware;
        let requestHandler;
        if (hasHandler(handler)) {
            routeMiddleware = handler.middleware;
            requestHandler = handler.handler;
        }
        else {
            requestHandler = handler;
        }
        matcher.add(pattern instanceof Route ? pattern.pattern : pattern, {
            handler: requestHandler,
            method,
            middleware: routeMiddleware,
        });
    }
    function mapRoute(routeArg, handlerArg) {
        if (typeof routeArg === 'string' || routeArg instanceof RoutePattern) {
            // map(pattern, handler)
            addRoute('ANY', routeArg, handlerArg);
        }
        else if (routeArg instanceof Route) {
            // map(route, handler)
            addRoute(routeArg.method, routeArg.pattern, handlerArg);
        }
        else if (!hasHandlers(handlerArg)) {
            // map(routes, handlers)
            let handlers = handlerArg;
            for (let key in routeArg) {
                let route = routeArg[key];
                let handler = handlers[key];
                if (route instanceof Route) {
                    addRoute(route.method, route.pattern, handler);
                }
                else {
                    mapRoute(route, handler);
                }
            }
        }
        else {
            // map(routes, { middleware?, handlers })
            let mapMiddleware = handlerArg.middleware;
            let handlers = handlerArg.handlers;
            for (let key in routeArg) {
                let route = routeArg[key];
                let handler = handlers[key];
                if (route instanceof Route) {
                    let routeMiddleware = mapMiddleware && handler.middleware
                        ? mapMiddleware.concat(handler.middleware)
                        : mapMiddleware || handler.middleware;
                    if (hasHandler(handler)) {
                        addRoute(route.method, route.pattern, {
                            middleware: routeMiddleware,
                            handler: handler.handler,
                        });
                    }
                    else {
                        addRoute(route.method, route.pattern, { middleware: routeMiddleware, handler });
                    }
                }
                else if (hasHandlers(handler)) {
                    // map(routes, { middleware?, handlers: { home: { middleware?, handlers } } })
                    let routeMiddleware = mapMiddleware && handler.middleware
                        ? mapMiddleware.concat(handler.middleware)
                        : mapMiddleware || handler.middleware;
                    mapRoute(route, { middleware: routeMiddleware, handlers: handler.handlers });
                }
                else {
                    // map(routes, { middleware?, handlers })
                    mapRoute(route, { middleware: mapMiddleware, handlers: handler });
                }
            }
        }
    }
    return {
        async fetch(input, init) {
            let request = new Request(input, init);
            if (request.signal.aborted) {
                throw request.signal.reason;
            }
            let context = new RequestContext(request);
            let response = middleware
                ? await runMiddleware(middleware, context, dispatch)
                : await dispatch(context);
            return response;
        },
        get size() {
            return matcher.size;
        },
        route: addRoute,
        map: mapRoute,
        get(route, handler) {
            addRoute('GET', route, handler);
        },
        head(route, handler) {
            addRoute('HEAD', route, handler);
        },
        post(route, handler) {
            addRoute('POST', route, handler);
        },
        put(route, handler) {
            addRoute('PUT', route, handler);
        },
        patch(route, handler) {
            addRoute('PATCH', route, handler);
        },
        delete(route, handler) {
            addRoute('DELETE', route, handler);
        },
        options(route, handler) {
            addRoute('OPTIONS', route, handler);
        },
    };
}
