{
  "version": 3,
  "sources": ["../../tempo.ts/src/wagmi/Actions/index.ts", "../../tempo.ts/src/wagmi/Actions/amm.ts", "../../ox/tempo/SignatureEnvelope.ts", "../../@noble/curves/src/nist.ts", "../../@noble/curves/src/p256.ts", "../../ox/core/P256.ts", "../../ox/core/Base64.ts", "../../ox/core/internal/webauthn.ts", "../../ox/core/WebAuthnP256.ts", "../../ox/tempo/AuthorizationTempo.ts", "../../ox/tempo/KeyAuthorization.ts", "../../ox/tempo/PoolId.ts", "../../ox/tempo/TokenId.ts", "../../ox/tempo/TokenRole.ts", "../../ox/core/Transaction.ts", "../../ox/tempo/Transaction.ts", "../../ox/core/TransactionReceipt.ts", "../../ox/tempo/TransactionReceipt.ts", "../../ox/tempo/TxEnvelopeTempo.ts", "../../ox/core/AccessList.ts", "../../ox/core/Value.ts", "../../ox/core/TxEnvelope.ts", "../../viem/tempo/Abis.ts", "../../viem/tempo/Account.ts", "../../ox/core/WebCryptoP256.ts", "../../viem/tempo/Transaction.ts", "../../viem/tempo/Addresses.ts", "../../viem/tempo/actions/index.ts", "../../viem/tempo/actions/amm.ts", "../../viem/tempo/internal/utils.ts", "../../viem/tempo/actions/dex.ts", "../../viem/tempo/actions/faucet.ts", "../../viem/tempo/actions/fee.ts", "../../viem/tempo/actions/nonce.ts", "../../viem/tempo/actions/policy.ts", "../../viem/tempo/actions/reward.ts", "../../viem/tempo/actions/token.ts", "../../ox/core/RpcResponse.ts", "../../ox/core/Provider.ts", "../../ox/core/RpcRequest.ts", "../../viem/tempo/Transport.ts", "../../viem/tempo/WebAuthnP256.ts", "../../viem/tempo/WebCryptoP256.ts", "../../tempo.ts/src/wagmi/Actions/dex.ts", "../../tempo.ts/src/wagmi/Actions/faucet.ts", "../../tempo.ts/src/wagmi/Actions/fee.ts", "../../tempo.ts/src/wagmi/Actions/nonce.ts", "../../tempo.ts/src/wagmi/Actions/policy.ts", "../../tempo.ts/src/wagmi/Actions/reward.ts", "../../tempo.ts/src/wagmi/Actions/token.ts", "../../idb-keyval/dist/index.js", "../../@scure/base/index.ts", "../../@scure/bip32/index.ts", "../../viem/accounts/generatePrivateKey.ts", "../../viem/accounts/toAccount.ts", "../../viem/accounts/utils/sign.ts", "../../viem/accounts/utils/signAuthorization.ts", "../../viem/accounts/utils/signMessage.ts", "../../viem/accounts/utils/signTransaction.ts", "../../viem/accounts/utils/signTypedData.ts", "../../viem/accounts/privateKeyToAccount.ts", "../../@scure/bip39/esm/wordlists/czech.js", "../../@scure/bip39/esm/wordlists/english.js", "../../@scure/bip39/esm/wordlists/french.js", "../../@scure/bip39/esm/wordlists/italian.js", "../../@scure/bip39/esm/wordlists/japanese.js", "../../@scure/bip39/esm/wordlists/korean.js", "../../@scure/bip39/esm/wordlists/portuguese.js", "../../@scure/bip39/esm/wordlists/simplified-chinese.js", "../../@scure/bip39/esm/wordlists/spanish.js", "../../@scure/bip39/esm/wordlists/traditional-chinese.js", "../../tempo.ts/src/wagmi/Connector.ts", "../../tempo.ts/src/wagmi/Hooks/index.ts", "../../tempo.ts/src/wagmi/Hooks/amm.ts", "../../tempo.ts/src/wagmi/Hooks/dex.ts", "../../tempo.ts/src/wagmi/Hooks/faucet.ts", "../../tempo.ts/src/wagmi/Hooks/fee.ts", "../../tempo.ts/src/wagmi/Hooks/nonce.ts", "../../tempo.ts/src/wagmi/Hooks/policy.ts", "../../tempo.ts/src/wagmi/Hooks/reward.ts", "../../tempo.ts/src/wagmi/Hooks/token.ts", "../../tempo.ts/src/wagmi/KeyManager.ts"],
  "sourcesContent": ["export * as amm from './amm.js'\nexport * as dex from './dex.js'\nexport * as faucet from './faucet.js'\nexport * as fee from './fee.js'\nexport * as nonce from './nonce.js'\nexport * as policy from './policy.js'\nexport * as reward from './reward.js'\nexport * as token from './token.js'\n", "import type * as Query from '@tanstack/query-core'\nimport { type Config, getConnectorClient } from '@wagmi/core'\nimport type { ChainIdParameter, ConnectorParameter } from '@wagmi/core/internal'\nimport type { Account } from 'viem'\nimport { Actions } from 'viem/tempo'\nimport type { RequiredBy, UnionOmit } from '../../internal/types.js'\n\n/**\n * Gets the reserves for a liquidity pool.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const pool = await Actions.amm.getPool(config, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The pool reserves.\n */\nexport function getPool<config extends Config>(\n  config: config,\n  parameters: getPool.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.amm.getPool(client, rest)\n}\n\nexport namespace getPool {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.amm.getPool.Parameters\n\n  export type ReturnValue = Actions.amm.getPool.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getPool', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getPool(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getPool.ReturnValue,\n    > = getPool.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getPool.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getPool.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getPool.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets the LP token balance for an account in a specific pool.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const poolId = await Actions.amm.getPoolId(config, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n * })\n *\n * const balance = await Actions.amm.getLiquidityBalance(config, {\n *   poolId,\n *   address: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The LP token balance.\n */\nexport function getLiquidityBalance<config extends Config>(\n  config: config,\n  parameters: getLiquidityBalance.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.amm.getLiquidityBalance(client, rest)\n}\n\nexport namespace getLiquidityBalance {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.amm.getLiquidityBalance.Parameters\n\n  export type ReturnValue = Actions.amm.getLiquidityBalance.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getLiquidityBalance', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getLiquidityBalance(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getLiquidityBalance.ReturnValue,\n    > = getLiquidityBalance.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getLiquidityBalance.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getLiquidityBalance.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getLiquidityBalance.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Performs a rebalance swap from validator token to user token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.amm.rebalanceSwap(config, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n *   amountOut: 100n,\n *   to: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function rebalanceSwap<config extends Config>(\n  config: config,\n  parameters: rebalanceSwap.Parameters<config>,\n): Promise<Actions.amm.rebalanceSwap.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.amm.rebalanceSwap(client, parameters as never)\n}\n\nexport declare namespace rebalanceSwap {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.amm.rebalanceSwap.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.amm.rebalanceSwap.ReturnValue\n}\n\n/**\n * Performs a rebalance swap from validator token to user token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.amm.rebalanceSwapSync(config, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n *   amountOut: 100n,\n *   to: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function rebalanceSwapSync<config extends Config>(\n  config: config,\n  parameters: rebalanceSwapSync.Parameters<config>,\n): Promise<Actions.amm.rebalanceSwapSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.amm.rebalanceSwapSync(client, parameters as never)\n}\n\nexport declare namespace rebalanceSwapSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.amm.rebalanceSwapSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.amm.rebalanceSwapSync.ReturnValue\n}\n\n/**\n * Adds liquidity to a pool.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.amm.mint(config, {\n *   userTokenAddress: '0x20c0...beef',\n *   validatorTokenAddress: '0x20c0...babe',\n *   validatorTokenAmount: 100n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function mint<config extends Config>(\n  config: config,\n  parameters: mint.Parameters<config>,\n): Promise<Actions.amm.mint.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.amm.mint(client, parameters as never)\n}\n\nexport declare namespace mint {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.amm.mint.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.amm.mint.ReturnValue\n}\n\n/**\n * Adds liquidity to a pool.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.amm.mintSync(config, {\n *   userTokenAddress: '0x20c0...beef',\n *   validatorTokenAddress: '0x20c0...babe',\n *   validatorTokenAmount: 100n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function mintSync<config extends Config>(\n  config: config,\n  parameters: mintSync.Parameters<config>,\n): Promise<Actions.amm.mintSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.amm.mintSync(client, parameters as never)\n}\n\nexport declare namespace mintSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.amm.mintSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.amm.mintSync.ReturnValue\n}\n\n/**\n * Removes liquidity from a pool.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.amm.burn(config, {\n *   userToken: '0x20c0...beef',\n *   validatorToken: '0x20c0...babe',\n *   liquidity: 50n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burn<config extends Config>(\n  config: config,\n  parameters: burn.Parameters<config>,\n): Promise<Actions.amm.burn.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.amm.burn(client, parameters as never)\n}\n\nexport declare namespace burn {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.amm.burn.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.amm.burn.ReturnValue\n}\n\n/**\n * Removes liquidity from a pool.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.amm.burnSync(config, {\n *   userToken: '0x20c0...beef',\n *   validatorToken: '0x20c0...babe',\n *   liquidity: 50n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnSync<config extends Config>(\n  config: config,\n  parameters: burnSync.Parameters<config>,\n): Promise<Actions.amm.burnSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.amm.burnSync(client, parameters as never)\n}\n\nexport declare namespace burnSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.amm.burnSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.amm.burnSync.ReturnValue\n}\n\n/**\n * Watches for rebalance swap events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.amm.watchRebalanceSwap(config, {\n *   onRebalanceSwap: (args, log) => {\n *     console.log('Rebalance swap:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRebalanceSwap<config extends Config>(\n  config: config,\n  parameters: watchRebalanceSwap.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.amm.watchRebalanceSwap(client, rest)\n}\n\nexport declare namespace watchRebalanceSwap {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.amm.watchRebalanceSwap.Parameters\n}\n\n/**\n * Watches for fee swap events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.amm.watchFeeSwap(config, {\n *   onFeeSwap: (args, log) => {\n *     console.log('Fee swap:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchFeeSwap<config extends Config>(\n  config: config,\n  parameters: watchFeeSwap.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.amm.watchFeeSwap(client, rest)\n}\n\nexport declare namespace watchFeeSwap {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.amm.watchFeeSwap.Parameters\n}\n\n/**\n * Watches for liquidity mint events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.amm.watchMint(config, {\n *   onMint: (args, log) => {\n *     console.log('Liquidity added:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchMint<config extends Config>(\n  config: config,\n  parameters: watchMint.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.amm.watchMint(client, rest)\n}\n\nexport declare namespace watchMint {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.amm.watchMint.Parameters\n}\n\n/**\n * Watches for liquidity burn events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.amm.watchBurn(config, {\n *   onBurn: (args, log) => {\n *     console.log('Liquidity removed:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBurn<config extends Config>(\n  config: config,\n  parameters: watchBurn.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.amm.watchBurn(client, rest)\n}\n\nexport declare namespace watchBurn {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.amm.watchBurn.Parameters\n}\n", "import * as Address from '../core/Address.js'\nimport type * as Bytes from '../core/Bytes.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport type {\n  Assign,\n  Compute,\n  IsNarrowable,\n  OneOf,\n  PartialBy,\n  UnionPartialBy,\n} from '../core/internal/types.js'\nimport * as Json from '../core/Json.js'\nimport * as ox_P256 from '../core/P256.js'\nimport type * as PublicKey from '../core/PublicKey.js'\nimport * as ox_Secp256k1 from '../core/Secp256k1.js'\nimport * as Signature from '../core/Signature.js'\nimport type * as WebAuthnP256 from '../core/WebAuthnP256.js'\nimport * as ox_WebAuthnP256 from '../core/WebAuthnP256.js'\n\n/** Signature type identifiers for encoding/decoding */\nconst serializedP256Type = '0x01'\nconst serializedWebAuthnType = '0x02'\nconst serializedKeychainType = '0x03'\n\n/** Serialized magic identifier for Tempo signature envelopes. */\nexport const magicBytes =\n  '0x7777777777777777777777777777777777777777777777777777777777777777' // 32 \"T\"s\n\n/**\n * Statically determines the signature type of an envelope at compile time.\n *\n * @example\n * ```ts twoslash\n * import type { SignatureEnvelope } from 'ox/tempo'\n *\n * type Type = SignatureEnvelope.GetType<{ r: bigint; s: bigint; yParity: number }>\n * // @log: 'secp256k1'\n * ```\n */\nexport type GetType<\n  envelope extends PartialBy<SignatureEnvelope, 'type'> | unknown,\n> = unknown extends envelope\n  ? envelope extends unknown\n    ? Type\n    : never\n  : envelope extends { type: infer T extends Type }\n    ? T\n    : envelope extends {\n          signature: { r: bigint; s: bigint }\n          prehash: boolean\n          publicKey: PublicKey.PublicKey\n        }\n      ? 'p256'\n      : envelope extends {\n            signature: { r: bigint; s: bigint }\n            metadata: any\n            publicKey: PublicKey.PublicKey\n          }\n        ? 'webAuthn'\n        : envelope extends { r: bigint; s: bigint; yParity: number }\n          ? 'secp256k1'\n          : envelope extends {\n                signature: { r: bigint; s: bigint; yParity: number }\n              }\n            ? 'secp256k1'\n            : envelope extends {\n                  userAddress: Address.Address\n                }\n              ? 'keychain'\n              : never\n\n/**\n * Represents a signature envelope that can contain different signature types.\n *\n * Tempo transactions support multiple signature types, each with different wire formats:\n *\n * - **secp256k1** (no type prefix, 65 bytes): Standard Ethereum ECDSA signature. The sender\n *   address is recovered via `ecrecover`. Base transaction cost: 21,000 gas.\n *\n * - **p256** (type `0x01`, 130 bytes): P256/secp256r1 curve signature for passkey accounts.\n *   Includes embedded public key (64 bytes) and prehash flag. Enables native WebCrypto\n *   key support. Additional gas cost: +5,000 gas over secp256k1.\n *\n * - **webAuthn** (type `0x02`, 129-2049 bytes): WebAuthn signature with authenticator data\n *   and clientDataJSON. Enables browser passkey authentication. The signature is also\n *   charged as calldata (16 gas/non-zero byte, 4 gas/zero byte).\n *\n * - **keychain** (type `0x03`): Access key signature that wraps an inner signature (secp256k1,\n *   p256, or webAuthn). Format: `0x03` + user_address (20 bytes) + inner signature. The\n *   protocol validates the access key authorization via the AccountKeychain precompile.\n *\n * [Signature Types Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n */\nexport type SignatureEnvelope<bigintType = bigint, numberType = number> = OneOf<\n  | Secp256k1<bigintType, numberType>\n  | P256<bigintType, numberType>\n  | WebAuthn<bigintType, numberType>\n  | Keychain<bigintType, numberType>\n>\n\n/**\n * RPC-formatted signature envelope.\n */\nexport type SignatureEnvelopeRpc = OneOf<\n  Secp256k1Rpc | P256Rpc | WebAuthnRpc | KeychainRpc\n>\n\nexport type Keychain<bigintType = bigint, numberType = number> = {\n  /** Root account address that this transaction is being executed for */\n  userAddress: Address.Address\n  /** The actual signature from the access key (can be Secp256k1, P256, or WebAuthn) */\n  inner: SignatureEnvelope<bigintType, numberType>\n  type: 'keychain'\n}\n\nexport type KeychainRpc = {\n  type: 'keychain'\n  userAddress: Address.Address\n  signature: SignatureEnvelopeRpc\n}\n\nexport type P256<bigintType = bigint, numberType = number> = {\n  prehash: boolean\n  publicKey: PublicKey.PublicKey\n  signature: Signature.Signature<false, bigintType, numberType>\n  type: 'p256'\n}\n\nexport type P256Rpc = {\n  preHash: boolean\n  pubKeyX: Hex.Hex\n  pubKeyY: Hex.Hex\n  r: Hex.Hex\n  s: Hex.Hex\n  type: 'p256'\n}\n\nexport type Secp256k1<bigintType = bigint, numberType = number> = {\n  signature: Signature.Signature<true, bigintType, numberType>\n  type: 'secp256k1'\n}\n\nexport type Secp256k1Rpc = Compute<\n  Signature.Rpc<true> & {\n    v?: Hex.Hex | undefined\n    type: 'secp256k1'\n  }\n>\n\nexport type Secp256k1Flat<\n  bigintType = bigint,\n  numberType = number,\n> = Signature.Signature<true, bigintType, numberType> & {\n  type?: 'secp256k1' | undefined\n}\n\nexport type WebAuthn<bigintType = bigint, numberType = number> = {\n  metadata: Pick<\n    WebAuthnP256.SignMetadata,\n    'authenticatorData' | 'clientDataJSON'\n  >\n  signature: Signature.Signature<false, bigintType, numberType>\n  publicKey: PublicKey.PublicKey\n  type: 'webAuthn'\n}\n\nexport type WebAuthnRpc = {\n  pubKeyX: Hex.Hex\n  pubKeyY: Hex.Hex\n  r: Hex.Hex\n  s: Hex.Hex\n  type: 'webAuthn'\n  webauthnData: Hex.Hex\n}\n\n/** Hex-encoded serialized signature envelope. */\nexport type Serialized = Hex.Hex\n\n/** List of supported signature types. */\nexport const types = ['secp256k1', 'p256', 'webAuthn'] as const\n\n/** Union type of supported signature types. */\nexport type Type = (typeof types)[number]\n\n/**\n * Asserts that a {@link ox#SignatureEnvelope.SignatureEnvelope} is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * SignatureEnvelope.assert({\n *   type: 'secp256k1',\n *   signature: {\n *     r: 0n,\n *     s: 0n,\n *     yParity: 0,\n *   },\n * })\n * ```\n *\n * @param envelope - The signature envelope to assert.\n * @throws `CoercionError` if the envelope type cannot be determined.\n */\nexport function assert(envelope: PartialBy<SignatureEnvelope, 'type'>): void {\n  const type = getType(envelope)\n\n  if (type === 'secp256k1') {\n    const secp256k1 = envelope as Secp256k1\n    Signature.assert(secp256k1.signature)\n    return\n  }\n\n  if (type === 'p256') {\n    const p256 = envelope as P256\n    const missing: string[] = []\n\n    if (typeof p256.signature?.r !== 'bigint') missing.push('signature.r')\n    if (typeof p256.signature?.s !== 'bigint') missing.push('signature.s')\n    if (typeof p256.prehash !== 'boolean') missing.push('prehash')\n    if (!p256.publicKey) missing.push('publicKey')\n    else {\n      if (typeof p256.publicKey.x !== 'bigint') missing.push('publicKey.x')\n      if (typeof p256.publicKey.y !== 'bigint') missing.push('publicKey.y')\n    }\n\n    if (missing.length > 0)\n      throw new MissingPropertiesError({ envelope, missing, type: 'p256' })\n    return\n  }\n\n  if (type === 'webAuthn') {\n    const webauthn = envelope as WebAuthn\n    const missing: string[] = []\n\n    if (typeof webauthn.signature?.r !== 'bigint') missing.push('signature.r')\n    if (typeof webauthn.signature?.s !== 'bigint') missing.push('signature.s')\n    if (!webauthn.metadata) missing.push('metadata')\n    else {\n      if (!webauthn.metadata.authenticatorData)\n        missing.push('metadata.authenticatorData')\n      if (!webauthn.metadata.clientDataJSON)\n        missing.push('metadata.clientDataJSON')\n    }\n    if (!webauthn.publicKey) missing.push('publicKey')\n    else {\n      if (typeof webauthn.publicKey.x !== 'bigint') missing.push('publicKey.x')\n      if (typeof webauthn.publicKey.y !== 'bigint') missing.push('publicKey.y')\n    }\n\n    if (missing.length > 0)\n      throw new MissingPropertiesError({ envelope, missing, type: 'webAuthn' })\n    return\n  }\n\n  if (type === 'keychain') {\n    const keychain = envelope as Keychain\n    assert(keychain.inner)\n    return\n  }\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | CoercionError\n    | MissingPropertiesError\n    | Signature.assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a hex-encoded signature envelope into a typed signature object.\n *\n * Wire format detection:\n * - 65 bytes (no prefix): secp256k1 signature\n * - Type `0x01` + 129 bytes: P256 signature (r, s, pubKeyX, pubKeyY, prehash)\n * - Type `0x02` + variable: WebAuthn signature (webauthnData, r, s, pubKeyX, pubKeyY)\n * - Type `0x03` + 20 bytes + inner: Keychain signature (userAddress + inner signature)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.deserialize('0x...')\n * ```\n *\n * @param serialized - The hex-encoded signature envelope to deserialize.\n * @returns The deserialized signature envelope.\n * @throws `CoercionError` if the serialized value cannot be coerced to a valid signature envelope.\n */\nexport function deserialize(value: Serialized): SignatureEnvelope {\n  const serialized = value.endsWith(magicBytes.slice(2))\n    ? Hex.slice(value, 0, -Hex.size(magicBytes))\n    : value\n\n  const size = Hex.size(serialized)\n\n  // Backward compatibility: 65 bytes means secp256k1 without type identifier\n  if (size === 65) {\n    const signature = Signature.fromHex(serialized)\n    Signature.assert(signature)\n    return { signature, type: 'secp256k1' } satisfies Secp256k1\n  }\n\n  // For all other lengths, first byte is the type identifier\n  const typeId = Hex.slice(serialized, 0, 1)\n  const data = Hex.slice(serialized, 1)\n  const dataSize = Hex.size(data)\n\n  if (typeId === serializedP256Type) {\n    // P256: 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash) = 129 bytes\n    if (dataSize !== 129)\n      throw new InvalidSerializedError({\n        reason: `Invalid P256 signature envelope size: expected 129 bytes, got ${dataSize} bytes`,\n        serialized,\n      })\n\n    return {\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(Hex.slice(data, 64, 96)),\n        y: Hex.toBigInt(Hex.slice(data, 96, 128)),\n      },\n      prehash: Hex.toNumber(Hex.slice(data, 128, 129)) !== 0,\n      signature: {\n        r: Hex.toBigInt(Hex.slice(data, 0, 32)),\n        s: Hex.toBigInt(Hex.slice(data, 32, 64)),\n      },\n      type: 'p256',\n    } satisfies P256\n  }\n\n  if (typeId === serializedWebAuthnType) {\n    // WebAuthn: variable (webauthnData) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n    // Minimum: 128 bytes (at least some authenticator data + signature components)\n    if (dataSize < 128)\n      throw new InvalidSerializedError({\n        reason: `Invalid WebAuthn signature envelope size: expected at least 128 bytes, got ${dataSize} bytes`,\n        serialized,\n      })\n\n    const webauthnDataSize = dataSize - 128\n    const webauthnData = Hex.slice(data, 0, webauthnDataSize)\n\n    // Parse webauthnData into authenticatorData and clientDataJSON\n    // According to the Rust code, it's authenticatorData || clientDataJSON\n    // We need to find the split point (minimum authenticatorData is 37 bytes)\n    let authenticatorData: Hex.Hex | undefined\n    let clientDataJSON: string | undefined\n\n    // Try to find the JSON start (clientDataJSON should start with '{')\n    for (let split = 37; split < webauthnDataSize; split++) {\n      const potentialJson = Hex.toString(Hex.slice(webauthnData, split))\n      if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {\n        try {\n          JSON.parse(potentialJson)\n          authenticatorData = Hex.slice(webauthnData, 0, split)\n          clientDataJSON = potentialJson\n          break\n        } catch {}\n      }\n    }\n\n    if (!authenticatorData || !clientDataJSON)\n      throw new InvalidSerializedError({\n        reason:\n          'Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON',\n        serialized,\n      })\n\n    return {\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize + 64, webauthnDataSize + 96),\n        ),\n        y: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize + 96, webauthnDataSize + 128),\n        ),\n      },\n      metadata: {\n        authenticatorData,\n        clientDataJSON,\n      },\n      signature: {\n        r: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize, webauthnDataSize + 32),\n        ),\n        s: Hex.toBigInt(\n          Hex.slice(data, webauthnDataSize + 32, webauthnDataSize + 64),\n        ),\n      },\n      type: 'webAuthn',\n    } satisfies WebAuthn\n  }\n\n  if (typeId === serializedKeychainType) {\n    const userAddress = Hex.slice(data, 0, 20)\n    const inner = deserialize(Hex.slice(data, 20))\n\n    return {\n      userAddress,\n      inner,\n      type: 'keychain',\n    } satisfies Keychain\n  }\n\n  throw new InvalidSerializedError({\n    reason: `Unknown signature type identifier: ${typeId}. Expected ${serializedP256Type} (P256) or ${serializedWebAuthnType} (WebAuthn)`,\n    serialized,\n  })\n}\n\n/**\n * Coerces a value to a signature envelope.\n *\n * Accepts either a serialized hex string or an existing signature envelope object.\n * Use this to wrap raw signatures from {@link ox#Secp256k1.(sign:function)}, {@link ox#P256.(sign:function)},\n * {@link ox#WebCryptoP256.(sign:function)}, or {@link ox#WebAuthnP256.(sign:function)} into the envelope format\n * required by Tempo transactions.\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from(signature)\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n * })\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * SHA256 hashes the digest before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: '0xdeadbeef',\n *   credentialId: credential.id,\n * })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * ```\n *\n * @example\n * ### Keychain\n *\n * Wraps another signature type with a user address, used for delegated signing\n * via access keys on behalf of a root account.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   userAddress: '0x1234567890123456789012345678901234567890',\n *   inner: SignatureEnvelope.from(signature),\n * })\n * ```\n *\n * @param value - The value to coerce (either a hex string or signature envelope).\n * @returns The signature envelope.\n */\nexport function from<const value extends from.Value>(\n  value: value | from.Value,\n): from.ReturnValue<value> {\n  if (typeof value === 'string') return deserialize(value) as never\n\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    'r' in value &&\n    's' in value &&\n    'yParity' in value\n  )\n    return { signature: value, type: 'secp256k1' } as never\n\n  const type = getType(value)\n  return {\n    ...value,\n    ...(type === 'p256' ? { prehash: value.prehash } : {}),\n    type,\n  } as never\n}\n\nexport declare namespace from {\n  type Value =\n    | UnionPartialBy<SignatureEnvelope, 'prehash' | 'type'>\n    | Secp256k1Flat\n    | Serialized\n\n  type ReturnValue<value extends Value> = Compute<\n    OneOf<\n      value extends Serialized\n        ? SignatureEnvelope\n        : value extends Secp256k1Flat\n          ? Secp256k1\n          : IsNarrowable<value, SignatureEnvelope> extends true\n            ? SignatureEnvelope\n            : Assign<value, { readonly type: GetType<value> }>\n    >\n  >\n}\n\n/**\n * Converts an RPC-formatted signature envelope to a typed signature envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.fromRpc({\n *   r: '0x0',\n *   s: '0x0',\n *   yParity: '0x0',\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The RPC signature envelope to convert.\n * @returns The signature envelope with bigint values.\n */\nexport function fromRpc(envelope: SignatureEnvelopeRpc): SignatureEnvelope {\n  if (envelope.type === 'secp256k1')\n    return {\n      signature: Signature.fromRpc(envelope),\n      type: 'secp256k1',\n    }\n\n  if (envelope.type === 'p256') {\n    return {\n      prehash: envelope.preHash,\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(envelope.pubKeyX),\n        y: Hex.toBigInt(envelope.pubKeyY),\n      },\n      signature: {\n        r: Hex.toBigInt(envelope.r),\n        s: Hex.toBigInt(envelope.s),\n      },\n      type: 'p256',\n    }\n  }\n\n  if (envelope.type === 'webAuthn') {\n    const webauthnData = envelope.webauthnData\n    const webauthnDataSize = Hex.size(webauthnData)\n\n    // Parse webauthnData into authenticatorData and clientDataJSON\n    let authenticatorData: Hex.Hex | undefined\n    let clientDataJSON: string | undefined\n\n    // Try to find the JSON start (clientDataJSON should start with '{')\n    for (let split = 37; split < webauthnDataSize; split++) {\n      const potentialJson = Hex.toString(Hex.slice(webauthnData, split))\n      if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {\n        try {\n          JSON.parse(potentialJson)\n          authenticatorData = Hex.slice(webauthnData, 0, split)\n          clientDataJSON = potentialJson\n          break\n        } catch {}\n      }\n    }\n\n    if (!authenticatorData || !clientDataJSON)\n      throw new InvalidSerializedError({\n        reason:\n          'Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON',\n        serialized: webauthnData,\n      })\n\n    return {\n      metadata: {\n        authenticatorData,\n        clientDataJSON,\n      },\n      publicKey: {\n        prefix: 4,\n        x: Hex.toBigInt(envelope.pubKeyX),\n        y: Hex.toBigInt(envelope.pubKeyY),\n      },\n      signature: {\n        r: Hex.toBigInt(envelope.r),\n        s: Hex.toBigInt(envelope.s),\n      },\n      type: 'webAuthn',\n    }\n  }\n\n  if (\n    envelope.type === 'keychain' ||\n    ('userAddress' in envelope && 'signature' in envelope)\n  )\n    return {\n      type: 'keychain',\n      userAddress: envelope.userAddress,\n      inner: fromRpc(envelope.signature),\n    }\n\n  throw new CoercionError({ envelope })\n}\n\nexport declare namespace fromRpc {\n  type ErrorType =\n    | CoercionError\n    | InvalidSerializedError\n    | Signature.fromRpc.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Determines the signature type of an envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const type = SignatureEnvelope.getType({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n * })\n * // @log: 'secp256k1'\n * ```\n *\n * @param envelope - The signature envelope to inspect.\n * @returns The signature type ('secp256k1', 'p256', or 'webAuthn').\n * @throws `CoercionError` if the envelope type cannot be determined.\n */\nexport function getType<\n  envelope extends\n    | PartialBy<SignatureEnvelope, 'type'>\n    | Secp256k1Flat\n    | unknown,\n>(envelope: envelope): GetType<envelope> {\n  if (typeof envelope !== 'object' || envelope === null)\n    throw new CoercionError({ envelope })\n\n  if ('type' in envelope && envelope.type) return envelope.type as never\n\n  // Detect secp256k1 signature (backwards compatibility: also support flat structure)\n  if (\n    'signature' in envelope &&\n    !('publicKey' in envelope) &&\n    typeof envelope.signature === 'object' &&\n    envelope.signature !== null &&\n    'r' in envelope.signature &&\n    's' in envelope.signature &&\n    'yParity' in envelope.signature\n  )\n    return 'secp256k1' as never\n\n  // Detect secp256k1 signature (flat structure)\n  if ('r' in envelope && 's' in envelope && 'yParity' in envelope)\n    return 'secp256k1' as never\n\n  // Detect P256 signature\n  if (\n    'signature' in envelope &&\n    'prehash' in envelope &&\n    'publicKey' in envelope &&\n    typeof envelope.prehash === 'boolean'\n  )\n    return 'p256' as never\n\n  // Detect WebAuthn signature\n  if (\n    'signature' in envelope &&\n    'metadata' in envelope &&\n    'publicKey' in envelope\n  )\n    return 'webAuthn' as never\n\n  // Detect Keychain signature\n  if ('userAddress' in envelope && 'inner' in envelope)\n    return 'keychain' as never\n\n  throw new CoercionError({\n    envelope,\n  })\n}\n\n/**\n * Serializes a signature envelope to a hex-encoded string.\n *\n * Wire format:\n * - secp256k1: 65 bytes (no type prefix, for backward compatibility)\n * - P256: `0x01` + r (32) + s (32) + pubKeyX (32) + pubKeyY (32) + prehash (1) = 130 bytes\n * - WebAuthn: `0x02` + webauthnData (variable) + r (32) + s (32) + pubKeyX (32) + pubKeyY (32)\n * - Keychain: `0x03` + userAddress (20) + inner signature (recursive)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const serialized = SignatureEnvelope.serialize({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to serialize.\n * @returns The hex-encoded serialized signature.\n * @throws `CoercionError` if the envelope cannot be serialized.\n */\nexport function serialize(\n  envelope: UnionPartialBy<SignatureEnvelope, 'prehash'>,\n  options: serialize.Options = {},\n): Serialized {\n  const type = getType(envelope)\n\n  // Backward compatibility: no type identifier for secp256k1\n  if (type === 'secp256k1') {\n    const secp256k1 = envelope as Secp256k1\n    return Hex.concat(\n      Signature.toHex(secp256k1.signature),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  if (type === 'p256') {\n    const p256 = envelope as P256\n    // Format: 1 byte (type) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash)\n    return Hex.concat(\n      serializedP256Type,\n      Hex.fromNumber(p256.signature.r, { size: 32 }),\n      Hex.fromNumber(p256.signature.s, { size: 32 }),\n      Hex.fromNumber(p256.publicKey.x, { size: 32 }),\n      Hex.fromNumber(p256.publicKey.y, { size: 32 }),\n      Hex.fromNumber(p256.prehash ? 1 : 0, { size: 1 }),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  if (type === 'webAuthn') {\n    const webauthn = envelope as WebAuthn\n    // Format: 1 byte (type) + variable (authenticatorData || clientDataJSON) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n    const webauthnData = Hex.concat(\n      webauthn.metadata.authenticatorData,\n      Hex.fromString(webauthn.metadata.clientDataJSON),\n    )\n\n    return Hex.concat(\n      serializedWebAuthnType,\n      webauthnData,\n      Hex.fromNumber(webauthn.signature.r, { size: 32 }),\n      Hex.fromNumber(webauthn.signature.s, { size: 32 }),\n      Hex.fromNumber(webauthn.publicKey.x, { size: 32 }),\n      Hex.fromNumber(webauthn.publicKey.y, { size: 32 }),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  if (type === 'keychain') {\n    const keychain = envelope as Keychain\n    return Hex.concat(\n      serializedKeychainType,\n      keychain.userAddress,\n      serialize(keychain.inner),\n      options.magic ? magicBytes : '0x',\n    )\n  }\n\n  throw new CoercionError({ envelope })\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /**\n     * Whether to serialize the signature envelope with the Tempo magic identifier.\n     * This is useful for being able to distinguish between Tempo and non-Tempo (e.g. ERC-1271) signatures.\n     */\n    magic?: boolean | undefined\n  }\n}\n\n/**\n * Converts a signature envelope to RPC format.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const rpc = SignatureEnvelope.toRpc({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to convert.\n * @returns The RPC signature envelope with hex values.\n */\nexport function toRpc(envelope: SignatureEnvelope): SignatureEnvelopeRpc {\n  const type = getType(envelope)\n\n  if (type === 'secp256k1') {\n    const secp256k1 = envelope as Secp256k1\n    return {\n      ...Signature.toRpc(secp256k1.signature),\n      type: 'secp256k1',\n    }\n  }\n\n  if (type === 'p256') {\n    const p256 = envelope as P256\n    return {\n      preHash: p256.prehash,\n      pubKeyX: Hex.fromNumber(p256.publicKey.x, { size: 32 }),\n      pubKeyY: Hex.fromNumber(p256.publicKey.y, { size: 32 }),\n      r: Hex.fromNumber(p256.signature.r, { size: 32 }),\n      s: Hex.fromNumber(p256.signature.s, { size: 32 }),\n      type: 'p256',\n    }\n  }\n\n  if (type === 'webAuthn') {\n    const webauthn = envelope as WebAuthn\n    const webauthnData = Hex.concat(\n      webauthn.metadata.authenticatorData,\n      Hex.fromString(webauthn.metadata.clientDataJSON),\n    )\n\n    return {\n      pubKeyX: Hex.fromNumber(webauthn.publicKey.x, { size: 32 }),\n      pubKeyY: Hex.fromNumber(webauthn.publicKey.y, { size: 32 }),\n      r: Hex.fromNumber(webauthn.signature.r, { size: 32 }),\n      s: Hex.fromNumber(webauthn.signature.s, { size: 32 }),\n      type: 'webAuthn',\n      webauthnData,\n    }\n  }\n\n  if (type === 'keychain') {\n    const keychain = envelope as Keychain\n    return {\n      type: 'keychain',\n      userAddress: keychain.userAddress,\n      signature: toRpc(keychain.inner),\n    }\n  }\n\n  throw new CoercionError({ envelope })\n}\n\nexport declare namespace toRpc {\n  type ErrorType =\n    | CoercionError\n    | Signature.toRpc.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a signature envelope. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const valid = SignatureEnvelope.validate({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The signature envelope to validate.\n * @returns `true` if valid, `false` otherwise.\n */\nexport function validate(\n  envelope: PartialBy<SignatureEnvelope, 'type'>,\n): boolean {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature envelope against a digest/payload.\n *\n * Supports `secp256k1`, `p256`, and `webAuthn` signature types.\n *\n * :::warning\n * `keychain` signatures are not supported and will throw an error.\n * :::\n *\n * @example\n * ### Secp256k1\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from(signature)\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### P256\n *\n * For P256 signatures, the `address` or `publicKey` must match the embedded\n * public key in the signature envelope.\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = P256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: false, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebCryptoP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const payload = '0xdeadbeef'\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: true, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebAuthnP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n * const payload = '0xdeadbeef'\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: payload,\n *   credentialId: credential.id,\n * })\n * const envelope = SignatureEnvelope.from({\n *   metadata,\n *   signature,\n *   publicKey: credential.publicKey,\n * })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey: credential.publicKey,\n * })\n * // @log: true\n * ```\n *\n * @param parameters - Verification parameters.\n * @returns `true` if the signature is valid, `false` otherwise.\n */\nexport function verify(\n  signature: SignatureEnvelope,\n  parameters: verify.Parameters,\n): boolean {\n  const { payload } = parameters\n\n  const address = (() => {\n    if (parameters.address) return parameters.address\n    if (parameters.publicKey) return Address.fromPublicKey(parameters.publicKey)\n    return undefined\n  })()\n  if (!address) return false\n\n  const envelope = from(signature)\n\n  if (envelope.type === 'secp256k1') {\n    if (!address) return false\n    return ox_Secp256k1.verify({\n      address,\n      payload,\n      signature: envelope.signature,\n    })\n  }\n\n  if (envelope.type === 'p256') {\n    const envelopeAddress = Address.fromPublicKey(envelope.publicKey)\n    if (!Address.isEqual(envelopeAddress, address)) return false\n    return ox_P256.verify({\n      hash: envelope.prehash,\n      publicKey: envelope.publicKey,\n      payload,\n      signature: envelope.signature,\n    })\n  }\n\n  if (envelope.type === 'webAuthn') {\n    const envelopeAddress = Address.fromPublicKey(envelope.publicKey)\n    if (!Address.isEqual(envelopeAddress, address)) return false\n    return ox_WebAuthnP256.verify({\n      challenge: Hex.from(payload),\n      metadata: envelope.metadata,\n      publicKey: envelope.publicKey,\n      signature: envelope.signature,\n    })\n  }\n\n  throw new VerificationError(\n    `Unable to verify signature envelope of type \"${envelope.type}\".`,\n  )\n}\n\nexport declare namespace verify {\n  type Parameters = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  } & OneOf<\n    | {\n        /** Public key that signed the payload. */\n        publicKey: PublicKey.PublicKey\n      }\n    | {\n        /** Address that signed the payload. */\n        address: Address.Address\n      }\n  >\n}\n\n/**\n * Error thrown when a signature envelope cannot be coerced to a valid type.\n */\nexport class CoercionError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.CoercionError'\n  constructor({ envelope }: { envelope: unknown }) {\n    super(\n      `Unable to coerce value (\\`${Json.stringify(envelope)}\\`) to a valid signature envelope.`,\n    )\n  }\n}\n\n/**\n * Error thrown when a signature envelope is missing required properties.\n */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.MissingPropertiesError'\n  constructor({\n    envelope,\n    missing,\n    type,\n  }: {\n    envelope: unknown\n    missing: string[]\n    type: Type\n  }) {\n    super(\n      `Signature envelope of type \"${type}\" is missing required properties: ${missing.map((m) => `\\`${m}\\``).join(', ')}.\\n\\nProvided: ${Json.stringify(envelope)}`,\n    )\n  }\n}\n\n/**\n * Error thrown when a serialized signature envelope cannot be deserialized.\n */\nexport class InvalidSerializedError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.InvalidSerializedError'\n  constructor({\n    reason,\n    serialized,\n  }: {\n    reason: string\n    serialized: Hex.Hex\n  }) {\n    super(`Unable to deserialize signature envelope: ${reason}`, {\n      metaMessages: [`Serialized: ${serialized}`],\n    })\n  }\n}\n\n/**\n * Error thrown when a signature envelope fails to verify.\n */\nexport class VerificationError extends Errors.BaseError {\n  override readonly name = 'SignatureEnvelope.VerificationError'\n}\n", "/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type Hasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.ts';\n\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nexport const p256: CurveFnWithCreate = createCurve({\n  a: p256_a,\n  b: p256_b,\n  Fp: Fp256,\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha256);\n/** Alias to p256. */\nexport const secp256r1: CurveFnWithCreate = p256;\n\nconst p256_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n  }))();\n\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp256r1.ProjectivePoint, (scalars: bigint[]) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp384 = Field(\n  BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  )\n);\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nexport const p384: CurveFnWithCreate = createCurve({\n  a: p384_a,\n  b: p384_b,\n  Fp: Fp384,\n  n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n  Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n  Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha384);\n/** Alias to p384. */\nexport const secp384r1: CurveFnWithCreate = p384;\n\nconst p384_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n  }))();\n\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp384r1.ProjectivePoint, (scalars: bigint[]) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: sha384,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp521 = Field(\n  BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  )\n);\n\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt(\n  '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n);\n\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nexport const p521: CurveFnWithCreate = createCurve({\n  a: p521_a,\n  b: p521_b,\n  Fp: Fp521,\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n  h: BigInt(1),\n  lowS: false,\n  allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n} as const, sha512);\n/** Alias to p521. */\nexport const secp521r1: CurveFnWithCreate = p521;\n\nconst p521_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n  }))();\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp521r1.ProjectivePoint, (scalars: bigint[]) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: sha512,\n  }))();\n", "/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type HTFMethod } from './abstract/hash-to-curve.ts';\nimport { p256_hasher, p256 as p256n } from './nist.ts';\nexport const p256: typeof p256n = p256n;\nexport const secp256r1: typeof p256n = p256n;\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n", "import { secp256r1 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1\n\n/**\n * Creates a new P256 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = P256.createKeyPair()\n * const { publicKey: publicKeyB } = P256.createKeyPair()\n *\n * const sharedSecret = P256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256r1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const privateKeyHex =\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2)\n  const sharedPoint = point.multiply(\n    secp256r1.utils.normPrivateKeyToScalar(privateKeyHex),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256r1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256r1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const payload_ =\n    payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload\n  const point = signature_.recoverPublicKey(payload_.substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256r1.sign(\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     * If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { hash, payload, publicKey, signature } = options\n  return secp256r1.verify(\n    signature,\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    PublicKey.toHex(publicKey).substring(2),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<boolean>\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\nconst decoder = /*#__PURE__*/ new TextDecoder()\n\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(\n  Array.from(\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  ).map((a, i) => [i, a.charCodeAt(0)]),\n)\n\nconst characterToInteger = /*#__PURE__*/ {\n  ...Object.fromEntries(\n    Array.from(\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    ).map((a, i) => [a.charCodeAt(0), i]),\n  ),\n  ['='.charCodeAt(0)]: 0,\n  ['-'.charCodeAt(0)]: 62,\n  ['_'.charCodeAt(0)]: 63,\n} as Record<number, number>\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromBytes(value: Bytes.Bytes, options: fromBytes.Options = {}) {\n  const { pad = true, url = false } = options\n\n  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4)\n\n  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n    const y = (value[j]! << 16) + (value[j + 1]! << 8) + (value[j + 2]! | 0)\n    encoded[i] = integerToCharacter[y >> 18]!\n    encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f]!\n    encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f]!\n    encoded[i + 3] = integerToCharacter[y & 0x3f]!\n  }\n\n  const k = value.length % 3\n  const end = Math.floor(value.length / 3) * 4 + (k && k + 1)\n  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end))\n  if (pad && k === 1) base64 += '=='\n  if (pad && k === 2) base64 += '='\n  if (url) base64 = base64.replaceAll('+', '-').replaceAll('/', '_')\n  return base64\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}) {\n  return fromBytes(Bytes.fromHex(value), options)\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromString(value: string, options: fromString.Options = {}) {\n  return fromBytes(Bytes.fromString(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(value: string): Bytes.Bytes {\n  const base64 = value.replace(/=+$/, '')\n\n  const size = base64.length\n\n  const decoded = new Uint8Array(size + 3)\n  encoder.encodeInto(base64 + '===', decoded)\n\n  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n    const x =\n      (characterToInteger[decoded[i]!]! << 18) +\n      (characterToInteger[decoded[i + 1]!]! << 12) +\n      (characterToInteger[decoded[i + 2]!]! << 6) +\n      characterToInteger[decoded[i + 3]!]!\n    decoded[j] = x >> 16\n    decoded[j + 1] = (x >> 8) & 0xff\n    decoded[j + 2] = x & 0xff\n  }\n\n  const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1)\n  return new Uint8Array(decoded.buffer, 0, decodedSize)\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nexport function toHex(value: string): Hex.Hex {\n  return Hex.fromBytes(toBytes(value))\n}\n\nexport declare namespace toHex {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nexport function toString(value: string): string {\n  return Bytes.toString(toBytes(value))\n}\n\nexport declare namespace toString {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n", "import { p256 } from '@noble/curves/p256'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport * as PublicKey from '../PublicKey.js'\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js'\n\n/** @internal */\nexport type AttestationConveyancePreference =\n  | 'direct'\n  | 'enterprise'\n  | 'indirect'\n  | 'none'\n\n/** @internal */\nexport type AuthenticatorAttachment = 'cross-platform' | 'platform'\n\n/** @internal */\nexport type AuthenticatorTransport =\n  | 'ble'\n  | 'hybrid'\n  | 'internal'\n  | 'nfc'\n  | 'usb'\n\n/** @internal */\nexport type COSEAlgorithmIdentifier = number\n\n/** @internal */\nexport type CredentialMediationRequirement =\n  | 'conditional'\n  | 'optional'\n  | 'required'\n  | 'silent'\n\n/** @internal */\nexport type PublicKeyCredentialType = 'public-key'\n\n/** @internal */\nexport type ResidentKeyRequirement = 'discouraged' | 'preferred' | 'required'\n\n/** @internal */\nexport type UserVerificationRequirement =\n  | 'discouraged'\n  | 'preferred'\n  | 'required'\n\n/** @internal */\nexport type LargeBlobSupport = {\n  support: 'required' | 'preferred'\n}\n\n/** @internal */\nexport type BufferSource = ArrayBufferView | ArrayBuffer\n\n/** @internal */\nexport type PrfExtension = Record<'eval', Record<'first', Uint8Array>>\n\n/** @internal */\nexport interface AuthenticationExtensionsClientInputs {\n  appid?: string\n  credProps?: boolean\n  hmacCreateSecret?: boolean\n  minPinLength?: boolean\n  prf?: PrfExtension\n  largeBlob?: LargeBlobSupport\n}\n\n/** @internal */\nexport interface AuthenticatorSelectionCriteria {\n  authenticatorAttachment?: AuthenticatorAttachment\n  requireResidentKey?: boolean\n  residentKey?: ResidentKeyRequirement\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface Credential {\n  readonly id: string\n  readonly type: string\n}\n\n/** @internal */\nexport interface CredentialCreationOptions {\n  publicKey?: PublicKeyCredentialCreationOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface CredentialRequestOptions {\n  mediation?: CredentialMediationRequirement\n  publicKey?: PublicKeyCredentialRequestOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface PublicKeyCredential extends Credential {\n  readonly authenticatorAttachment: string | null\n  readonly rawId: ArrayBuffer\n  readonly response: AuthenticatorResponse\n  getClientExtensionResults(): AuthenticationExtensionsClientOutputs\n}\n\n/** @internal */\nexport interface PublicKeyCredentialCreationOptions {\n  attestation?: AttestationConveyancePreference\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  challenge: BufferSource\n  excludeCredentials?: PublicKeyCredentialDescriptor[]\n  extensions?: AuthenticationExtensionsClientInputs\n  pubKeyCredParams: PublicKeyCredentialParameters[]\n  rp: PublicKeyCredentialRpEntity\n  timeout?: number\n  user: PublicKeyCredentialUserEntity\n}\n\n/** @internal */\nexport interface PublicKeyCredentialDescriptor {\n  id: BufferSource\n  transports?: AuthenticatorTransport[]\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialEntity {\n  name: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialParameters {\n  alg: COSEAlgorithmIdentifier\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRequestOptions {\n  allowCredentials?: PublicKeyCredentialDescriptor[]\n  challenge: BufferSource\n  extensions?: AuthenticationExtensionsClientInputs\n  rpId?: string\n  timeout?: number\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {\n  id?: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialUserEntity\n  extends PublicKeyCredentialEntity {\n  displayName: string\n  id: BufferSource\n}\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)))\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)))\n\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s,\n  }\n}\n\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(\n  response: AuthenticatorAttestationResponse,\n): Promise<PublicKey.PublicKey> {\n  try {\n    const publicKeyBuffer = response.getPublicKey()\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError()\n\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer)\n    const cryptoKey = await crypto.subtle.importKey(\n      'spki',\n      new Uint8Array(publicKeyBytes),\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256',\n      },\n      true,\n      ['verify'],\n    )\n    const publicKey = new Uint8Array(\n      await crypto.subtle.exportKey('raw', cryptoKey),\n    )\n    return PublicKey.from(publicKey)\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if ((error as Error).message !== 'Permission denied to access object')\n      throw error\n\n    const data = new Uint8Array(response.attestationObject)\n    const coordinateLength = 0x20\n    const cborPrefix = 0x58\n\n    const findStart = (key: number) => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      throw new CredentialCreationFailedError()\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    return PublicKey.from(\n      new Uint8Array([\n        0x04,\n        ...data.slice(xStart, xStart + coordinateLength),\n        ...data.slice(yStart, yStart + coordinateLength),\n      ]),\n    )\n  }\n}\n\nexport declare namespace parseCredentialPublicKey {\n  type ErrorType = CredentialCreationFailedError | Errors.GlobalErrorType\n}\n", "import * as Base64 from './Base64.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as internal from './internal/webauthn.js'\nimport * as P256 from './P256.js'\nimport type * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** A WebAuthn-flavored P256 credential. */\nexport type P256Credential = {\n  id: string\n  publicKey: PublicKey.PublicKey\n  raw: internal.PublicKeyCredential\n}\n\n/** Metadata for a WebAuthn P256 signature. */\nexport type SignMetadata = Compute<{\n  authenticatorData: Hex.Hex\n  challengeIndex?: number | undefined\n  clientDataJSON: string\n  typeIndex?: number | undefined\n  userVerificationRequired?: boolean | undefined\n}>\n\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(\n  options: createCredential.Options,\n): Promise<P256Credential> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = options\n  const creationOptions = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(\n      creationOptions as never,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialCreationFailedError()\n\n    const response = credential.response as AuthenticatorAttestationResponse\n    const publicKey = await internal.parseCredentialPublicKey(response)\n\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace createCredential {\n  type Options = getCredentialCreationOptions.Options & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: internal.CredentialCreationOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ErrorType =\n    | getCredentialCreationOptions.ErrorType\n    | internal.parseCredentialPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(\n  options: getAuthenticatorData.Options = {},\n): Hex.Hex {\n  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId))\n  const flag_bytes = Hex.fromNumber(flag, { size: 1 })\n  const signCount_bytes = Hex.fromNumber(signCount, { size: 4 })\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes)\n}\n\nexport declare namespace getAuthenticatorData {\n  type Options = {\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options: getClientDataJSON.Options): string {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin,\n  } = options\n\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, { url: true, pad: false }),\n    origin,\n    crossOrigin,\n    ...extraClientData,\n  })\n}\n\nexport declare namespace getClientDataJSON {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(\n  options: getCredentialCreationOptions.Options,\n): internal.CredentialCreationOptions {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    extensions,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n  } = options\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge:\n        typeof challenge === 'string' ? Bytes.fromHex(challenge) : challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: Base64.toBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      ...(extensions && { extensions }),\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), { as: 'Bytes' }),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n    },\n  }\n}\n\nexport declare namespace getCredentialCreationOptions {\n  type Options = {\n    /**\n     * A string specifying the relying party's preference for how the attestation statement\n     * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n     * is conveyed during credential creation.\n     */\n    attestation?:\n      | internal.PublicKeyCredentialCreationOptions['attestation']\n      | undefined\n    /**\n     * An object whose properties are criteria used to filter out the potential authenticators\n     * for the credential creation operation.\n     */\n    authenticatorSelection?:\n      | internal.PublicKeyCredentialCreationOptions['authenticatorSelection']\n      | undefined\n    /**\n     * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n     */\n    challenge?:\n      | Hex.Hex\n      | internal.PublicKeyCredentialCreationOptions['challenge']\n      | undefined\n    /**\n     * List of credential IDs to exclude from the creation. This property can be used\n     * to prevent creation of a credential if it already exists.\n     */\n    excludeCredentialIds?: readonly string[] | undefined\n    /**\n     * List of Web Authentication API credentials to use during creation or authentication.\n     */\n    extensions?:\n      | internal.PublicKeyCredentialCreationOptions['extensions']\n      | undefined\n    /**\n     * An object describing the relying party that requested the credential creation\n     */\n    rp?:\n      | {\n          id: string\n          name: string\n        }\n      | undefined\n    /**\n     * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n     */\n    timeout?: internal.PublicKeyCredentialCreationOptions['timeout'] | undefined\n  } & OneOf<\n    | {\n        /** Name for the credential (user.name). */\n        name: string\n      }\n    | {\n        /**\n         * An object describing the user account for which the credential is generated.\n         */\n        user: {\n          displayName?: string\n          id?: BufferSource\n          name: string\n        }\n      }\n  >\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(\n  options: getCredentialRequestOptions.Options,\n): internal.CredentialRequestOptions {\n  const {\n    credentialId,\n    challenge,\n    extensions,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = options\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: Array.isArray(credentialId)\n              ? credentialId.map((id) => ({\n                  id: Base64.toBytes(id),\n                  type: 'public-key',\n                }))\n              : [\n                  {\n                    id: Base64.toBytes(credentialId),\n                    type: 'public-key',\n                  },\n                ],\n          }\n        : {}),\n      challenge: Bytes.fromHex(challenge),\n      ...(extensions && { extensions }),\n      rpId,\n      userVerification,\n    },\n  }\n}\n\nexport declare namespace getCredentialRequestOptions {\n  type Options = {\n    /** The credential ID to use. */\n    credentialId?: string | string[] | undefined\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** List of Web Authentication API credentials to use during creation or authentication. */\n    extensions?:\n      | internal.PublicKeyCredentialRequestOptions['extensions']\n      | undefined\n    /** The relying party identifier to use. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** The user verification requirement. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Base64.toBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(\n  options: getSignPayload.Options,\n): getSignPayload.ReturnType {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required',\n  } = options\n\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount,\n  })\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin,\n  })\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON))\n\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n  const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required',\n  }\n\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash)\n\n  return { metadata, payload }\n}\n\nexport declare namespace getSignPayload {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** If set to `true`, the payload will be hashed before being returned. */\n    hash?: boolean | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n    /** The user verification requirement that the authenticator will enforce. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    payload: Hex.Hex\n  }\n\n  type ErrorType =\n    | Hash.sha256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromString.ErrorType\n    | getAuthenticatorData.ErrorType\n    | getClientDataJSON.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options\n  const requestOptions = getCredentialRequestOptions(rest)\n  try {\n    const credential = (await getFn(\n      requestOptions as never,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialRequestFailedError()\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = internal.parseAsn1Signature(\n      new Uint8Array(response.signature),\n    )\n\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          requestOptions.publicKey!.userVerification === 'required',\n      },\n      signature,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace sign {\n  type Options = getCredentialRequestOptions.Options & {\n    /**\n     * Credential request function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.get\n     */\n    getFn?:\n      | ((\n          options?: internal.CredentialRequestOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    raw: internal.PublicKeyCredential\n    signature: Signature.Signature<false>\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getCredentialRequestOptions.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options: verify.Options): boolean {\n  const { challenge, hash = true, metadata, publicKey, signature } = options\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired,\n  } = metadata\n\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData)\n\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false\n\n  const flag = authenticatorDataBytes[32]!\n\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false\n\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false\n\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false\n\n  // Check that response is for an authentication assertion (if typeIndex is provided)\n  if (typeIndex !== undefined) {\n    const type = '\"type\":\"webauthn.get\"'\n    if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n      return false\n  }\n\n  // Extract and validate the challenge from clientDataJSON\n  const challengeMatch =\n    challengeIndex !== undefined\n      ? clientDataJSON\n          .slice(Number(challengeIndex))\n          .match(/^\"challenge\":\"(.*?)\"/)\n      : clientDataJSON.match(/\"challenge\":\"(.*?)\"/)\n  if (!challengeMatch) return false\n\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = challengeMatch\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted!)) !== challenge)\n    return false\n\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes',\n  })\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash)\n\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature,\n  })\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** The challenge to verify. */\n    challenge: Hex.Hex\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** The public key to verify the signature with. */\n    publicKey: PublicKey.PublicKey\n    /** The signature to verify. */\n    signature: Signature.Signature<false>\n    /** The metadata to verify the signature with. */\n    metadata: SignMetadata\n  }\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.fromHex.ErrorType\n    | P256.verify.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialCreationFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to create credential.', {\n      cause,\n    })\n  }\n}\n\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialRequestFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to request credential.', {\n      cause,\n    })\n  }\n}\n\n// Export types required for inference.\nexport type {\n  AttestationConveyancePreference,\n  AuthenticationExtensionsClientInputs,\n  AuthenticatorAttachment,\n  AuthenticatorSelectionCriteria,\n  AuthenticatorTransport,\n  BufferSource,\n  COSEAlgorithmIdentifier,\n  Credential,\n  CredentialCreationOptions,\n  CredentialMediationRequirement,\n  CredentialRequestOptions,\n  LargeBlobSupport,\n  PrfExtension,\n  PublicKeyCredential,\n  PublicKeyCredentialCreationOptions,\n  PublicKeyCredentialDescriptor,\n  PublicKeyCredentialEntity,\n  PublicKeyCredentialParameters,\n  PublicKeyCredentialRequestOptions,\n  PublicKeyCredentialRpEntity,\n  PublicKeyCredentialType,\n  PublicKeyCredentialUserEntity,\n  ResidentKeyRequirement,\n  UserVerificationRequirement,\n} from './internal/webauthn.js'\n", "import type * as Address from '../core/Address.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute, Mutable } from '../core/internal/types.js'\nimport * as Rlp from '../core/Rlp.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\n\n/**\n * Root type for a Tempo Authorization.\n *\n * Tempo extends EIP-7702 to support secp256k1, P256, and WebAuthn signature types,\n * enabling passkey-based account delegation.\n *\n * [Tempo Authorization Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#tempo-authorization-list)\n */\nexport type AuthorizationTempo<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** Address of the contract to set as code for the Authority. */\n    address: Address.Address\n    /** Chain ID to authorize. */\n    chainId: numberType\n    /** Nonce of the Authority to authorize. */\n    nonce: bigintType\n  } & (signed extends true\n    ? { signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType> }\n    : {\n        signature?:\n          | SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n          | undefined\n      })\n>\n\n/** RPC representation of an {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type Rpc = Omit<\n  AuthorizationTempo<false, Hex.Hex, Hex.Hex>,\n  'signature'\n> & {\n  signature: SignatureEnvelope.SignatureEnvelopeRpc\n}\n\n/** List of {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type List<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<readonly AuthorizationTempo<signed, bigintType, numberType>[]>\n\n/** RPC representation of a list of AA Authorizations. */\nexport type ListRpc = readonly Rpc[]\n\n/** Signed representation of a list of AA Authorizations. */\nexport type ListSigned<bigintType = bigint, numberType = number> = List<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Signed representation of an AA Authorization. */\nexport type Signed<\n  bigintType = bigint,\n  numberType = number,\n> = AuthorizationTempo<true, bigintType, numberType>\n\n/** Tuple representation of an AA Authorization. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      chainId: Hex.Hex,\n      address: Hex.Hex,\n      nonce: Hex.Hex,\n      signature: Hex.Hex,\n    ]\n  : readonly [chainId: Hex.Hex, address: Hex.Hex, nonce: Hex.Hex]\n\n/** Tuple representation of a signed {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type TupleSigned = Tuple<true>\n\n/** Tuple representation of a list of {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type TupleList<signed extends boolean = boolean> =\n  readonly Tuple<signed>[]\n\n/** Tuple representation of a list of signed {@link ox#AuthorizationTempo.AuthorizationTempo}. */\nexport type TupleListSigned = TupleList<true>\n\n/**\n * Converts an EIP-7702 Authorization object into a typed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * Tempo extends EIP-7702 to support secp256k1, P256, and WebAuthn signature types.\n *\n * [Tempo Authorization Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#tempo-authorization-list)\n *\n * @example\n * An Authorization can be instantiated from an EIP-7702 Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256)\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = P256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: false,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256 WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = await WebCryptoP256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: AuthorizationTempo.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple in object format.\n * @param options - AA Authorization options.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function from<\n  const authorization extends AuthorizationTempo | Rpc,\n  const signature extends SignatureEnvelope.from.Value | undefined = undefined,\n>(\n  authorization: authorization | AuthorizationTempo,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.chainId === 'string')\n    return fromRpc(authorization as Rpc) as never\n  if (options.signature) {\n    return { ...authorization, signature: options.signature } as never\n  }\n  return authorization as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = {\n    /** The {@link ox#SignatureEnvelope.SignatureEnvelope} to attach to the AA Authorization. */\n    signature?: signature | SignatureEnvelope.SignatureEnvelope | undefined\n  }\n\n  type ReturnType<\n    authorization extends AuthorizationTempo | Rpc = AuthorizationTempo,\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends SignatureEnvelope.from.Value\n            ? { signature: SignatureEnvelope.from.ReturnValue<signature> }\n            : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted AA Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { address, chainId, nonce } = authorization\n  const signature = SignatureEnvelope.fromRpc(authorization.signature)\n  return {\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    signature,\n  } as never\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.ListRpc} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted AA Authorization list.\n * @returns A signed {@link ox#AuthorizationTempo.List}.\n */\nexport function fromRpcList(authorizationList: ListRpc): ListSigned {\n  return authorizationList.map((x) => fromRpc(x as unknown as Rpc))\n}\n\nexport declare namespace fromRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.Tuple} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   signature: {\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [chainId, address, nonce, signatureSerialized] = tuple\n  const args: AuthorizationTempo = {\n    address,\n    chainId: chainId === '0x' ? 0 : Number(chainId),\n    nonce: nonce === '0x' ? 0n : BigInt(nonce),\n  }\n  if (signatureSerialized)\n    args.signature = SignatureEnvelope.deserialize(signatureSerialized)\n  return from(args) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    AuthorizationTempo<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.TupleList} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n * @returns An {@link ox#AuthorizationTempo.List}.\n */\nexport function fromTupleList<const tupleList extends TupleList>(\n  tupleList: tupleList,\n): fromTupleList.ReturnType<tupleList> {\n  const list: Mutable<List> = []\n  for (const tuple of tupleList) list.push(fromTuple(tuple))\n  return list as never\n}\n\nexport declare namespace fromTupleList {\n  type ReturnType<tupleList extends TupleList> = Compute<\n    TupleList<tupleList extends TupleList<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }\n * )\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = P256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: false,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: true,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const challenge = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge,\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: AuthorizationTempo): Hex.Hex {\n  return hash(authorization, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = AuthorizationTempo.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The hash.\n */\nexport function hash(\n  authorization: AuthorizationTempo,\n  options: hash.Options = {},\n): Hex.Hex {\n  const { presign } = options\n  return Hash.keccak256(\n    Hex.concat(\n      '0x05',\n      Rlp.fromHex(\n        toTuple(\n          presign\n            ? {\n                address: authorization.address,\n                chainId: authorization.chainId,\n                nonce: authorization.nonce,\n              }\n            : authorization,\n        ),\n      ),\n    ),\n  )\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n\n  type Options = {\n    /** Whether to hash this authorization for signing. @default false */\n    presign?: boolean | undefined\n  }\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - An AA Authorization.\n * @returns An RPC-formatted AA Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const { address, chainId, nonce, signature } = authorization\n\n  return {\n    address,\n    chainId: Hex.fromNumber(chainId),\n    nonce: Hex.fromNumber(nonce),\n    signature: SignatureEnvelope.toRpc(signature),\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * }])\n * ```\n *\n * @param authorizationList - An AA Authorization List.\n * @returns An RPC-formatted AA Authorization List.\n */\nexport function toRpcList(authorizationList: ListSigned): ListRpc {\n  return authorizationList.map((x) => toRpc(x as unknown as Signed)) as never\n}\n\nexport declare namespace toRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = AuthorizationTempo.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n */\nexport function toTuple<const authorization extends AuthorizationTempo>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId, nonce } = authorization\n  const signature = authorization.signature\n    ? SignatureEnvelope.serialize(authorization.signature)\n    : undefined\n  return [\n    chainId ? Hex.fromNumber(chainId) : '0x',\n    address,\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    ...(signature ? [signature] : []),\n  ] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<\n    authorization extends AuthorizationTempo = AuthorizationTempo,\n  > = Compute<\n    Tuple<authorization extends AuthorizationTempo<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization_1 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = AuthorizationTempo.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#AuthorizationTempo.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n */\nexport function toTupleList<\n  const list extends\n    | readonly AuthorizationTempo<true>[]\n    | readonly AuthorizationTempo<false>[],\n>(list?: list | undefined): toTupleList.ReturnType<list> {\n  if (!list || list.length === 0) return []\n\n  const tupleList: Mutable<TupleList> = []\n  for (const authorization of list) tupleList.push(toTuple(authorization))\n\n  return tupleList as never\n}\n\nexport declare namespace toTupleList {\n  type ReturnType<\n    list extends\n      | readonly AuthorizationTempo<true>[]\n      | readonly AuthorizationTempo<false>[],\n  > = Compute<\n    TupleList<list extends readonly AuthorizationTempo<true>[] ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import type * as Address from '../core/Address.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute } from '../core/internal/types.js'\nimport * as Rlp from '../core/Rlp.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\n\n/**\n * Key authorization for provisioning access keys.\n *\n * Access keys allow a root key (e.g., a passkey) to delegate transaction signing to secondary\n * keys with customizable permissions including expiry timestamps and per-TIP-20 token spending\n * limits. This enables a user to sign transactions without repeated passkey prompts.\n *\n * The root key signs a `KeyAuthorization` to grant an access key permission to sign transactions\n * on its behalf. The authorization is attached to a transaction (which can be signed by the access\n * key itself), and the protocol validates the authorization before storing the key in the\n * AccountKeychain precompile.\n *\n * Key authorization fields:\n * - `address`: Address derived from the access key's public key (the \"key ID\")\n * - `chainId`: Chain ID for replay protection (0 = valid on any chain)\n * - `expiry`: Unix timestamp when the key expires (undefined = never expires)\n * - `limits`: Per-TIP-20 token spending limits (only applies to `transfer()` and `approve()` calls)\n * - `type`: Key type (`secp256k1`, `p256`, or `webAuthn`)\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n */\nexport type KeyAuthorization<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = {\n  /** Address derived from the public key of the key type. */\n  address: Address.Address\n  /** Chain ID for replay protection (0 = valid on any chain). */\n  chainId?: bigintType | undefined\n  /** Unix timestamp when key expires (0 = never expires). */\n  expiry?: numberType | null | undefined\n  /** TIP20 spending limits for this key. */\n  limits?: readonly TokenLimit<bigintType>[] | undefined\n  /** Key type. (secp256k1, P256, WebAuthn). */\n  type: SignatureEnvelope.Type\n} & (signed extends true\n  ? { signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType> }\n  : {\n      signature?:\n        | SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n        | undefined\n    })\n\n/** RPC representation of an {@link ox#KeyAuthorization.KeyAuthorization}. */\nexport type Rpc = Omit<\n  KeyAuthorization<false, Hex.Hex, Hex.Hex>,\n  'address' | 'signature' | 'type'\n> & {\n  keyId: Address.Address\n  keyType: SignatureEnvelope.Type\n  signature: SignatureEnvelope.SignatureEnvelopeRpc\n}\n\n/** Signed representation of a Key Authorization. */\nexport type Signed<bigintType = bigint, numberType = number> = KeyAuthorization<\n  true,\n  bigintType,\n  numberType\n>\n\ntype BaseTuple = readonly [\n  chainId: Hex.Hex,\n  keyType: Hex.Hex,\n  keyId: Address.Address,\n]\n\n/** Tuple representation of a Key Authorization. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      authorization:\n        | BaseTuple\n        | readonly [...BaseTuple, expiry: Hex.Hex]\n        | readonly [\n            ...BaseTuple,\n            expiry: Hex.Hex,\n            limits: readonly [token: Address.Address, limit: Hex.Hex][],\n          ],\n      signature: Hex.Hex,\n    ]\n  : readonly [\n      authorization:\n        | BaseTuple\n        | readonly [...BaseTuple, expiry: Hex.Hex]\n        | readonly [\n            ...BaseTuple,\n            expiry: Hex.Hex,\n            limits: readonly [token: Address.Address, limit: Hex.Hex][],\n          ],\n    ]\n\n/**\n * Token spending limit for access keys.\n *\n * Defines a per-TIP-20 token spending limit for an access key. Limits deplete as tokens\n * are spent and can be updated by the root key via `updateSpendingLimit()`.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n */\nexport type TokenLimit<bigintType = bigint> = {\n  /** Address of the TIP-20 token. */\n  token: Address.Address\n  /** Maximum spending amount for this token (enforced over the key's lifetime). */\n  limit: bigintType\n}\n\n/**\n * Converts a Key Authorization object into a typed {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * Use this to create an unsigned key authorization, then sign it with the root key using\n * {@link ox#KeyAuthorization.(getSignPayload:function)} and attach the signature. The signed authorization\n * can be included in a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} via the\n * `keyAuthorization` field to provision the access key on-chain.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ### Secp256k1 Key\n *\n * Standard Ethereum ECDSA key using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### WebCryptoP256 Key\n *\n * ```ts twoslash\n * import { Address, WebCryptoP256, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Attach a signature to a Key Authorization using a Secp256k1 private key to\n * authorize another Secp256k1 key on the account.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const rootPrivateKey = '0x...'\n * const signature = Secp256k1.sign({\n *   payload: KeyAuthorization.getSignPayload(authorization),\n *   privateKey: rootPrivateKey,\n * })\n *\n * const authorization_signed = KeyAuthorization.from(authorization, { signature })\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Attach a signature to a Key Authorization using a WebAuthn credential to\n * authorize a new WebCryptoP256 key on the account.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Address, Value, WebCryptoP256, WebAuthnP256 } from 'ox'\n * import { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: KeyAuthorization.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n *\n * const signatureEnvelope = SignatureEnvelope.from({ // [!code focus]\n *   signature, // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   metadata, // [!code focus]\n * })\n * const authorization_signed = KeyAuthorization.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - A Key Authorization tuple in object format.\n * @param options - Key Authorization options.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */\nexport function from<\n  const authorization extends KeyAuthorization | Rpc,\n  const signature extends SignatureEnvelope.from.Value | undefined = undefined,\n>(\n  authorization: authorization | KeyAuthorization,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.expiry === 'string')\n    return fromRpc(authorization as Rpc) as never\n  if (options.signature)\n    return {\n      ...authorization,\n      signature: SignatureEnvelope.from(options.signature),\n    } as never\n  return authorization as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = {\n    /** The {@link ox#SignatureEnvelope.SignatureEnvelope} to attach to the Key Authorization. */\n    signature?: signature | SignatureEnvelope.SignatureEnvelope | undefined\n  }\n\n  type ReturnType<\n    authorization extends KeyAuthorization | Rpc = KeyAuthorization,\n    signature extends SignatureEnvelope.from.Value | undefined =\n      | SignatureEnvelope.from.Value\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends SignatureEnvelope.from.Value\n            ? { signature: SignatureEnvelope.from.ReturnValue<signature> }\n            : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyAuthorization = KeyAuthorization.fromRpc({\n *   expiry: '0x174876e800',\n *   keyId: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   keyType: 'secp256k1',\n *   limits: [{ token: '0x20c0000000000000000000000000000000000001', limit: '0xf4240' }],\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0'\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Key Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { chainId = '0x0', keyId, expiry = 0, limits, keyType } = authorization\n  const signature = SignatureEnvelope.fromRpc(authorization.signature)\n  return {\n    address: keyId,\n    chainId: chainId === '0x' ? 0n : Hex.toBigInt(chainId),\n    expiry: Number(expiry),\n    limits: limits?.map((limit) => ({\n      token: limit.token,\n      limit: BigInt(limit.limit),\n    })),\n    signature,\n    type: keyType,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#KeyAuthorization.Tuple} to an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * ```\n *\n * @example\n * Unsigned Key Authorization tuple (no signature):\n *\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n * ])\n * ```\n *\n * @param tuple - The Key Authorization tuple.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [authorization, signatureSerialized] = tuple\n  const [chainId, keyType_hex, keyId, expiry, limits] = authorization\n  const keyType = (() => {\n    switch (keyType_hex) {\n      case '0x':\n      case '0x00':\n        return 'secp256k1'\n      case '0x01':\n        return 'p256'\n      case '0x02':\n        return 'webAuthn'\n      default:\n        throw new Error(`Invalid key type: ${keyType_hex}`)\n    }\n  })()\n  const args: KeyAuthorization = {\n    address: keyId,\n    expiry: typeof expiry !== 'undefined' ? Hex.toNumber(expiry) : undefined,\n    type: keyType,\n    ...(chainId !== '0x' ? { chainId: Hex.toBigInt(chainId) } : {}),\n    ...(typeof expiry !== 'undefined' ? { expiry: Hex.toNumber(expiry) } : {}),\n    ...(typeof limits !== 'undefined'\n      ? {\n          limits: limits.map(([token, limit]) => ({\n            token,\n            limit: BigInt(limit),\n          })),\n        }\n      : {}),\n  }\n  if (signatureSerialized)\n    args.signature = SignatureEnvelope.deserialize(signatureSerialized)\n  return from(args) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    KeyAuthorization<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * The root key must sign this payload to authorize the access key. The resulting signature\n * is attached to the key authorization via {@link ox#KeyAuthorization.(from:function)} with the\n * `signature` option.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const payload = KeyAuthorization.getSignPayload(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: KeyAuthorization): Hex.Hex {\n  return hash(authorization)\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const hash = KeyAuthorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The hash.\n */\nexport function hash(authorization: KeyAuthorization): Hex.Hex {\n  const [authorizationTuple] = toTuple(authorization)\n  const serialized = Rlp.fromHex(authorizationTuple)\n  return Hash.keccak256(serialized)\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.toRpc({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - A Key Authorization.\n * @returns An RPC-formatted Key Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const {\n    address,\n    chainId = 0n,\n    expiry,\n    limits,\n    type,\n    signature,\n  } = authorization\n\n  return {\n    chainId: chainId === 0n ? '0x' : Hex.fromNumber(chainId),\n    expiry: typeof expiry === 'number' ? Hex.fromNumber(expiry) : null,\n    limits: limits?.map(({ token, limit }) => ({\n      token,\n      limit: Hex.fromNumber(limit),\n    })),\n    keyId: address,\n    signature: SignatureEnvelope.toRpc(signature),\n    keyType: type,\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const tuple = KeyAuthorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   '0x174876e800',\n * // @log:   [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n * // @log:   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   'secp256k1',\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns A Tempo Key Authorization tuple.\n */\nexport function toTuple<const authorization extends KeyAuthorization>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId = 0n, expiry, limits } = authorization\n  const signature = authorization.signature\n    ? SignatureEnvelope.serialize(authorization.signature)\n    : undefined\n  const type = (() => {\n    switch (authorization.type) {\n      case 'secp256k1':\n        return '0x'\n      case 'p256':\n        return '0x01'\n      case 'webAuthn':\n        return '0x02'\n      default:\n        throw new Error(`Invalid key type: ${authorization.type}`)\n    }\n  })()\n  const authorizationTuple = [\n    chainId === 0n ? '0x' : Hex.fromNumber(chainId),\n    type,\n    address,\n    typeof expiry === 'number' ? Hex.fromNumber(expiry) : undefined,\n    limits?.map((limit) => [limit.token, Hex.fromNumber(limit.limit)]) ??\n      undefined,\n  ].filter(Boolean)\n  return [authorizationTuple, ...(signature ? [signature] : [])] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<authorization extends KeyAuthorization = KeyAuthorization> =\n    Compute<Tuple<authorization extends KeyAuthorization<true> ? true : false>>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport * as TokenId from './TokenId.js'\n\n/**\n * Converts a user token and validator token to a pool ID.\n *\n * Pool IDs are deterministic keys derived from two token addresses (order-independent)\n * used to identify trading pairs on Tempo's enshrined stablecoin DEX.\n *\n * [Stablecoin DEX Specification](https://docs.tempo.xyz/protocol/exchange/spec)\n *\n * @example\n * ```ts twoslash\n * import { PoolId } from 'ox/tempo'\n *\n * const poolId = PoolId.from({\n *   userToken: 1n,\n *   validatorToken: 2n,\n * })\n * ```\n *\n * @param value - User token and validator token.\n * @returns The pool ID.\n */\nexport function from(value: from.Value): Hex.Hex {\n  return Hash.keccak256(\n    Hex.concat(\n      Hex.padLeft(TokenId.toAddress(value.userToken), 32),\n      Hex.padLeft(TokenId.toAddress(value.validatorToken), 32),\n    ),\n  )\n}\n\nexport declare namespace from {\n  export type Value = {\n    /** User token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n}\n", "import * as Address from '../core/Address.js'\nimport * as Hex from '../core/Hex.js'\n\nconst tip20Prefix = '0x20c0'\n\nexport type TokenId = bigint\nexport type TokenIdOrAddress = TokenId | Address.Address\n\n/**\n * Converts a token ID or address to a token ID.\n *\n * TIP-20 is Tempo's native token standard for stablecoins with deterministic addresses\n * derived from sequential token IDs (prefix `0x20c0`).\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.from(1n)\n * ```\n *\n * @param tokenIdOrAddress - The token ID or address.\n * @returns The token ID.\n */\nexport function from(tokenIdOrAddress: TokenIdOrAddress | number): TokenId {\n  if (\n    typeof tokenIdOrAddress === 'bigint' ||\n    typeof tokenIdOrAddress === 'number'\n  )\n    return BigInt(tokenIdOrAddress)\n  return fromAddress(tokenIdOrAddress)\n}\n\n/**\n * Converts a TIP-20 token address to a token ID.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.fromAddress('0x20c00000000000000000000000000000000000000001')\n * ```\n *\n * @param address - The token address.\n * @returns The token ID.\n */\nexport function fromAddress(address: Address.Address): TokenId {\n  if (!address.toLowerCase().startsWith(tip20Prefix))\n    throw new Error('invalid tip20 address.')\n  return Hex.toBigInt(Hex.slice(address, tip20Prefix.length))\n}\n\n/**\n * Converts a TIP-20 token ID to an address.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const address = TokenId.toAddress(1n)\n * ```\n *\n * @param tokenId - The token ID.\n * @returns The address.\n */\nexport function toAddress(tokenId: TokenIdOrAddress): Address.Address {\n  if (typeof tokenId === 'string') {\n    Address.assert(tokenId)\n    return tokenId\n  }\n\n  const tokenIdHex = Hex.fromNumber(tokenId, { size: 18 })\n  return Hex.concat(tip20Prefix, tokenIdHex)\n}\n", "import * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\n\nexport const roles = [\n  'defaultAdmin',\n  'pause',\n  'unpause',\n  'issuer',\n  'burnBlocked',\n] as const\nexport type TokenRole = (typeof roles)[number]\n\nexport const toPreHashed = {\n  defaultAdmin: 'DEFAULT_ADMIN_ROLE',\n  pause: 'PAUSE_ROLE',\n  unpause: 'UNPAUSE_ROLE',\n  issuer: 'ISSUER_ROLE',\n  burnBlocked: 'BURN_BLOCKED_ROLE',\n} as const satisfies Record<TokenRole, string>\n\n/**\n * Serializes a token role to its keccak256 hash representation.\n *\n * TIP-20 includes a built-in RBAC system with roles like `ISSUER_ROLE` (mint/burn),\n * `PAUSE_ROLE`/`UNPAUSE_ROLE` (emergency controls), and `BURN_BLOCKED_ROLE` (compliance).\n *\n * [TIP-20 RBAC](https://docs.tempo.xyz/protocol/tip20/overview#role-based-access-control-rbac)\n *\n * @example\n * ```ts twoslash\n * import { TokenRole } from 'ox/tempo'\n *\n * const hash = TokenRole.serialize('issuer')\n * ```\n *\n * @param role - The token role to serialize.\n * @returns The keccak256 hash of the role.\n */\nexport function serialize(role: TokenRole) {\n  if (role === 'defaultAdmin')\n    return '0x0000000000000000000000000000000000000000000000000000000000000000'\n  return Hash.keccak256(\n    Hex.fromString(toPreHashed[role as keyof typeof toPreHashed] ?? role),\n  )\n}\n", "import type * as AccessList from './AccessList.js'\nimport type * as Address from './Address.js'\nimport * as Authorization from './Authorization.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf, UnionCompute } from './internal/types.js'\nimport * as Signature from './Signature.js'\n\n/**\n * A Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n */\nexport type Transaction<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = UnionCompute<\n  OneOf<\n    | Legacy<pending, bigintType, numberType>\n    | Eip1559<pending, bigintType, numberType>\n    | Eip2930<pending, bigintType, numberType>\n    | Eip4844<pending, bigintType, numberType>\n    | Eip7702<pending, bigintType, numberType>\n    | (Base & { type: Hex.Hex })\n  >\n>\n\n/**\n * An RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n */\nexport type Rpc<pending extends boolean = false> = UnionCompute<\n  OneOf<\n    | LegacyRpc<pending>\n    | Eip1559Rpc<pending>\n    | Eip2930Rpc<pending>\n    | Eip4844Rpc<pending>\n    | Eip7702Rpc<pending>\n    | (BaseRpc & { type: Hex.Hex })\n  >\n>\n\n/** Base properties of a Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Base<\n  type extends string = string,\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** Hash of the block that contains this transaction, or `null` if pending. */\n  blockHash: pending extends true ? null : Hex.Hex\n  /** Number of block containing this transaction or `null` if pending */\n  blockNumber: pending extends true ? null : bigintType\n  /** Chain ID that this transaction is valid on. */\n  chainId: numberType\n  /** @alias `input` Added for TransactionEnvelope - Transaction compatibility. */\n  data?: Hex.Hex | undefined\n  /** Sender of this transaction */\n  from: Address.Address\n  /** Hash of this transaction */\n  hash: Hex.Hex\n  /** Contract code or a hashed method call with encoded args */\n  input: Hex.Hex\n  /** Gas provided for transaction execution */\n  gas: bigintType\n  /** Unique number identifying this transaction */\n  nonce: bigintType\n  /** Transaction recipient. `null` if the transaction is a contract creation. */\n  to: Address.Address | null\n  /** Index of this transaction in the block or `null` if pending */\n  transactionIndex: pending extends true ? null : numberType\n  /** Transaction type */\n  type: type\n  /** Value in wei sent with this transaction */\n  value: bigintType\n  /** ECDSA signature r. */\n  r: bigintType\n  /** ECDSA signature s. */\n  s: bigintType\n  /** ECDSA signature yParity. */\n  yParity: numberType\n  /** @deprecated ECDSA signature v (for backwards compatibility). */\n  v?: numberType | undefined\n}>\n\n/** Base properties of an RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type BaseRpc<\n  type extends string = string,\n  pending extends boolean = false,\n> = Base<type, pending, Hex.Hex, Hex.Hex>\n\n/** An [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip1559<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip1559',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** Effective gas price paid by the sender in wei. */\n    gasPrice?: bigintType | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n  }\n>\n\n/** An [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip1559Rpc<pending extends boolean = false> = Compute<\n  Eip1559<pending, Hex.Hex, Hex.Hex, ToRpcType['eip1559']>\n>\n\n/** An [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip2930<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip2930',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** The gas price willing to be paid by the sender (in wei). */\n    gasPrice: bigintType\n  }\n>\n\n/** An RPC [EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip2930Rpc<pending extends boolean = false> = Compute<\n  Eip2930<pending, Hex.Hex, Hex.Hex, ToRpcType['eip2930']>\n>\n\n/** An [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip4844<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip4844',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** List of versioned blob hashes associated with the transaction's blobs. */\n    blobVersionedHashes: readonly Hex.Hex[]\n    /** Total fee per blob gas in wei. */\n    maxFeePerBlobGas: bigintType\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n  }\n>\n\n/** An RPC [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip4844Rpc<pending extends boolean = false> = Compute<\n  Eip4844<pending, Hex.Hex, Hex.Hex, ToRpcType['eip4844']>\n>\n\n/** An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip7702<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'eip7702',\n> = Compute<\n  Base<type, pending, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** EIP-7702 Authorization list for the transaction. */\n    authorizationList: Authorization.ListSigned<bigintType, numberType>\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n  }\n>\n\n/** An RPC [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Eip7702Rpc<pending extends boolean = false> = Compute<\n  Eip7702<pending, Hex.Hex, Hex.Hex, ToRpcType['eip7702']>\n>\n\n/** An legacy Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type Legacy<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'legacy',\n> = Compute<\n  Omit<\n    Base<type, pending, bigintType, numberType>,\n    'chainId' | 'v' | 'yParity'\n  > & {\n    chainId?: numberType | undefined\n    /** The gas price willing to be paid by the sender (in wei). */\n    gasPrice: bigintType\n    /** ECDSA signature v. */\n    v: numberType\n    /** ECDSA signature yParity. */\n    yParity?: numberType | undefined\n  }\n>\n\n/** A legacy RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml). */\nexport type LegacyRpc<pending extends boolean = false> = Compute<\n  Legacy<pending, Hex.Hex, Hex.Hex, ToRpcType['legacy']>\n>\n\n/** Type to RPC Type mapping. */\nexport const toRpcType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\n/** Type to RPC Type mapping. */\nexport type ToRpcType = typeof toRpcType & {\n  [type: string]: `0x${string}`\n}\n\n/** RPC Type to Type mapping. */\nexport const fromRpcType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const\n\n/** RPC Type to Type mapping. */\n\nexport type FromRpcType = typeof fromRpcType & {\n  [type: `0x${string}`]: string\n}\n\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nexport function fromRpc<\n  const transaction extends Rpc | null,\n  pending extends boolean = false,\n>(\n  transaction: transaction | Rpc<pending> | null,\n  _options: fromRpc.Options<pending> = {},\n): transaction extends Rpc<pending> ? Transaction<pending> : null {\n  if (!transaction) return null as never\n\n  const signature = Signature.extract(transaction)\n\n  const transaction_ = {\n    ...transaction,\n    ...signature,\n  } as unknown as Transaction<boolean>\n\n  transaction_.blockNumber = transaction.blockNumber\n    ? BigInt(transaction.blockNumber)\n    : null\n  transaction_.data = transaction.input\n  transaction_.gas = BigInt(transaction.gas ?? 0n)\n  transaction_.nonce = BigInt(transaction.nonce ?? 0n)\n  transaction_.transactionIndex = transaction.transactionIndex\n    ? Number(transaction.transactionIndex)\n    : null\n  transaction_.value = BigInt(transaction.value ?? 0n)\n\n  if (transaction.authorizationList)\n    transaction_.authorizationList = Authorization.fromRpcList(\n      transaction.authorizationList,\n    )\n  if (transaction.chainId) transaction_.chainId = Number(transaction.chainId)\n  if (transaction.gasPrice) transaction_.gasPrice = BigInt(transaction.gasPrice)\n  if (transaction.maxFeePerBlobGas)\n    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas)\n  if (transaction.maxFeePerGas)\n    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas)\n  if (transaction.maxPriorityFeePerGas)\n    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas)\n  if (transaction.type)\n    transaction_.type =\n      (fromRpcType as any)[transaction.type] ?? transaction.type\n  if (signature) transaction_.v = Signature.yParityToV(signature.yParity)\n\n  return transaction_ as never\n}\n\nexport declare namespace fromRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   chainId: 1,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n *   v: 27,\n *   value: 700000000000000000n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nexport function toRpc<pending extends boolean = false>(\n  transaction: Transaction<pending>,\n  _options?: toRpc.Options<pending>,\n): Rpc<pending> {\n  const rpc = {} as Rpc<boolean>\n\n  rpc.blockHash = transaction.blockHash\n  rpc.blockNumber =\n    typeof transaction.blockNumber === 'bigint'\n      ? Hex.fromNumber(transaction.blockNumber)\n      : null\n  rpc.from = transaction.from\n  rpc.gas = Hex.fromNumber(transaction.gas ?? 0n)\n  rpc.hash = transaction.hash\n  rpc.input = transaction.input\n  rpc.nonce = Hex.fromNumber(transaction.nonce ?? 0n)\n  rpc.to = transaction.to\n  rpc.transactionIndex = transaction.transactionIndex\n    ? Hex.fromNumber(transaction.transactionIndex)\n    : null\n  rpc.type = (toRpcType as any)[transaction.type] ?? transaction.type\n  rpc.value = Hex.fromNumber(transaction.value ?? 0n)\n\n  if (transaction.accessList) rpc.accessList = transaction.accessList\n  if (transaction.authorizationList)\n    rpc.authorizationList = Authorization.toRpcList(\n      transaction.authorizationList,\n    )\n  if (transaction.blobVersionedHashes)\n    rpc.blobVersionedHashes = transaction.blobVersionedHashes\n  if (transaction.chainId) rpc.chainId = Hex.fromNumber(transaction.chainId)\n  if (typeof transaction.gasPrice === 'bigint')\n    rpc.gasPrice = Hex.fromNumber(transaction.gasPrice)\n  if (typeof transaction.maxFeePerBlobGas === 'bigint')\n    rpc.maxFeePerBlobGas = Hex.fromNumber(transaction.maxFeePerBlobGas)\n  if (typeof transaction.maxFeePerGas === 'bigint')\n    rpc.maxFeePerGas = Hex.fromNumber(transaction.maxFeePerGas)\n  if (typeof transaction.maxPriorityFeePerGas === 'bigint')\n    rpc.maxPriorityFeePerGas = Hex.fromNumber(transaction.maxPriorityFeePerGas)\n  if (typeof transaction.r === 'bigint')\n    rpc.r = Hex.fromNumber(transaction.r, { size: 32 })\n  if (typeof transaction.s === 'bigint')\n    rpc.s = Hex.fromNumber(transaction.s, { size: 32 })\n  if (typeof transaction.v === 'number')\n    rpc.v = Hex.fromNumber(transaction.v, { size: 1 })\n  if (typeof transaction.yParity === 'number')\n    rpc.yParity = transaction.yParity === 0 ? '0x0' : '0x1'\n\n  return rpc as Rpc<pending>\n}\n\nexport declare namespace toRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as AccessList from '../core/AccessList.js'\nimport type * as Address from '../core/Address.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Compute, OneOf, UnionCompute } from '../core/internal/types.js'\nimport * as Signature from '../core/Signature.js'\nimport * as ox_Transaction from '../core/Transaction.js'\nimport * as AuthorizationTempo from './AuthorizationTempo.js'\nimport * as KeyAuthorization from './KeyAuthorization.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\nimport type { Call } from './TxEnvelopeTempo.js'\n\n/**\n * A Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n */\nexport type Transaction<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = UnionCompute<\n  OneOf<\n    | Tempo<pending, bigintType, numberType>\n    | ox_Transaction.Transaction<pending, bigintType, numberType>\n  >\n>\n\n/**\n * An RPC Transaction as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/transaction.yaml).\n */\nexport type Rpc<pending extends boolean = false> = UnionCompute<\n  OneOf<TempoRpc<pending> | ox_Transaction.Rpc<pending>>\n>\n\n/**\n * Native account abstraction transaction (type `0x76`).\n *\n * Features configurable fee tokens, call batching, fee sponsorship, access keys,\n * parallelizable nonces, and scheduled execution via `validAfter`/`validBefore`.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction Tempo Transaction Specification}\n */\nexport type Tempo<\n  pending extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = 'tempo',\n> = Compute<\n  Omit<\n    ox_Transaction.Base<type, pending, bigintType, numberType>,\n    // Tempo transactions don't have these properties.\n    'input' | 'to' | 'value' | 'v' | 'r' | 's' | 'yParity'\n  > & {\n    /** EIP-2930 Access List. */\n    accessList: AccessList.AccessList\n    /** EIP-7702 Authorization list for the transaction. */\n    authorizationList?:\n      | AuthorizationTempo.ListSigned<bigintType, numberType>\n      | undefined\n    /** Array of calls to execute. */\n    calls: readonly Call<bigintType>[]\n    /** Fee payer signature. */\n    feePayerSignature?:\n      | {\n          /** ECDSA signature r. */\n          r: bigintType\n          /** ECDSA signature s. */\n          s: bigintType\n          /** ECDSA signature yParity. */\n          yParity: numberType\n          /** @deprecated ECDSA signature v (for backwards compatibility). */\n          v?: numberType | undefined\n        }\n      | undefined\n    /** Fee token preference. */\n    feeToken: Address.Address\n    /** Effective gas price paid by the sender in wei. */\n    gasPrice?: bigintType | undefined\n    /** Key authorization for provisioning a new access key. */\n    keyAuthorization?:\n      | KeyAuthorization.KeyAuthorization<true, bigintType, numberType>\n      | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas: bigintType\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas: bigintType\n    /** Nonce key for 2D nonce system (192 bits). */\n    nonceKey?: bigintType | undefined\n    /** Sender signature. */\n    signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n    /** Transaction can only be included in a block before this timestamp. */\n    validBefore?: numberType | undefined\n    /** Transaction can only be included in a block after this timestamp. */\n    validAfter?: numberType | undefined\n  }\n>\n\n/**\n * Native account abstraction transaction in RPC format.\n */\nexport type TempoRpc<pending extends boolean = false> = Compute<\n  Omit<\n    Tempo<pending, Hex.Hex, Hex.Hex, ToRpcType['tempo']>,\n    'authorizationList' | 'calls' | 'keyAuthorization' | 'signature'\n  > & {\n    aaAuthorizationList?: AuthorizationTempo.ListRpc | undefined\n    calls:\n      | readonly {\n          input?: Hex.Hex | undefined\n          to?: Hex.Hex | undefined\n          value?: Hex.Hex | undefined\n        }[]\n      | undefined\n    keyAuthorization?: KeyAuthorization.Rpc | undefined\n    signature: SignatureEnvelope.SignatureEnvelopeRpc\n  }\n>\n\n/** Type to RPC Type mapping. */\nexport const toRpcType = {\n  ...ox_Transaction.toRpcType,\n  tempo: '0x76',\n} as const\n\n/** Type to RPC Type mapping. */\nexport type ToRpcType = typeof toRpcType & {\n  [type: string]: `0x${string}`\n}\n\n/** RPC Type to Type mapping. */\nexport const fromRpcType = {\n  ...ox_Transaction.fromRpcType,\n  '0x76': 'tempo',\n} as const\n\n/** RPC Type to Type mapping. */\n\nexport type FromRpcType = typeof fromRpcType & {\n  [type: `0x${string}`]: string\n}\n\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   calls: [\n *     {\n *       input: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: '0x9b6e64a8ec60000',\n *     },\n *   ],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   signature: {\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     type: 'secp256k1',\n *     yParity: '0x0',\n *   },\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x76',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nexport function fromRpc<\n  const transaction extends Rpc | null,\n  pending extends boolean = false,\n>(\n  transaction: transaction | Rpc<pending> | null,\n  _options: fromRpc.Options<pending> = {},\n): transaction extends Rpc<pending> ? Transaction<pending> : null {\n  if (!transaction) return null as never\n\n  const transaction_ = ox_Transaction.fromRpc(\n    transaction as ox_Transaction.Rpc<pending>,\n  ) as Transaction<pending>\n\n  transaction_.type = fromRpcType[transaction.type as keyof typeof fromRpcType]\n\n  if (transaction.aaAuthorizationList) {\n    transaction_.authorizationList = AuthorizationTempo.fromRpcList(\n      transaction.aaAuthorizationList,\n    )\n    delete (transaction_ as any).aaAuthorizationList\n  }\n  if (transaction.calls)\n    transaction_.calls = transaction.calls.map((call) => ({\n      to: call.to,\n      value: call.value && call.value !== '0x' ? BigInt(call.value) : undefined,\n      // @ts-expect-error\n      data: call.input || call.data || '0x',\n    }))\n  if (transaction.feeToken) transaction_.feeToken = transaction.feeToken\n  if (transaction.nonceKey) transaction_.nonceKey = BigInt(transaction.nonceKey)\n  if (transaction.signature)\n    transaction_.signature = SignatureEnvelope.fromRpc(transaction.signature)\n  if (transaction.validAfter)\n    transaction_.validAfter = Number(transaction.validAfter)\n  if (transaction.validBefore)\n    transaction_.validBefore = Number(transaction.validBefore)\n  if (transaction.keyAuthorization)\n    transaction_.keyAuthorization = KeyAuthorization.fromRpc(\n      transaction.keyAuthorization,\n    )\n  if (transaction.feePayerSignature) {\n    transaction_.feePayerSignature = Signature.fromRpc(\n      transaction.feePayerSignature,\n    )\n    ;(transaction_.feePayerSignature as any).v = Signature.yParityToV(\n      transaction_.feePayerSignature.yParity,\n    )\n  }\n\n  return transaction_ as never\n}\n\nexport declare namespace fromRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = ox_Transaction.fromRpc.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: 700000000000000000n,\n *     },\n *   ],\n *   chainId: 1,\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   signature: {\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *     type: 'secp256k1',\n *   },\n *   transactionIndex: 2,\n *   type: 'tempo',\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nexport function toRpc<pending extends boolean = false>(\n  transaction: Transaction<pending>,\n  _options?: toRpc.Options<pending>,\n): Rpc<pending> {\n  const rpc = ox_Transaction.toRpc(\n    transaction as ox_Transaction.Transaction<pending>,\n  ) as Rpc<pending>\n\n  rpc.type = toRpcType[transaction.type as keyof typeof toRpcType]\n\n  if (transaction.authorizationList)\n    rpc.aaAuthorizationList = AuthorizationTempo.toRpcList(\n      transaction.authorizationList as AuthorizationTempo.ListSigned,\n    )\n  if (transaction.calls)\n    rpc.calls = transaction.calls.map((call) => ({\n      to: call.to,\n      value: call.value ? Hex.fromNumber(call.value) : undefined,\n      data: call.data,\n    }))\n  if (transaction.feeToken) rpc.feeToken = transaction.feeToken\n  if (transaction.keyAuthorization)\n    rpc.keyAuthorization = KeyAuthorization.toRpc(transaction.keyAuthorization)\n  if (transaction.feePayerSignature) {\n    rpc.feePayerSignature = Signature.toRpc(\n      transaction.feePayerSignature,\n    ) as any\n    ;(rpc.feePayerSignature as any).v = Hex.fromNumber(\n      Signature.yParityToV(transaction.feePayerSignature?.yParity),\n    )\n  }\n  if (transaction.signature)\n    rpc.signature = SignatureEnvelope.toRpc(transaction.signature)\n  if (typeof transaction.validAfter === 'number')\n    rpc.validAfter = Hex.fromNumber(transaction.validAfter)\n  if (typeof transaction.validBefore === 'number')\n    rpc.validBefore = Hex.fromNumber(transaction.validBefore)\n\n  return rpc as Rpc<pending>\n}\n\nexport declare namespace toRpc {\n  type Options<pending extends boolean = false> = {\n    pending?: pending | boolean | undefined\n  }\n\n  type ErrorType = ox_Transaction.toRpc.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Log from './Log.js'\n\n/** An Transaction Receipt as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type TransactionReceipt<\n  status = Status,\n  type = Type,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<{\n  /** The actual value per gas deducted from the sender's account for blob gas. Only specified for blob transactions as defined by EIP-4844. */\n  blobGasPrice?: bigintType | undefined\n  /** The amount of blob gas used. Only specified for blob transactions as defined by EIP-4844. */\n  blobGasUsed?: bigintType | undefined\n  /** Hash of block containing this transaction */\n  blockHash: Hex.Hex\n  /** Number of block containing this transaction */\n  blockNumber: bigintType\n  /** Address of new contract or `null` if no contract was created */\n  contractAddress?: Address.Address | null | undefined\n  /** Gas used by this and all preceding transactions in this block */\n  cumulativeGasUsed: bigintType\n  /** Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. */\n  effectiveGasPrice: bigintType\n  /** Transaction sender */\n  from: Address.Address\n  /** Gas used by this transaction */\n  gasUsed: bigintType\n  /** List of log objects generated by this transaction */\n  logs: Log.Log<false, bigintType, numberType>[]\n  /** Logs bloom filter */\n  logsBloom: Hex.Hex\n  /** The post-transaction state root. Only specified for transactions included before the Byzantium upgrade. */\n  root?: Hex.Hex | undefined\n  /** `success` if this transaction was successful or `reverted` if it failed */\n  status: status\n  /** Transaction recipient or `null` if deploying a contract */\n  to: Address.Address | null\n  /** Hash of this transaction */\n  transactionHash: Hex.Hex\n  /** Index of this transaction in the block */\n  transactionIndex: numberType\n  /** Transaction type */\n  type: type\n}>\n\n/** An RPC Transaction Receipt as defined in the [Execution API specification](https://github.com/ethereum/execution-apis/blob/main/src/schemas/receipt.yaml). */\nexport type Rpc = TransactionReceipt<RpcStatus, RpcType, Hex.Hex, Hex.Hex>\n\n/**\n * Union of Transaction Receipt statuses.\n *\n * - `success`\n * - `reverted`\n */\nexport type Status = 'success' | 'reverted'\n\n/**\n * Union of RPC Transaction Receipt statuses.\n *\n * - `0x0`\n * - `0x1`\n */\nexport type RpcStatus = '0x0' | '0x1'\n\n/**\n * Union of Transaction Receipt types.\n *\n * - `legacy`\n * - `eip1559`\n * - `eip2930`\n * - `eip4844`\n * - `eip7702`\n * - any other string\n */\nexport type Type =\n  | 'legacy'\n  | 'eip1559'\n  | 'eip2930'\n  | 'eip4844'\n  | 'eip7702'\n  | (string & {})\n\n/**\n * Union of RPC Transaction Receipt types.\n *\n * - `0x0`: legacy transactions\n * - `0x1`: EIP-1559 transactions\n * - `0x2`: EIP-2930 transactions\n * - `0x3`: EIP-4844 transactions\n * - `0x4`: EIP-7702 transactions\n * - any other string\n */\nexport type RpcType = '0x0' | '0x1' | '0x2' | '0x3' | '0x4' | (string & {})\n\n/** RPC status to status mapping. */\nexport const fromRpcStatus = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\n/** Status to RPC status mapping. */\nexport const toRpcStatus = {\n  reverted: '0x0',\n  success: '0x1',\n} as const\n\n/** RPC type to type mapping. */\nexport const fromRpcType = {\n  '0x0': 'legacy',\n  '0x1': 'eip2930',\n  '0x2': 'eip1559',\n  '0x3': 'eip4844',\n  '0x4': 'eip7702',\n} as const\n\n/** Type to RPC type mapping. */\nexport const toRpcType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\n/**\n * Converts a {@link ox#TransactionReceipt.Rpc} to an {@link ox#TransactionReceipt.TransactionReceipt}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.fromRpc({\n *   blobGasPrice: '0x42069',\n *   blobGasUsed: '0x1337',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   contractAddress: null,\n *   cumulativeGasUsed: '0x82515',\n *   effectiveGasPrice: '0x21c2f6c09',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: '0x2abba',\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   status: '0x1',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: '0x2',\n *   type: '0x2',\n * })\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an example of how to use the `TransactionReceipt.fromRpc` method to convert an RPC transaction receipt to a {@link ox#TransactionReceipt.TransactionReceipt} object.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = await window.ethereum!\n *   .request({\n *     method: 'eth_getTransactionReceipt',\n *     params: [\n *       '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *     ],\n *   })\n *   .then(TransactionReceipt.fromRpc) // [!code hl]\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param receipt - The RPC receipt to convert.\n * @returns An instantiated {@link ox#TransactionReceipt.TransactionReceipt}.\n */\nexport function fromRpc<const receipt extends Rpc | null>(\n  receipt: receipt | Rpc | null,\n): receipt extends Rpc ? TransactionReceipt : null {\n  if (!receipt) return null as never\n\n  return {\n    ...receipt,\n    blobGasPrice: receipt.blobGasPrice\n      ? BigInt(receipt.blobGasPrice)\n      : undefined,\n    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : undefined,\n    blockNumber: BigInt(receipt.blockNumber ?? 0n),\n    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),\n    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),\n    gasUsed: BigInt(receipt.gasUsed ?? 0n),\n    logs: receipt.logs.map((log) => Log.fromRpc(log, { pending: false })),\n    status: fromRpcStatus[receipt.status],\n    transactionIndex: Number(receipt.transactionIndex ?? 0),\n    type: (fromRpcType as any)[receipt.type] || receipt.type,\n  } as never\n}\n\nexport declare namespace fromRpc {\n  export type ErrorType = Log.fromRpc.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#TransactionReceipt.TransactionReceipt} to a {@link ox#TransactionReceipt.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox'\n *\n * const receipt = TransactionReceipt.toRpc({\n *   blobGasPrice: 270441n,\n *   blobGasUsed: 4919n,\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   contractAddress: null,\n *   cumulativeGasUsed: 533781n,\n *   effectiveGasPrice: 9062804489n,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: 175034n,\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   root: undefined,\n *   status: 'success',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n * })\n * // @log: {\n * // @log:   blobGasPrice: \"0x042069\",\n * // @log:   blobGasUsed: \"0x1337\",\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: \"0x012f296f\",\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: \"0x082515\",\n * // @log:   effectiveGasPrice: \"0x021c2f6c09\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: \"0x02abba\",\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"0x1\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: \"0x02\",\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The receipt to convert.\n * @returns An RPC receipt.\n */\nexport function toRpc(receipt: TransactionReceipt): Rpc {\n  return {\n    blobGasPrice: receipt.blobGasPrice\n      ? Hex.fromNumber(receipt.blobGasPrice)\n      : undefined,\n    blobGasUsed: receipt.blobGasUsed\n      ? Hex.fromNumber(receipt.blobGasUsed)\n      : undefined,\n    blockHash: receipt.blockHash,\n    blockNumber: Hex.fromNumber(receipt.blockNumber),\n    contractAddress: receipt.contractAddress,\n    cumulativeGasUsed: Hex.fromNumber(receipt.cumulativeGasUsed),\n    effectiveGasPrice: Hex.fromNumber(receipt.effectiveGasPrice),\n    from: receipt.from,\n    gasUsed: Hex.fromNumber(receipt.gasUsed),\n    logs: receipt.logs.map(Log.toRpc as never),\n    logsBloom: receipt.logsBloom,\n    root: receipt.root,\n    status: toRpcStatus[receipt.status],\n    to: receipt.to,\n    transactionHash: receipt.transactionHash,\n    transactionIndex: Hex.fromNumber(receipt.transactionIndex),\n    type: (toRpcType as any)[receipt.type] ?? receipt.type,\n  }\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n", "import type * as Address from '../core/Address.js'\nimport type * as Hex from '../core/Hex.js'\nimport type { Compute } from '../core/internal/types.js'\nimport * as ox_TransactionReceipt from '../core/TransactionReceipt.js'\n\n/**\n * Tempo transaction receipt.\n *\n * Extends standard receipts with `feePayer` (the address that paid fees) and\n * `feeToken` (the TIP-20 token used for fee payment).\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n */\nexport type TransactionReceipt<\n  status = ox_TransactionReceipt.Status,\n  type = ox_TransactionReceipt.Type,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  ox_TransactionReceipt.TransactionReceipt<\n    status,\n    type,\n    bigintType,\n    numberType\n  > & {\n    /** Address of the fee payer. */\n    feePayer?: Address.Address | undefined\n    /** Address of the fee token. */\n    feeToken?: Address.Address | undefined\n  }\n>\n\nexport type Rpc = TransactionReceipt<\n  ox_TransactionReceipt.RpcStatus,\n  ox_TransactionReceipt.RpcType,\n  Hex.Hex,\n  Hex.Hex\n>\n\nexport type Type = 'tempo' | ox_TransactionReceipt.Type\n\nexport type RpcType = '0x76' | ox_TransactionReceipt.RpcType\n\nexport type Status = ox_TransactionReceipt.Status\n\nexport type RpcStatus = ox_TransactionReceipt.RpcStatus\n\n/** RPC type to type mapping. */\nexport const fromRpcType = {\n  ...ox_TransactionReceipt.fromRpcType,\n  '0x76': 'tempo',\n} as const\n\n/** Type to RPC type mapping. */\nexport const toRpcType = {\n  ...ox_TransactionReceipt.toRpcType,\n  tempo: '0x76',\n} as const\n\n/**\n * Converts an RPC receipt to a TransactionReceipt.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox/tempo'\n *\n * const receipt = TransactionReceipt.fromRpc({\n *   blobGasPrice: '0x42069',\n *   blobGasUsed: '0x1337',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   contractAddress: null,\n *   cumulativeGasUsed: '0x82515',\n *   effectiveGasPrice: '0x21c2f6c09',\n *   feePayer: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   feeToken: '0x20c0000000000000000000000000000000000001',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: '0x2abba',\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   status: '0x1',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: '0x2',\n *   type: '0x2',\n * })\n * // @log: {\n * // @log:   blobGasPrice: 270441n,\n * // @log:   blobGasUsed: 4919n,\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: 19868015n,\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: 533781n,\n * // @log:   effectiveGasPrice: 9062804489n,\n * // @log:   feePayer: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   feeToken: \"0x20c0000000000000000000000000000000000001\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: 175034n,\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"success\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: 2,\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The RPC receipt to convert.\n * @returns A TransactionReceipt.\n */\nexport function fromRpc<const receipt extends Rpc | null>(\n  receipt: receipt | Rpc | null,\n): receipt extends Rpc ? TransactionReceipt : null {\n  return ox_TransactionReceipt.fromRpc(\n    receipt as ox_TransactionReceipt.Rpc,\n  ) as never\n}\n\nexport declare namespace fromRpc {\n  export type ErrorType = ox_TransactionReceipt.fromRpc.ErrorType\n}\n\n/**\n * Converts a TransactionReceipt to an RPC receipt.\n *\n * @example\n * ```ts twoslash\n * import { TransactionReceipt } from 'ox/tempo'\n *\n * const receipt = TransactionReceipt.toRpc({\n *   blobGasPrice: 270441n,\n *   blobGasUsed: 4919n,\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   contractAddress: null,\n *   cumulativeGasUsed: 533781n,\n *   effectiveGasPrice: 9062804489n,\n *   feePayer: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   feeToken: '0x20c0000000000000000000000000000000000001',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gasUsed: 175034n,\n *   logs: [],\n *   logsBloom:\n *     '0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000',\n *   root: undefined,\n *   status: 'success',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionHash:\n *     '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n * })\n * // @log: {\n * // @log:   blobGasPrice: \"0x042069\",\n * // @log:   blobGasUsed: \"0x1337\",\n * // @log:   blockHash: \"0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b\",\n * // @log:   blockNumber: \"0x012f296f\",\n * // @log:   contractAddress: null,\n * // @log:   cumulativeGasUsed: \"0x082515\",\n * // @log:   effectiveGasPrice: \"0x021c2f6c09\",\n * // @log:   feePayer: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   feeToken: \"0x20c0000000000000000000000000000000000001\",\n * // @log:   from: \"0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6\",\n * // @log:   gasUsed: \"0x02abba\",\n * // @log:   logs: [],\n * // @log:   logsBloom: \"0x00200000000000000000008080000000000000000040000000000000000000000000000000000000000000000000000022000000080000000000000000000000000000080000000000000008000000200000000000000000000200008020400000000000000000280000000000100000000000000000000000000010000000000000000000020000000000000020000000000001000000080000004000000000000000000000000000000000000000000000400000000000001000000000000000000002000000000000000020000000000000000000001000000000000000000000200000000000000000000000000000001000000000c00000000000000000\",\n * // @log:   root: undefined,\n * // @log:   status: \"0x1\",\n * // @log:   to: \"0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad\",\n * // @log:   transactionHash: \"0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0\",\n * // @log:   transactionIndex: \"0x02\",\n * // @log:   type: \"eip1559\",\n * // @log: }\n * ```\n *\n * @param receipt - The receipt to convert.\n * @returns An RPC receipt.\n */\nexport function toRpc(receipt: TransactionReceipt): Rpc {\n  const rpc = ox_TransactionReceipt.toRpc(\n    receipt as ox_TransactionReceipt.TransactionReceipt,\n  ) as Rpc\n  return {\n    ...rpc,\n    feePayer: receipt.feePayer,\n    feeToken: receipt.feeToken,\n  }\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = ox_TransactionReceipt.toRpc.ErrorType\n}\n", "import * as AccessList from '../core/AccessList.js'\nimport * as Address from '../core/Address.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type {\n  Assign,\n  Compute,\n  OneOf,\n  PartialBy,\n  UnionPartialBy,\n} from '../core/internal/types.js'\nimport * as Rlp from '../core/Rlp.js'\nimport * as Signature from '../core/Signature.js'\nimport * as TransactionEnvelope from '../core/TxEnvelope.js'\nimport * as AuthorizationTempo from './AuthorizationTempo.js'\nimport * as KeyAuthorization from './KeyAuthorization.js'\nimport * as SignatureEnvelope from './SignatureEnvelope.js'\nimport * as TokenId from './TokenId.js'\n\n/**\n * Represents a single call within a Tempo transaction.\n *\n * Tempo transactions support batching multiple calls for atomic execution.\n *\n * [Batch Calls](https://docs.tempo.xyz/protocol/transactions#batch-calls)\n */\nexport type Call<bigintType = bigint> = {\n  /** Call data. */\n  data?: Hex.Hex | undefined\n  /** The target address or contract creation. */\n  to?: Address.Address | undefined\n  /** Value to send (in wei). */\n  value?: bigintType | undefined\n}\n\n/**\n * Tempo transaction envelope (type `0x76`).\n *\n * A new EIP-2718 transaction type exclusively available on Tempo, designed for payment\n * use cases with the following features:\n *\n * - **Configurable Fee Tokens**: Pay transaction fees with any USD-denominated TIP-20 token.\n *   The Fee AMM automatically converts to the validator's preferred token.\n *\n * - **Fee Sponsorship**: A third-party fee payer can pay fees on behalf of the sender using\n *   a dual-signature scheme (sender signs tx, fee payer signs over tx + sender address).\n *\n * - **Batch Calls**: Execute multiple operations atomically in a single transaction via\n *   the `calls` array, reducing overhead and simplifying wallet management.\n *\n * - **Access Keys**: Delegate signing to secondary keys with expiry and per-TIP-20 spending\n *   limits via `keyAuthorization`. Enables passkey UX without repeated prompts.\n *\n * - **Parallelizable Nonces**: Use different `nonceKey` values to submit multiple transactions\n *   in parallel without waiting for sequential nonce confirmation.\n *\n * - **Scheduled Transactions**: Set `validAfter` and `validBefore` timestamps to define a\n *   time window for when the transaction can be included in a block.\n *\n * - **Multi-Signature Support**: Sign with secp256k1, P256 (passkeys), or WebAuthn credentials.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n */\nexport type TxEnvelopeTempo<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** EIP-7702 (Tempo) Authorization list for the transaction. */\n    authorizationList?:\n      | AuthorizationTempo.ListSigned<bigintType, numberType>\n      | undefined\n    /** Array of calls to execute. */\n    calls: readonly Call<bigintType>[]\n    /** EIP-155 Chain ID. */\n    chainId: numberType\n    /** Sender of the transaction. */\n    from?: Address.Address | undefined\n    /** Gas provided for transaction execution */\n    gas?: bigintType | undefined\n    /** Fee payer signature. */\n    feePayerSignature?:\n      | Signature.Signature<true, bigintType, numberType>\n      | null\n      | undefined\n    /** Fee token preference. Address or ID of the TIP-20 token. */\n    feeToken?: TokenId.TokenIdOrAddress | undefined\n    /**\n     * Key authorization for provisioning a new access key.\n     *\n     * When present, this transaction will add the specified key to the AccountKeychain precompile,\n     * before verifying the transaction signature.\n     * The authorization must be signed with the root key, the tx can be signed by the Keychain signature.\n     */\n    keyAuthorization?:\n      | KeyAuthorization.Signed<bigintType, numberType>\n      | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n    /** Nonce key for 2D nonce system (192 bits). */\n    nonceKey?: bigintType | undefined\n    /** Unique number identifying this transaction */\n    nonce?: bigintType | undefined\n    /** Transaction type */\n    type: type\n    /** Transaction can only be included in a block before this timestamp. */\n    validBefore?: numberType | undefined\n    /** Transaction can only be included in a block after this timestamp. */\n    validAfter?: numberType | undefined\n  } & (signed extends true\n    ? {\n        signature: SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n      }\n    : {\n        signature?:\n          | SignatureEnvelope.SignatureEnvelope<bigintType, numberType>\n          | undefined\n      })\n>\n\nexport type Rpc<signed extends boolean = boolean> = TxEnvelopeTempo<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x76'\n>\n\nexport const feePayerMagic = '0x78' as const\nexport type FeePayerMagic = typeof feePayerMagic\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport type Signed = TxEnvelopeTempo<true>\n\nexport const serializedType = '0x76' as const\nexport type SerializedType = typeof serializedType\n\nexport const type = 'tempo' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 0n }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TxEnvelopeTempo, 'type'>) {\n  const {\n    calls,\n    chainId,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    validBefore,\n    validAfter,\n  } = envelope\n\n  // Calls must not be empty\n  if (!calls || calls.length === 0) throw new CallsEmptyError()\n\n  // validBefore must be greater than validAfter if both are set\n  if (\n    typeof validBefore === 'number' &&\n    typeof validAfter === 'number' &&\n    validBefore <= validAfter\n  ) {\n    throw new InvalidValidityWindowError({\n      validBefore: validBefore,\n      validAfter: validAfter,\n    })\n  }\n\n  // Validate each call\n  if (calls)\n    for (const call of calls)\n      if (call.to) Address.assert(call.to, { strict: false })\n\n  // Validate chain ID\n  if (chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n\n  // Validate max fee per gas\n  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.FeeCapTooHighError({\n      feeCap: maxFeePerGas,\n    })\n\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TransactionEnvelope.TipAboveFeeCapError({\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | CallsEmptyError\n    | InvalidValidityWindowError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.deserialize('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   type: 'tempo',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   calls: [{ to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: 1000000000000000000n }],\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized: Serialized): Compute<TxEnvelopeTempo> {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    calls,\n    accessList,\n    nonceKey,\n    nonce,\n    validBefore,\n    validAfter,\n    feeToken,\n    feePayerSignatureOrSender,\n    authorizationList,\n    keyAuthorizationOrSignature,\n    maybeSignature,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  const keyAuthorization = Array.isArray(keyAuthorizationOrSignature)\n    ? keyAuthorizationOrSignature\n    : undefined\n  const signature = keyAuthorization\n    ? maybeSignature\n    : keyAuthorizationOrSignature\n\n  if (\n    !(\n      transactionArray.length === 13 ||\n      transactionArray.length === 14 ||\n      transactionArray.length === 15\n    )\n  )\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        authorizationList,\n        chainId,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        calls,\n        accessList,\n        keyAuthorization,\n        nonceKey,\n        nonce,\n        validBefore,\n        validAfter,\n        feeToken,\n        feePayerSignatureOrSender,\n        ...(transactionArray.length > 12\n          ? {\n              signature,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId),\n    type,\n  } as TxEnvelopeTempo\n\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (Hex.validate(nonceKey))\n    transaction.nonceKey = nonceKey === '0x' ? 0n : BigInt(nonceKey)\n  if (Hex.validate(validBefore) && validBefore !== '0x')\n    transaction.validBefore = Number(validBefore)\n  if (Hex.validate(validAfter) && validAfter !== '0x')\n    transaction.validAfter = Number(validAfter)\n  if (Hex.validate(feeToken) && feeToken !== '0x')\n    transaction.feeToken = feeToken\n\n  // Parse calls array\n  if (calls && calls !== '0x') {\n    const callsArray = calls as unknown as readonly Hex.Hex[][]\n    transaction.calls = callsArray.map((callTuple) => {\n      const [to, value, data] = callTuple\n      const call: Call = {}\n      if (to && to !== '0x') call.to = to\n      if (value && value !== '0x') call.value = BigInt(value)\n      if (data && data !== '0x') call.data = data\n      return call\n    })\n  }\n\n  if (accessList?.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as never)\n\n  if (authorizationList?.length !== 0 && authorizationList !== '0x')\n    transaction.authorizationList = AuthorizationTempo.fromTupleList(\n      authorizationList as never,\n    )\n\n  if (\n    feePayerSignatureOrSender !== '0x' &&\n    feePayerSignatureOrSender !== undefined\n  ) {\n    if (\n      feePayerSignatureOrSender === '0x00' ||\n      Address.validate(feePayerSignatureOrSender)\n    )\n      transaction.feePayerSignature = null\n    else\n      transaction.feePayerSignature = Signature.fromTuple(\n        feePayerSignatureOrSender as never,\n      )\n  }\n\n  if (keyAuthorization)\n    transaction.keyAuthorization = KeyAuthorization.fromTuple(\n      keyAuthorization as never,\n    )\n\n  const signatureEnvelope = signature\n    ? SignatureEnvelope.deserialize(signature)\n    : undefined\n  if (signatureEnvelope)\n    transaction = {\n      ...transaction,\n      signature: signatureEnvelope,\n    }\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into a Tempo Transaction Envelope.\n *\n * Use this to create transaction envelopes with Tempo-specific features like batched calls,\n * fee tokens, access keys, and scheduled execution. Attach a signature using the `signature`\n * option after signing with {@link ox#TxEnvelopeTempo.(getSignPayload:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({ // [!code focus]\n *   chainId: 1, // [!code focus]\n *   calls: [{ // [!code focus]\n *     data: '0xdeadbeef', // [!code focus]\n *     to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   }], // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 1000000000000000000n }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   type: 'tempo',\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate a Tempo Transaction Envelope from a {@link ox#TxEnvelopeTempo.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{\n * // @log:     data: '0xdeadbeef',\n * // @log:     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   type: 'tempo',\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A Tempo Transaction Envelope.\n */\nexport function from<\n  const envelope extends UnionPartialBy<TxEnvelopeTempo, 'type'> | Serialized,\n  const signature extends SignatureEnvelope.from.Value | undefined = undefined,\n>(\n  envelope: envelope | UnionPartialBy<TxEnvelopeTempo, 'type'> | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnValue<envelope, signature> {\n  const { feePayerSignature, signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TxEnvelopeTempo\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? { signature: SignatureEnvelope.from(signature) } : {}),\n    ...(feePayerSignature\n      ? { feePayerSignature: Signature.from(feePayerSignature) }\n      : {}),\n    type: 'tempo',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends SignatureEnvelope.from.Value | undefined = undefined,\n  > = {\n    feePayerSignature?: Signature.Signature | null | undefined\n    signature?: signature | SignatureEnvelope.from.Value | undefined\n  }\n\n  type ReturnValue<\n    envelope extends UnionPartialBy<TxEnvelopeTempo, 'type'> | Hex.Hex =\n      | TxEnvelopeTempo\n      | Hex.Hex,\n    signature extends SignatureEnvelope.from.Value | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TxEnvelopeTempo\n      : Assign<\n          envelope,\n          (signature extends SignatureEnvelope.from.Value\n            ? { signature: SignatureEnvelope.from.ReturnValue<signature> }\n            : {}) & {\n            readonly type: 'tempo'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * RLP-encodes the transaction with type prefix `0x76`. For fee sponsorship, use `format: 'feePayer'`\n * to serialize with the fee payer magic `0x78` and the sender address.\n *\n * [RLP Encoding](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#rlp-encoding)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TxEnvelopeTempo, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    accessList,\n    authorizationList,\n    calls,\n    chainId,\n    feeToken,\n    gas,\n    keyAuthorization,\n    nonce,\n    nonceKey,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    validBefore,\n    validAfter,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n  const signature = options.signature || envelope.signature\n\n  const authorizationTupleList =\n    AuthorizationTempo.toTupleList(authorizationList)\n\n  // Encode calls as RLP list of [to, value, data] tuples\n  const callsTupleList = calls.map((call) => [\n    call.to ?? '0x',\n    call.value ? Hex.fromNumber(call.value) : '0x',\n    call.data ?? '0x',\n  ])\n\n  const feePayerSignatureOrSender = (() => {\n    if (options.sender) return options.sender\n    const feePayerSignature =\n      typeof options.feePayerSignature !== 'undefined'\n        ? options.feePayerSignature\n        : envelope.feePayerSignature\n    if (feePayerSignature === null) return '0x00'\n    if (!feePayerSignature) return '0x'\n    return Signature.toTuple(feePayerSignature)\n  })()\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    callsTupleList,\n    accessTupleList,\n    nonceKey ? Hex.fromNumber(nonceKey) : '0x',\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    typeof validBefore === 'number' ? Hex.fromNumber(validBefore) : '0x',\n    typeof validAfter === 'number' ? Hex.fromNumber(validAfter) : '0x',\n    typeof feeToken === 'bigint' || typeof feeToken === 'string'\n      ? TokenId.toAddress(feeToken)\n      : '0x',\n    feePayerSignatureOrSender,\n    authorizationTupleList,\n    ...(keyAuthorization ? [KeyAuthorization.toTuple(keyAuthorization)] : []),\n    ...(signature\n      ? [SignatureEnvelope.serialize(SignatureEnvelope.from(signature))]\n      : []),\n  ] as const\n\n  return Hex.concat(\n    options.format === 'feePayer' ? feePayerMagic : serializedType,\n    Rlp.fromHex(serialized),\n  ) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /**\n     * Sender signature to append to the serialized envelope.\n     */\n    signature?: SignatureEnvelope.from.Value | undefined\n  } & OneOf<\n    | {\n        /**\n         * Sender address to cover the fee of.\n         */\n        sender: Address.Address\n        /**\n         * Whether to serialize the transaction in the fee payer format.\n         *\n         * - If `'feePayer'`, then the transaction will be serialized in the fee payer format.\n         * - If `undefined` (default), then the transaction will be serialized in the normal format.\n         */\n        format: 'feePayer'\n      }\n    | {\n        /**\n         * Fee payer signature or the sender to cover the fee of.\n         *\n         * - If `Signature.Signature`, then this is the fee payer signature.\n         * - If `null`, then this indicates the envelope is intended to be signed by a fee payer.\n         */\n        feePayerSignature?: Signature.Signature | null | undefined\n        format?: undefined\n      }\n  >\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Computes the keccak256 hash of the unsigned serialized transaction. Sign this payload\n * with secp256k1, P256, or WebAuthn, then attach the signature via {@link ox#TxEnvelopeTempo.(from:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TxEnvelopeTempo,\n): getSignPayload.ReturnValue {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnValue = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { signature })\n *\n * const hash = TxEnvelopeTempo.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Tempo Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TxEnvelopeTempo<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnValue {\n  const serialized = serialize({\n    ...envelope,\n    ...(options.presign\n      ? {\n          signature: undefined,\n        }\n      : {}),\n  })\n  return Hash.keccak256(serialized)\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /**\n     * Whether to hash this transaction for signing.\n     *\n     * @default false\n     */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnValue = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the fee payer payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Fee sponsorship uses a dual-signature scheme: the sender signs the transaction, then a fee payer\n * signs over the transaction with the sender's address to commit to paying fees. The fee payer's\n * signature includes the `feeToken` and `sender_address`, using magic byte `0x78` for domain separation.\n *\n * [Fee Payer Signature](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#fee-payer-signature)\n * [Fee Sponsorship Guide](https://docs.tempo.xyz/protocol/transactions#fee-sponsorship)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getFeePayerSignPayload(envelope, {\n *   sender: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045'\n * }) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the fee payer sign payload for.\n * @param options - Options.\n * @returns The fee payer sign payload.\n */\nexport function getFeePayerSignPayload(\n  envelope: TxEnvelopeTempo,\n  options: getFeePayerSignPayload.Options,\n): getFeePayerSignPayload.ReturnValue {\n  const { sender } = options\n  const serialized = serialize(\n    { ...envelope, signature: undefined },\n    {\n      sender,\n      format: 'feePayer',\n    },\n  )\n  return Hash.keccak256(serialized)\n}\n\nexport declare namespace getFeePayerSignPayload {\n  type Options = {\n    /**\n     * Sender address to cover the fee of.\n     */\n    sender: Address.Address\n  }\n\n  type ReturnValue = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const valid = TxEnvelopeTempo.validate({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope: PartialBy<TxEnvelopeTempo, 'type'>) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a transaction's calls list is empty.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [],\n *   chainId: 1,\n * })\n * // @error: TxEnvelopeTempo.CallsEmptyError: Calls list cannot be empty.\n * ```\n */\nexport class CallsEmptyError extends Errors.BaseError {\n  override readonly name = 'TxEnvelopeTempo.CallsEmptyError'\n  constructor() {\n    super('Calls list cannot be empty.')\n  }\n}\n\n/**\n * Thrown when validBefore is not greater than validAfter.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000' }],\n *   chainId: 1,\n *   validBefore: 100,\n *   validAfter: 200,\n * })\n * // @error: TxEnvelopeTempo.InvalidValidityWindowError: validBefore (100) must be greater than validAfter (200).\n * ```\n */\nexport class InvalidValidityWindowError extends Errors.BaseError {\n  override readonly name = 'TxEnvelopeTempo.InvalidValidityWindowError'\n  constructor({\n    validBefore,\n    validAfter,\n  }: {\n    validBefore: number\n    validAfter: number\n  }) {\n    super(\n      `validBefore (${validBefore}) must be greater than validAfter (${validAfter}).`,\n    )\n  }\n}\n", "import * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, Mutable } from './internal/types.js'\n\nexport type AccessList = Compute<readonly Item[]>\n\nexport type Item = Compute<{\n  address: Address.Address\n  storageKeys: readonly Hex.Hex[]\n}>\n\nexport type ItemTuple = Compute<\n  [address: Address.Address, storageKeys: readonly Hex.Hex[]]\n>\n\nexport type Tuple = readonly ItemTuple[]\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nexport function fromTupleList(accessList: Tuple): AccessList {\n  const list: Mutable<AccessList> = []\n  for (let i = 0; i < accessList.length; i++) {\n    const [address, storageKeys] = accessList[i] as [Hex.Hex, Hex.Hex[]]\n\n    if (address) Address.assert(address, { strict: false })\n\n    list.push({\n      address: address,\n      storageKeys: storageKeys.map((key) =>\n        Hash.validate(key) ? key : Hex.trimLeft(key),\n      ),\n    })\n  }\n  return list\n}\n\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nexport function toTupleList(\n  accessList?: AccessList | undefined,\n): Compute<Tuple> {\n  if (!accessList || accessList.length === 0) return []\n\n  const tuple: Mutable<Tuple> = []\n  for (const { address, storageKeys } of accessList) {\n    for (let j = 0; j < storageKeys.length; j++)\n      if (Hex.size(storageKeys[j]!) !== 32)\n        throw new InvalidStorageKeySizeError({\n          storageKey: storageKeys[j]!,\n        })\n\n    if (address) Address.assert(address, { strict: false })\n\n    tuple.push([address, storageKeys])\n  }\n  return tuple\n}\n\n/** Thrown when the size of a storage key is invalid. */\nexport class InvalidStorageKeySizeError extends Errors.BaseError {\n  override readonly name = 'AccessList.InvalidStorageKeySizeError'\n  constructor({ storageKey }: { storageKey: Hex.Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Hex.size(storageKey)} bytes.`,\n    )\n  }\n}\n", "import * as Errors from './Errors.js'\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nexport const exponents = {\n  wei: 0,\n  gwei: 9,\n  szabo: 12,\n  finney: 15,\n  ether: 18,\n} as const\n\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nexport function format(value: bigint, decimals = 0) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nexport function formatEther(\n  wei: bigint,\n  unit: 'wei' | 'gwei' | 'szabo' | 'finney' = 'wei',\n) {\n  return format(wei, exponents.ether - exponents[unit])\n}\n\nexport declare namespace formatEther {\n  type ErrorType = format.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return format(wei, exponents.gwei - exponents[unit])\n}\n\nexport declare namespace formatGwei {\n  type ErrorType = format.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nexport function from(value: string, decimals = 0) {\n  if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n    throw new InvalidDecimalNumberError({ value })\n\n  let [integer = '', fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1)\n      integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9)\n      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n\nexport declare namespace from {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromEther(\n  ether: string,\n  unit: 'wei' | 'gwei' | 'szabo' | 'finney' = 'wei',\n) {\n  return from(ether, exponents.ether - exponents[unit])\n}\n\nexport declare namespace fromEther {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromGwei(gwei: string, unit: 'wei' = 'wei') {\n  return from(gwei, exponents.gwei - exponents[unit])\n}\n\nexport declare namespace fromGwei {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nexport class InvalidDecimalNumberError extends Errors.BaseError {\n  override readonly name = 'Value.InvalidDecimalNumberError'\n  constructor({ value }: { value: string }) {\n    super(`Value \\`${value}\\` is not a valid decimal number.`)\n  }\n}\n", "import type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Value from './Value.js'\n\n/** Base type for a Transaction Envelope. Transaction Envelopes inherit this type. */\nexport type Base<\n  type extends string = string,\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** EIP-155 Chain ID. */\n    chainId: numberType\n    /** Contract code or a hashed method call with encoded args */\n    data?: Hex.Hex | undefined\n    /** @alias `data`  added for TransactionEnvelope - Transaction compatibility. */\n    input?: Hex.Hex | undefined\n    /** Sender of the transaction. */\n    from?: Address.Address | undefined\n    /** Gas provided for transaction execution */\n    gas?: bigintType | undefined\n    /** Unique number identifying this transaction */\n    nonce?: bigintType | undefined\n    /** Transaction recipient */\n    to?: Address.Address | null | undefined\n    /** Transaction type */\n    type: type\n    /** Value in wei sent with this transaction */\n    value?: bigintType | undefined\n    /** ECDSA signature r. */\n    r?: bigintType | undefined\n    /** ECDSA signature s. */\n    s?: bigintType | undefined\n    /** ECDSA signature yParity. */\n    yParity?: numberType | undefined\n    /** @deprecated ECDSA signature v (for backwards compatibility). */\n    v?: numberType | undefined\n  } & (signed extends true ? { r: bigintType; s: bigintType } : {})\n>\n\n/** RPC representation of a {@link ox#(TransactionEnvelope:namespace).Base}. */\nexport type BaseRpc<\n  type extends string = string,\n  signed extends boolean = boolean,\n> = Base<type, signed, Hex.Hex, Hex.Hex>\n\n/** Signed representation of a {@link ox#(TransactionEnvelope:namespace).Base}. */\nexport type BaseSigned<type extends string = string> = Base<type, true>\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nexport class FeeCapTooHighError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.FeeCapTooHighError'\n  constructor({\n    feeCap,\n  }: {\n    feeCap?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${\n        feeCap ? ` = ${Value.formatGwei(feeCap)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n    )\n  }\n}\n\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * TxEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nexport class GasPriceTooHighError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.GasPriceTooHighError'\n  constructor({\n    gasPrice,\n  }: {\n    gasPrice?: bigint | undefined\n  } = {}) {\n    super(\n      `The gas price (\\`gasPrice\\`${\n        gasPrice ? ` = ${Value.formatGwei(gasPrice)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n    )\n  }\n}\n\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */\nexport class InvalidChainIdError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.InvalidChainIdError'\n  constructor({ chainId }: { chainId?: number | undefined }) {\n    super(\n      typeof chainId !== 'undefined'\n        ? `Chain ID \"${chainId}\" is invalid.`\n        : 'Chain ID is invalid.',\n    )\n  }\n}\n\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */\nexport class InvalidSerializedError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.InvalidSerializedError'\n  constructor({\n    attributes,\n    serialized,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serialized: Hex.Hex\n    type: string\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serialized}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n  }\n}\n\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */\nexport class TipAboveFeeCapError extends Errors.BaseError {\n  override readonly name = 'TransactionEnvelope.TipAboveFeeCapError'\n  constructor({\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    maxPriorityFeePerGas?: bigint | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${Value.formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${Value.formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n    )\n  }\n}\n", "// Generated with `pnpm gen:abis`. Do not modify manually.\n\nexport const stablecoinExchange = [\n  {\n    name: 'createPair',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'base' }],\n    outputs: [{ type: 'bytes32', name: 'key' }],\n  },\n  {\n    name: 'place',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'token' },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n    ],\n    outputs: [{ type: 'uint128', name: 'orderId' }],\n  },\n  {\n    name: 'placeFlip',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'token' },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n      { type: 'int16', name: 'flipTick' },\n    ],\n    outputs: [{ type: 'uint128', name: 'orderId' }],\n  },\n  {\n    name: 'cancel',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint128', name: 'orderId' }],\n    outputs: [],\n  },\n  {\n    name: 'executeBlock',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'swapExactAmountIn',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountIn' },\n      { type: 'uint128', name: 'minAmountOut' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountOut' }],\n  },\n  {\n    name: 'swapExactAmountOut',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountOut' },\n      { type: 'uint128', name: 'maxAmountIn' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountIn' }],\n  },\n  {\n    name: 'quoteSwapExactAmountIn',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountIn' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountOut' }],\n  },\n  {\n    name: 'quoteSwapExactAmountOut',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'tokenIn' },\n      { type: 'address', name: 'tokenOut' },\n      { type: 'uint128', name: 'amountOut' },\n    ],\n    outputs: [{ type: 'uint128', name: 'amountIn' }],\n  },\n  {\n    name: 'balanceOf',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'user' },\n      { type: 'address', name: 'token' },\n    ],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'withdraw',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'token' },\n      { type: 'uint128', name: 'amount' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'getOrder',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint128', name: 'orderId' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint128', name: 'orderId' },\n          { type: 'address', name: 'maker' },\n          { type: 'bytes32', name: 'bookKey' },\n          { type: 'bool', name: 'isBid' },\n          { type: 'int16', name: 'tick' },\n          { type: 'uint128', name: 'amount' },\n          { type: 'uint128', name: 'remaining' },\n          { type: 'uint128', name: 'prev' },\n          { type: 'uint128', name: 'next' },\n          { type: 'bool', name: 'isFlip' },\n          { type: 'int16', name: 'flipTick' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'getTickLevel',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'base' },\n      { type: 'int16', name: 'tick' },\n      { type: 'bool', name: 'isBid' },\n    ],\n    outputs: [\n      { type: 'uint128', name: 'head' },\n      { type: 'uint128', name: 'tail' },\n      { type: 'uint128', name: 'totalLiquidity' },\n    ],\n  },\n  {\n    name: 'pairKey',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [\n      { type: 'address', name: 'tokenA' },\n      { type: 'address', name: 'tokenB' },\n    ],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'activeOrderId',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'pendingOrderId',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'books',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'pairKey' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'address', name: 'base' },\n          { type: 'address', name: 'quote' },\n          { type: 'int16', name: 'bestBidTick' },\n          { type: 'int16', name: 'bestAskTick' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'MIN_TICK',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'int16' }],\n  },\n  {\n    name: 'MAX_TICK',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'int16' }],\n  },\n  {\n    name: 'TICK_SPACING',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'int16' }],\n  },\n  {\n    name: 'PRICE_SCALE',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint32' }],\n  },\n  {\n    name: 'MIN_PRICE',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint32' }],\n  },\n  {\n    name: 'MAX_PRICE',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [],\n    outputs: [{ type: 'uint32' }],\n  },\n  {\n    name: 'tickToPrice',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [{ type: 'int16', name: 'tick' }],\n    outputs: [{ type: 'uint32', name: 'price' }],\n  },\n  {\n    name: 'priceToTick',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [{ type: 'uint32', name: 'price' }],\n    outputs: [{ type: 'int16', name: 'tick' }],\n  },\n  {\n    name: 'PairCreated',\n    type: 'event',\n    inputs: [\n      { type: 'bytes32', name: 'key', indexed: true },\n      { type: 'address', name: 'base', indexed: true },\n      { type: 'address', name: 'quote', indexed: true },\n    ],\n  },\n  {\n    name: 'OrderPlaced',\n    type: 'event',\n    inputs: [\n      { type: 'uint128', name: 'orderId', indexed: true },\n      { type: 'address', name: 'maker', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n    ],\n  },\n  {\n    name: 'FlipOrderPlaced',\n    type: 'event',\n    inputs: [\n      { type: 'uint128', name: 'orderId', indexed: true },\n      { type: 'address', name: 'maker', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint128', name: 'amount' },\n      { type: 'bool', name: 'isBid' },\n      { type: 'int16', name: 'tick' },\n      { type: 'int16', name: 'flipTick' },\n    ],\n  },\n  {\n    name: 'OrderFilled',\n    type: 'event',\n    inputs: [\n      { type: 'uint128', name: 'orderId', indexed: true },\n      { type: 'address', name: 'maker', indexed: true },\n      { type: 'uint128', name: 'amountFilled' },\n      { type: 'bool', name: 'partialFill' },\n    ],\n  },\n  {\n    name: 'OrderFilled',\n    type: 'event',\n    inputs: [\n      { type: 'uint128', name: 'orderId', indexed: true },\n      { type: 'address', name: 'maker', indexed: true },\n      { type: 'address', name: 'taker', indexed: true },\n      { type: 'uint128', name: 'amountFilled' },\n      { type: 'bool', name: 'partialFill' },\n    ],\n  },\n  {\n    name: 'OrderCancelled',\n    type: 'event',\n    inputs: [{ type: 'uint128', name: 'orderId', indexed: true }],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'PairDoesNotExist', type: 'error', inputs: [] },\n  { name: 'PairAlreadyExists', type: 'error', inputs: [] },\n  { name: 'OrderDoesNotExist', type: 'error', inputs: [] },\n  { name: 'IdenticalTokens', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  {\n    name: 'TickOutOfBounds',\n    type: 'error',\n    inputs: [{ type: 'int16', name: 'tick' }],\n  },\n  { name: 'InvalidTick', type: 'error', inputs: [] },\n  { name: 'InvalidFlipTick', type: 'error', inputs: [] },\n  { name: 'InsufficientBalance', type: 'error', inputs: [] },\n  { name: 'InsufficientLiquidity', type: 'error', inputs: [] },\n  { name: 'InsufficientOutput', type: 'error', inputs: [] },\n  { name: 'MaxInputExceeded', type: 'error', inputs: [] },\n  {\n    name: 'BelowMinimumOrderSize',\n    type: 'error',\n    inputs: [{ type: 'uint128', name: 'amount' }],\n  },\n  { name: 'InvalidBaseToken', type: 'error', inputs: [] },\n] as const\n\nexport const tip20 = [\n  {\n    name: 'name',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'string' }],\n  },\n  {\n    name: 'symbol',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'string' }],\n  },\n  {\n    name: 'decimals',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint8' }],\n  },\n  {\n    name: 'totalSupply',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'quoteToken',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'nextQuoteToken',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'balanceOf',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'account' }],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'transfer',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'approve',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'spender' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'allowance',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'owner' },\n      { type: 'address', name: 'spender' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'transferFrom',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'from' },\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'mint',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'burn',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint256', name: 'amount' }],\n    outputs: [],\n  },\n  {\n    name: 'currency',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'string' }],\n  },\n  {\n    name: 'supplyCap',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'paused',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'transferPolicyId',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'burnBlocked',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'from' },\n      { type: 'uint256', name: 'amount' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'mintWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'burnWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'transferWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'transferFromWithMemo',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'from' },\n      { type: 'address', name: 'to' },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'feeRecipient',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'setFeeRecipient',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'newRecipient' }],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'changeTransferPolicyId',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint64', name: 'newPolicyId' }],\n    outputs: [],\n  },\n  {\n    name: 'setSupplyCap',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint256', name: 'newSupplyCap' }],\n    outputs: [],\n  },\n  {\n    name: 'pause',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'unpause',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'setNextQuoteToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'newQuoteToken' }],\n    outputs: [],\n  },\n  {\n    name: 'completeQuoteTokenUpdate',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'PAUSE_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'UNPAUSE_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'ISSUER_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'BURN_BLOCKED_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'startReward',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint256', name: 'amount' },\n      { type: 'uint32', name: 'secs' },\n    ],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'setRewardRecipient',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'recipient' }],\n    outputs: [],\n  },\n  {\n    name: 'cancelReward',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint64', name: 'id' }],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'claimRewards',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'finalizeStreams',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'uint64', name: 'timestamp' }],\n    outputs: [],\n  },\n  {\n    name: 'getStream',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint64', name: 'id' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'address', name: 'funder' },\n          { type: 'uint64', name: 'startTime' },\n          { type: 'uint64', name: 'endTime' },\n          { type: 'uint256', name: 'ratePerSecondScaled' },\n          { type: 'uint256', name: 'amountTotal' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'totalRewardPerSecond',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'optedInSupply',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint128' }],\n  },\n  {\n    name: 'nextStreamId',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'userRewardInfo',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'account' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'address', name: 'rewardRecipient' },\n          { type: 'uint256', name: 'rewardPerToken' },\n          { type: 'uint256', name: 'rewardBalance' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'Transfer',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'Approval',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'owner', indexed: true },\n      { type: 'address', name: 'spender', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'Mint',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'Burn',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'BurnBlocked',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'uint256', name: 'amount' },\n    ],\n  },\n  {\n    name: 'TransferWithMemo',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'from', indexed: true },\n      { type: 'address', name: 'to', indexed: true },\n      { type: 'uint256', name: 'amount' },\n      { type: 'bytes32', name: 'memo', indexed: true },\n    ],\n  },\n  {\n    name: 'TransferPolicyUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'uint64', name: 'newPolicyId', indexed: true },\n    ],\n  },\n  {\n    name: 'SupplyCapUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'uint256', name: 'newSupplyCap', indexed: true },\n    ],\n  },\n  {\n    name: 'PauseStateUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'bool', name: 'isPaused' },\n    ],\n  },\n  {\n    name: 'NextQuoteTokenSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'nextQuoteToken', indexed: true },\n    ],\n  },\n  {\n    name: 'QuoteTokenUpdate',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'newQuoteToken', indexed: true },\n    ],\n  },\n  {\n    name: 'RewardScheduled',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'funder', indexed: true },\n      { type: 'uint64', name: 'id', indexed: true },\n      { type: 'uint256', name: 'amount' },\n      { type: 'uint32', name: 'durationSeconds' },\n    ],\n  },\n  {\n    name: 'RewardCanceled',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'funder', indexed: true },\n      { type: 'uint64', name: 'id', indexed: true },\n      { type: 'uint256', name: 'refund' },\n    ],\n  },\n  {\n    name: 'RewardRecipientSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'holder', indexed: true },\n      { type: 'address', name: 'recipient', indexed: true },\n    ],\n  },\n  {\n    name: 'FeeRecipientUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'newRecipient', indexed: true },\n    ],\n  },\n  {\n    name: 'InsufficientBalance',\n    type: 'error',\n    inputs: [\n      { type: 'uint256', name: 'available' },\n      { type: 'uint256', name: 'required' },\n      { type: 'address', name: 'token' },\n    ],\n  },\n  { name: 'InsufficientAllowance', type: 'error', inputs: [] },\n  { name: 'SupplyCapExceeded', type: 'error', inputs: [] },\n  { name: 'InvalidSupplyCap', type: 'error', inputs: [] },\n  { name: 'InvalidPayload', type: 'error', inputs: [] },\n  { name: 'StringTooLong', type: 'error', inputs: [] },\n  { name: 'PolicyForbids', type: 'error', inputs: [] },\n  { name: 'InvalidRecipient', type: 'error', inputs: [] },\n  { name: 'ContractPaused', type: 'error', inputs: [] },\n  { name: 'InvalidCurrency', type: 'error', inputs: [] },\n  { name: 'InvalidQuoteToken', type: 'error', inputs: [] },\n  { name: 'TransfersDisabled', type: 'error', inputs: [] },\n  { name: 'InvalidAmount', type: 'error', inputs: [] },\n  { name: 'NotStreamFunder', type: 'error', inputs: [] },\n  { name: 'StreamInactive', type: 'error', inputs: [] },\n  { name: 'NoOptedInSupply', type: 'error', inputs: [] },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'RewardsDisabled', type: 'error', inputs: [] },\n  { name: 'ScheduledRewardsDisabled', type: 'error', inputs: [] },\n  { name: 'ProtectedAddress', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  {\n    name: 'hasRole',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'bytes32', name: 'role' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'getRoleAdmin',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'role' }],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'grantRole',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'role' },\n      { type: 'address', name: 'account' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'revokeRole',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'role' },\n      { type: 'address', name: 'account' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'renounceRole',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'bytes32', name: 'role' }],\n    outputs: [],\n  },\n  {\n    name: 'setRoleAdmin',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'role' },\n      { type: 'bytes32', name: 'adminRole' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'RoleMembershipUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'bytes32', name: 'role', indexed: true },\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'sender', indexed: true },\n      { type: 'bool', name: 'hasRole' },\n    ],\n  },\n  {\n    name: 'RoleAdminUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'bytes32', name: 'role', indexed: true },\n      { type: 'bytes32', name: 'newAdminRole', indexed: true },\n      { type: 'address', name: 'sender', indexed: true },\n    ],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n] as const\n\nexport const tipAccountRegistrar = [\n  {\n    name: 'delegateToDefault',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes32', name: 'hash' },\n      { type: 'bytes', name: 'signature' },\n    ],\n    outputs: [{ type: 'address', name: 'authority' }],\n  },\n  {\n    name: 'delegateToDefault',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'bytes', name: 'message' },\n      { type: 'bytes', name: 'signature' },\n    ],\n    outputs: [{ type: 'address', name: 'authority' }],\n  },\n  { name: 'InvalidSignature', type: 'error', inputs: [] },\n  { name: 'CodeNotEmpty', type: 'error', inputs: [] },\n  { name: 'NonceNotZero', type: 'error', inputs: [] },\n] as const\n\nexport const feeManager = [\n  {\n    name: 'userTokens',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'user' }],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'validatorTokens',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'validator' }],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'setUserToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'token' }],\n    outputs: [],\n  },\n  {\n    name: 'setValidatorToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'token' }],\n    outputs: [],\n  },\n  {\n    name: 'getFeeTokenBalance',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'sender' },\n      { type: 'address', name: 'validator' },\n    ],\n    outputs: [{ type: 'address' }, { type: 'uint256' }],\n  },\n  {\n    name: 'executeBlock',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  {\n    name: 'UserTokenSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'user', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n    ],\n  },\n  {\n    name: 'ValidatorTokenSet',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'validator', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n    ],\n  },\n  { name: 'OnlyValidator', type: 'error', inputs: [] },\n  { name: 'OnlySystemContract', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  { name: 'PoolDoesNotExist', type: 'error', inputs: [] },\n  { name: 'InsufficientFeeTokenBalance', type: 'error', inputs: [] },\n  { name: 'InternalError', type: 'error', inputs: [] },\n  { name: 'CannotChangeWithinBlock', type: 'error', inputs: [] },\n  { name: 'CannotChangeWithPendingFees', type: 'error', inputs: [] },\n  { name: 'TokenPolicyForbids', type: 'error', inputs: [] },\n] as const\n\nexport const feeAmm = [\n  {\n    name: 'M',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'N',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'SCALE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'MIN_LIQUIDITY',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'getPoolId',\n    type: 'function',\n    stateMutability: 'pure',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n    ],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'getPool',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n    ],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint128', name: 'reserveUserToken' },\n          { type: 'uint128', name: 'reserveValidatorToken' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'pools',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'poolId' }],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint128', name: 'reserveUserToken' },\n          { type: 'uint128', name: 'reserveValidatorToken' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'mint',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'amountUserToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [{ type: 'uint256', name: 'liquidity' }],\n  },\n  {\n    name: 'mintWithValidatorToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [{ type: 'uint256', name: 'liquidity' }],\n  },\n  {\n    name: 'burn',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'liquidity' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [\n      { type: 'uint256', name: 'amountUserToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n    ],\n  },\n  {\n    name: 'totalSupply',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes32', name: 'poolId' }],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'liquidityBalances',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'bytes32', name: 'poolId' },\n      { type: 'address', name: 'user' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'rebalanceSwap',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'userToken' },\n      { type: 'address', name: 'validatorToken' },\n      { type: 'uint256', name: 'amountOut' },\n      { type: 'address', name: 'to' },\n    ],\n    outputs: [{ type: 'uint256', name: 'amountIn' }],\n  },\n  {\n    name: 'Mint',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'sender', indexed: true },\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'uint256', name: 'amountUserToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'uint256', name: 'liquidity' },\n    ],\n  },\n  {\n    name: 'Burn',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'sender', indexed: true },\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'uint256', name: 'amountUserToken' },\n      { type: 'uint256', name: 'amountValidatorToken' },\n      { type: 'uint256', name: 'liquidity' },\n      { type: 'address', name: 'to' },\n    ],\n  },\n  {\n    name: 'RebalanceSwap',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'address', name: 'swapper', indexed: true },\n      { type: 'uint256', name: 'amountIn' },\n      { type: 'uint256', name: 'amountOut' },\n    ],\n  },\n  {\n    name: 'FeeSwap',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'userToken', indexed: true },\n      { type: 'address', name: 'validatorToken', indexed: true },\n      { type: 'uint256', name: 'amountIn' },\n      { type: 'uint256', name: 'amountOut' },\n    ],\n  },\n  { name: 'IdenticalAddresses', type: 'error', inputs: [] },\n  { name: 'ZeroAddress', type: 'error', inputs: [] },\n  { name: 'PoolExists', type: 'error', inputs: [] },\n  { name: 'PoolDoesNotExist', type: 'error', inputs: [] },\n  { name: 'InvalidToken', type: 'error', inputs: [] },\n  { name: 'InsufficientLiquidity', type: 'error', inputs: [] },\n  { name: 'OnlyProtocol', type: 'error', inputs: [] },\n  { name: 'InsufficientPoolBalance', type: 'error', inputs: [] },\n  { name: 'InsufficientReserves', type: 'error', inputs: [] },\n  { name: 'InsufficientLiquidityBalance', type: 'error', inputs: [] },\n  { name: 'MustDepositLowerBalanceToken', type: 'error', inputs: [] },\n  { name: 'InvalidAmount', type: 'error', inputs: [] },\n  { name: 'InvalidRebalanceState', type: 'error', inputs: [] },\n  { name: 'InvalidRebalanceDirection', type: 'error', inputs: [] },\n  { name: 'InvalidNewReserves', type: 'error', inputs: [] },\n  { name: 'CannotSupportPendingSwaps', type: 'error', inputs: [] },\n  { name: 'DivisionByZero', type: 'error', inputs: [] },\n  { name: 'InvalidSwapCalculation', type: 'error', inputs: [] },\n  { name: 'InsufficientLiquidityForPending', type: 'error', inputs: [] },\n  { name: 'TokenTransferFailed', type: 'error', inputs: [] },\n  { name: 'InternalError', type: 'error', inputs: [] },\n] as const\n\nexport const accountKeychain = [\n  {\n    name: 'authorizeKey',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'keyId' },\n      { type: 'uint8', name: 'signatureType' },\n      { type: 'uint64', name: 'expiry' },\n      { type: 'bool', name: 'enforceLimits' },\n      {\n        type: 'tuple[]',\n        name: 'limits',\n        components: [\n          { type: 'address', name: 'token' },\n          { type: 'uint256', name: 'amount' },\n        ],\n      },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'revokeKey',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'keyId' }],\n    outputs: [],\n  },\n  {\n    name: 'updateSpendingLimit',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'keyId' },\n      { type: 'address', name: 'token' },\n      { type: 'uint256', name: 'newLimit' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'getKey',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'address', name: 'keyId' },\n    ],\n    outputs: [\n      {\n        type: 'tuple',\n        components: [\n          { type: 'uint8', name: 'signatureType' },\n          { type: 'address', name: 'keyId' },\n          { type: 'uint64', name: 'expiry' },\n          { type: 'bool', name: 'enforceLimits' },\n          { type: 'bool', name: 'isRevoked' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'getRemainingLimit',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'address', name: 'keyId' },\n      { type: 'address', name: 'token' },\n    ],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'getTransactionKey',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'KeyAuthorized',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'publicKey', indexed: true },\n      { type: 'uint8', name: 'signatureType' },\n      { type: 'uint64', name: 'expiry' },\n    ],\n  },\n  {\n    name: 'KeyAuthorized',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bytes32', name: 'publicKey', indexed: true },\n      { type: 'uint8', name: 'signatureType' },\n      { type: 'uint64', name: 'expiry' },\n    ],\n  },\n  {\n    name: 'KeyRevoked',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'publicKey', indexed: true },\n    ],\n  },\n  {\n    name: 'KeyRevoked',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bytes32', name: 'publicKey', indexed: true },\n    ],\n  },\n  {\n    name: 'SpendingLimitUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'address', name: 'publicKey', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint256', name: 'newLimit' },\n    ],\n  },\n  {\n    name: 'SpendingLimitUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bytes32', name: 'publicKey', indexed: true },\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint256', name: 'newLimit' },\n    ],\n  },\n  { name: 'UnauthorizedCaller', type: 'error', inputs: [] },\n  { name: 'KeyAlreadyExists', type: 'error', inputs: [] },\n  { name: 'KeyNotFound', type: 'error', inputs: [] },\n  { name: 'KeyExpired', type: 'error', inputs: [] },\n  { name: 'SpendingLimitExceeded', type: 'error', inputs: [] },\n  { name: 'InvalidSignatureType', type: 'error', inputs: [] },\n  { name: 'ZeroPublicKey', type: 'error', inputs: [] },\n  { name: 'ExpiryInPast', type: 'error', inputs: [] },\n  { name: 'KeyAlreadyRevoked', type: 'error', inputs: [] },\n] as const\n\nexport const nonce = [\n  {\n    name: 'getNonce',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'address', name: 'account' },\n      { type: 'uint256', name: 'nonceKey' },\n    ],\n    outputs: [{ type: 'uint64', name: 'nonce' }],\n  },\n  {\n    name: 'getActiveNonceKeyCount',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'account' }],\n    outputs: [{ type: 'uint256', name: 'count' }],\n  },\n  {\n    name: 'NonceIncremented',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'uint256', name: 'nonceKey', indexed: true },\n      { type: 'uint64', name: 'newNonce' },\n    ],\n  },\n  {\n    name: 'ActiveKeyCountChanged',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'uint256', name: 'newCount' },\n    ],\n  },\n  { name: 'ProtocolNonceNotSupported', type: 'error', inputs: [] },\n  { name: 'InvalidNonceKey', type: 'error', inputs: [] },\n  { name: 'NonceOverflow', type: 'error', inputs: [] },\n] as const\n\nexport const tip20RewardsRegistry = [\n  {\n    name: 'finalizeStreams',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [],\n    outputs: [],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'StreamsAlreadyFinalized', type: 'error', inputs: [] },\n] as const\n\nexport const tip20Factory = [\n  {\n    name: 'createToken',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'string', name: 'name' },\n      { type: 'string', name: 'symbol' },\n      { type: 'string', name: 'currency' },\n      { type: 'address', name: 'quoteToken' },\n      { type: 'address', name: 'admin' },\n    ],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'tokenIdCounter',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint256' }],\n  },\n  {\n    name: 'isTIP20',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'address', name: 'token' }],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'TokenCreated',\n    type: 'event',\n    inputs: [\n      { type: 'address', name: 'token', indexed: true },\n      { type: 'uint256', name: 'tokenId', indexed: true },\n      { type: 'string', name: 'name' },\n      { type: 'string', name: 'symbol' },\n      { type: 'string', name: 'currency' },\n      { type: 'address', name: 'quoteToken' },\n      { type: 'address', name: 'admin' },\n    ],\n  },\n] as const\n\nexport const tip403Registry = [\n  {\n    name: 'policyIdCounter',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'policyData',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'uint64', name: 'policyId' }],\n    outputs: [\n      { type: 'uint8', name: 'policyType' },\n      { type: 'address', name: 'admin' },\n    ],\n  },\n  {\n    name: 'isAuthorized',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'user' },\n    ],\n    outputs: [{ type: 'bool' }],\n  },\n  {\n    name: 'createPolicy',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'admin' },\n      { type: 'uint8', name: 'policyType' },\n    ],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'createPolicyWithAccounts',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'admin' },\n      { type: 'uint8', name: 'policyType' },\n      { type: 'address[]', name: 'accounts' },\n    ],\n    outputs: [{ type: 'uint64' }],\n  },\n  {\n    name: 'setPolicyAdmin',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'admin' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'modifyPolicyWhitelist',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'account' },\n      { type: 'bool', name: 'allowed' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'modifyPolicyBlacklist',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'uint64', name: 'policyId' },\n      { type: 'address', name: 'account' },\n      { type: 'bool', name: 'restricted' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'PolicyAdminUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'admin', indexed: true },\n    ],\n  },\n  {\n    name: 'PolicyCreated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'uint8', name: 'policyType' },\n    ],\n  },\n  {\n    name: 'WhitelistUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bool', name: 'allowed' },\n    ],\n  },\n  {\n    name: 'BlacklistUpdated',\n    type: 'event',\n    inputs: [\n      { type: 'uint64', name: 'policyId', indexed: true },\n      { type: 'address', name: 'updater', indexed: true },\n      { type: 'address', name: 'account', indexed: true },\n      { type: 'bool', name: 'restricted' },\n    ],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'IncompatiblePolicyType', type: 'error', inputs: [] },\n] as const\n\nexport const validatorConfig = [\n  {\n    name: 'getValidators',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [\n      {\n        type: 'tuple[]',\n        name: 'validators',\n        components: [\n          { type: 'bytes32', name: 'publicKey' },\n          { type: 'bool', name: 'active' },\n          { type: 'uint64', name: 'index' },\n          { type: 'address', name: 'validatorAddress' },\n          { type: 'string', name: 'inboundAddress' },\n          { type: 'string', name: 'outboundAddress' },\n        ],\n      },\n    ],\n  },\n  {\n    name: 'addValidator',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'newValidatorAddress' },\n      { type: 'bytes32', name: 'publicKey' },\n      { type: 'bool', name: 'active' },\n      { type: 'string', name: 'inboundAddress' },\n      { type: 'string', name: 'outboundAddress' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'updateValidator',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'newValidatorAddress' },\n      { type: 'bytes32', name: 'publicKey' },\n      { type: 'string', name: 'inboundAddress' },\n      { type: 'string', name: 'outboundAddress' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'changeValidatorStatus',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [\n      { type: 'address', name: 'validator' },\n      { type: 'bool', name: 'active' },\n    ],\n    outputs: [],\n  },\n  {\n    name: 'owner',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'address' }],\n  },\n  {\n    name: 'changeOwner',\n    type: 'function',\n    stateMutability: 'nonpayable',\n    inputs: [{ type: 'address', name: 'newOwner' }],\n    outputs: [],\n  },\n  { name: 'Unauthorized', type: 'error', inputs: [] },\n  { name: 'ValidatorAlreadyExists', type: 'error', inputs: [] },\n  { name: 'ValidatorNotFound', type: 'error', inputs: [] },\n  {\n    name: 'NotHostPort',\n    type: 'error',\n    inputs: [\n      { type: 'string', name: 'field' },\n      { type: 'string', name: 'input' },\n      { type: 'string', name: 'backtrace' },\n    ],\n  },\n  {\n    name: 'NotIpPort',\n    type: 'error',\n    inputs: [\n      { type: 'string', name: 'field' },\n      { type: 'string', name: 'input' },\n      { type: 'string', name: 'backtrace' },\n    ],\n  },\n] as const\n\nexport const pathUsd = [\n  {\n    name: 'TRANSFER_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n  {\n    name: 'RECEIVE_WITH_MEMO_ROLE',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [],\n    outputs: [{ type: 'bytes32' }],\n  },\n] as const\n", "import * as Address from 'ox/Address'\nimport * as Hex from 'ox/Hex'\nimport * as P256 from 'ox/P256'\nimport * as PublicKey from 'ox/PublicKey'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\nimport * as WebCryptoP256 from 'ox/WebCryptoP256'\nimport type {\n  LocalAccount,\n  Account as viem_Account,\n} from '../accounts/types.js'\nimport { parseAccount } from '../accounts/utils/parseAccount.js'\nimport type { TransactionSerializable } from '../types/transaction.js'\nimport type { OneOf, RequiredBy } from '../types/utils.js'\nimport { hashAuthorization } from '../utils/authorization/hashAuthorization.js'\nimport { keccak256 } from '../utils/hash/keccak256.js'\nimport { hashMessage } from '../utils/signature/hashMessage.js'\nimport { hashTypedData } from '../utils/signature/hashTypedData.js'\nimport type { SerializeTransactionFn } from '../utils/transaction/serializeTransaction.js'\nimport * as Transaction from './Transaction.js'\n\nexport type Account_base<source extends string = string> = RequiredBy<\n  LocalAccount<source>,\n  'sign' | 'signAuthorization' | 'signTransaction'\n> & {\n  /** Key type. */\n  keyType: SignatureEnvelope.Type\n  /** Sign transaction fn. */\n  signTransaction: <\n    serializer extends\n      SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<Transaction.TransactionSerializableTempo>,\n    transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n  >(\n    transaction: transaction,\n    options?:\n      | {\n          serializer?: serializer | undefined\n        }\n      | undefined,\n  ) => Promise<Hex.Hex>\n}\n\nexport type RootAccount = Account_base<'root'> & {\n  /** Sign key authorization. */\n  signKeyAuthorization: (\n    key: Pick<AccessKeyAccount, 'accessKeyAddress' | 'keyType'>,\n    parameters?: Pick<KeyAuthorization.KeyAuthorization, 'expiry' | 'limits'>,\n  ) => Promise<KeyAuthorization.Signed>\n}\n\nexport type AccessKeyAccount = Account_base<'accessKey'> & {\n  /** Access key ID. */\n  accessKeyAddress: Address.Address\n}\n\nexport type Account = OneOf<RootAccount | AccessKeyAccount>\n\n/**\n * Instantiates an Account from a headless WebAuthn credential (P256 private key).\n *\n * @example\n * ```ts\n * import { Account } from 'tempo.ts/viem'\n *\n * const account = Account.fromHeadlessWebAuthn('0x...')\n * ```\n *\n * @param privateKey P256 private key.\n * @returns Account.\n */\nexport function fromHeadlessWebAuthn<\n  const options extends fromHeadlessWebAuthn.Options,\n>(\n  privateKey: Hex.Hex,\n  options: options | fromHeadlessWebAuthn.Options,\n): fromHeadlessWebAuthn.ReturnValue<options> {\n  const { access, rpId, origin } = options\n\n  const publicKey = P256.getPublicKey({ privateKey })\n\n  return from({\n    access,\n    keyType: 'webAuthn',\n    publicKey,\n    async sign({ hash }) {\n      const { metadata, payload } = WebAuthnP256.getSignPayload({\n        ...options,\n        challenge: hash,\n        rpId,\n        origin,\n      })\n      const signature = P256.sign({\n        payload,\n        privateKey,\n        hash: true,\n      })\n      return SignatureEnvelope.serialize({\n        metadata,\n        signature,\n        publicKey,\n        type: 'webAuthn',\n      })\n    },\n  }) as never\n}\n\nexport declare namespace fromHeadlessWebAuthn {\n  export type Options = Omit<\n    WebAuthnP256.getSignPayload.Options,\n    'challenge' | 'rpId' | 'origin'\n  > &\n    Pick<from.Parameters, 'access'> & {\n      rpId: string\n      origin: string\n    }\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\n/**\n * Instantiates an Account from a P256 private key.\n *\n * @example\n * ```ts\n * import { Account } from 'tempo.ts/viem'\n *\n * const account = Account.fromP256('0x...')\n * ```\n *\n * @param privateKey P256 private key.\n * @returns Account.\n */\nexport function fromP256<const options extends fromP256.Options>(\n  privateKey: Hex.Hex,\n  options: options | fromP256.Options = {},\n): fromP256.ReturnValue<options> {\n  const { access } = options\n  const publicKey = P256.getPublicKey({ privateKey })\n\n  return from({\n    access,\n    keyType: 'p256',\n    publicKey,\n    async sign({ hash }) {\n      const signature = P256.sign({ payload: hash, privateKey })\n      return SignatureEnvelope.serialize({\n        signature,\n        publicKey,\n        type: 'p256',\n      })\n    },\n  }) as never\n}\n\nexport declare namespace fromP256 {\n  export type Options = Pick<from.Parameters, 'access'>\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\n/**\n * Instantiates an Account from a Secp256k1 private key.\n *\n * @example\n * ```ts\n * import { Account } from 'tempo.ts/viem'\n *\n * const account = Account.fromSecp256k1('0x...')\n * ```\n *\n * @param privateKey Secp256k1 private key.\n * @returns Account.\n */\nexport function fromSecp256k1<const options extends fromSecp256k1.Options>(\n  privateKey: Hex.Hex,\n  options: options | fromSecp256k1.Options = {},\n): fromSecp256k1.ReturnValue<options> {\n  const { access } = options\n  const publicKey = Secp256k1.getPublicKey({ privateKey })\n\n  return from({\n    access,\n    keyType: 'secp256k1',\n    publicKey,\n    async sign(parameters) {\n      const { hash } = parameters\n      const signature = Secp256k1.sign({ payload: hash, privateKey })\n      return Signature.toHex(signature)\n    },\n  }) as never\n}\n\nexport declare namespace fromSecp256k1 {\n  export type Options = Pick<from.Parameters, 'access'>\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\n/**\n * Instantiates an Account from a WebAuthn credential.\n *\n * @example\n *\n * ### Create Passkey + Instantiate Account\n *\n * Create a credential with `WebAuthnP256.createCredential` and then instantiate\n * a Viem Account with `Account.fromWebAuthnP256`.\n *\n * It is highly recommended to store the credential's public key in an external store\n * for future use (ie. for future calls to `WebAuthnP256.getCredential`).\n *\n * ```ts\n * import { Account, WebAuthnP256 } from 'tempo.ts/viem'\n * import { publicKeyStore } from './store'\n *\n * // 1. Create credential\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * // 2. Instantiate account\n * const account = Account.fromWebAuthnP256(credential)\n *\n * // 3. Store public key\n * await publicKeyStore.set(credential.id, credential.publicKey)\n *\n * ```\n *\n * @example\n *\n * ### Get Credential + Instantiate Account\n *\n * Gets a credential from `WebAuthnP256.getCredential` and then instantiates\n * an account with `Account.fromWebAuthnP256`.\n *\n * The `getPublicKey` function is required to fetch the public key paired with the credential\n * from an external store. The public key is required to derive the account's address.\n *\n * ```ts\n * import { Account, WebAuthnP256 } from 'tempo.ts/viem'\n * import { publicKeyStore } from './store'\n *\n * // 1. Get credential\n * const credential = await WebAuthnP256.getCredential({\n *   async getPublicKey(credential) {\n *     // 2. Get public key from external store.\n *     return await publicKeyStore.get(credential.id)\n *   }\n * })\n *\n * // 3. Instantiate account\n * const account = Account.fromWebAuthnP256(credential)\n * ```\n *\n * @param credential WebAuthnP256 credential.\n * @returns Account.\n */\nexport function fromWebAuthnP256(\n  credential: fromWebAuthnP256.Credential,\n  options: fromWebAuthnP256.Options = {},\n): fromWebAuthnP256.ReturnValue {\n  const { id } = credential\n  const publicKey = PublicKey.fromHex(credential.publicKey)\n  return from({\n    keyType: 'webAuthn',\n    publicKey,\n    async sign({ hash }) {\n      const { metadata, signature } = await WebAuthnP256.sign({\n        ...options,\n        challenge: hash,\n        credentialId: id,\n      })\n      return SignatureEnvelope.serialize({\n        publicKey,\n        metadata,\n        signature,\n        type: 'webAuthn',\n      })\n    },\n  })\n}\n\nexport declare namespace fromWebAuthnP256 {\n  export type Credential = {\n    id: WebAuthnP256.P256Credential['id']\n    publicKey: Hex.Hex\n  }\n\n  export type Options = {\n    getFn?: WebAuthnP256.sign.Options['getFn'] | undefined\n    rpId?: WebAuthnP256.sign.Options['rpId'] | undefined\n  }\n\n  export type ReturnValue = from.ReturnValue\n}\n\n/**\n * Instantiates an Account from a P256 private key.\n *\n * @example\n * ```ts\n * import { Account } from 'tempo.ts/viem'\n * import { WebCryptoP256 } from 'ox'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n *\n * const account = Account.fromWebCryptoP256(keyPair)\n * ```\n *\n * @param keyPair WebCryptoP256 key pair.\n * @returns Account.\n */\nexport function fromWebCryptoP256<\n  const options extends fromWebCryptoP256.Options,\n>(\n  keyPair: Awaited<ReturnType<typeof WebCryptoP256.createKeyPair>>,\n  options: options | fromWebCryptoP256.Options = {},\n): fromWebCryptoP256.ReturnValue<options> {\n  const { access } = options\n  const { publicKey, privateKey } = keyPair\n\n  return from({\n    access,\n    keyType: 'p256',\n    publicKey,\n    async sign({ hash }) {\n      const signature = await WebCryptoP256.sign({ payload: hash, privateKey })\n      return SignatureEnvelope.serialize({\n        signature,\n        prehash: true,\n        publicKey,\n        type: 'p256',\n      })\n    },\n  }) as never\n}\n\nexport declare namespace fromWebCryptoP256 {\n  export type Options = Pick<from.Parameters, 'access'>\n\n  export type ReturnValue<options extends Options = Options> =\n    from.ReturnValue<options>\n}\n\nexport async function signKeyAuthorization(\n  account: LocalAccount,\n  parameters: signKeyAuthorization.Parameters,\n): Promise<signKeyAuthorization.ReturnValue> {\n  const { key, expiry, limits } = parameters\n  const { accessKeyAddress, keyType: type } = key\n\n  const signature = await account.sign!({\n    hash: KeyAuthorization.getSignPayload({\n      address: accessKeyAddress,\n      expiry,\n      limits,\n      type,\n    }),\n  })\n  return KeyAuthorization.from({\n    address: accessKeyAddress,\n    expiry,\n    limits,\n    signature: SignatureEnvelope.from(signature),\n    type,\n  })\n}\n\nexport declare namespace signKeyAuthorization {\n  type Parameters = Pick<\n    KeyAuthorization.KeyAuthorization,\n    'expiry' | 'limits'\n  > & {\n    key: Pick<AccessKeyAccount, 'accessKeyAddress' | 'keyType'>\n  }\n\n  type ReturnValue = KeyAuthorization.Signed\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction fromBase(parameters: fromBase.Parameters): Account_base {\n  const {\n    keyType = 'secp256k1',\n    parentAddress,\n    source = 'privateKey',\n  } = parameters\n\n  const address = parentAddress ?? Address.fromPublicKey(parameters.publicKey)\n  const publicKey = PublicKey.toHex(parameters.publicKey, {\n    includePrefix: false,\n  })\n\n  async function sign({ hash }: { hash: Hex.Hex }) {\n    const signature = await parameters.sign({ hash })\n    if (parentAddress)\n      return SignatureEnvelope.serialize(\n        SignatureEnvelope.from({\n          userAddress: parentAddress,\n          inner: SignatureEnvelope.from(signature),\n          type: 'keychain',\n        }),\n      )\n    // Don't need to append magic bytes to secp256k1 signatures as they are\n    // backwards compatible with existing verification logic.\n    if (keyType === 'secp256k1') return signature\n    return Hex.concat(signature, SignatureEnvelope.magicBytes)\n  }\n\n  return {\n    address: Address.checksum(address),\n    keyType,\n    sign,\n    async signAuthorization(parameters) {\n      const { chainId, nonce } = parameters\n      const address = parameters.contractAddress ?? parameters.address\n      const signature = await sign({\n        hash: hashAuthorization({ address, chainId, nonce }),\n      })\n      const envelope = SignatureEnvelope.from(signature)\n      if (envelope.type !== 'secp256k1')\n        throw new Error(\n          'Unsupported signature type. Expected `secp256k1` but got `' +\n            envelope.type +\n            '`.',\n        )\n      const { r, s, yParity } = envelope.signature\n      return {\n        address,\n        chainId,\n        nonce,\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity,\n      }\n    },\n    async signMessage(parameters) {\n      const { message } = parameters\n      return await sign({ hash: hashMessage(message) })\n    },\n    async signTransaction(transaction, options) {\n      const { serializer = Transaction.serialize } = options ?? {}\n      const signature = await sign({\n        hash: keccak256(await serializer(transaction)),\n      })\n      const envelope = SignatureEnvelope.from(signature)\n      return await serializer(transaction, envelope as never)\n    },\n    async signTypedData(typedData) {\n      return await sign({ hash: hashTypedData(typedData) })\n    },\n    publicKey,\n    source,\n    type: 'local',\n  }\n}\n\ndeclare namespace fromBase {\n  export type Parameters = {\n    /** Parent address. */\n    parentAddress?: Address.Address | undefined\n    /** Public key. */\n    publicKey: PublicKey.PublicKey\n    /** Key type. */\n    keyType?: SignatureEnvelope.Type | undefined\n    /** Sign function. */\n    sign: NonNullable<LocalAccount['sign']>\n    /** Source. */\n    source?: string | undefined\n  }\n\n  export type ReturnValue = Account_base\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction fromRoot(parameters: fromRoot.Parameters): RootAccount {\n  const account = fromBase(parameters)\n  return {\n    ...account,\n    source: 'root',\n    async signKeyAuthorization(key, parameters = {}) {\n      const { expiry, limits } = parameters\n      const { accessKeyAddress, keyType: type } = key\n\n      const signature = await account.sign({\n        hash: KeyAuthorization.getSignPayload({\n          address: accessKeyAddress,\n          expiry,\n          limits,\n          type,\n        }),\n      })\n      const keyAuthorization = KeyAuthorization.from({\n        address: accessKeyAddress,\n        expiry,\n        limits,\n        signature: SignatureEnvelope.from(signature),\n        type,\n      })\n      return keyAuthorization\n    },\n  }\n}\n\ndeclare namespace fromRoot {\n  export type Parameters = fromBase.Parameters\n\n  export type ReturnValue = RootAccount\n}\n\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction fromAccessKey(parameters: fromAccessKey.Parameters): AccessKeyAccount {\n  const { access } = parameters\n  const { address: parentAddress } = parseAccount(access)\n  const account = fromBase({ ...parameters, parentAddress })\n  return {\n    ...account,\n    accessKeyAddress: Address.fromPublicKey(parameters.publicKey),\n    source: 'accessKey',\n  }\n}\n\ndeclare namespace fromAccessKey {\n  export type Parameters = fromBase.Parameters & {\n    /**\n     * Parent account to access.\n     * If defined, this account will act as an \"access key\", and use\n     * the parent account's address as the keychain address.\n     */\n    access: viem_Account | Address.Address\n  }\n\n  export type ReturnValue = AccessKeyAccount\n}\n\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction from<const parameters extends from.Parameters>(\n  parameters: parameters | from.Parameters,\n): from.ReturnValue<parameters> {\n  const { access } = parameters\n  if (access) return fromAccessKey(parameters) as never\n  return fromRoot(parameters) as never\n}\n\ndeclare namespace from {\n  export type Parameters = OneOf<fromRoot.Parameters | fromAccessKey.Parameters>\n\n  export type ReturnValue<\n    parameters extends {\n      access?: fromAccessKey.Parameters['access'] | undefined\n    } = {\n      access?: fromAccessKey.Parameters['access'] | undefined\n    },\n  > = parameters extends {\n    access: fromAccessKey.Parameters['access']\n  }\n    ? AccessKeyAccount\n    : RootAccount\n}\n\n// Export types required for inference.\n// biome-ignore lint/performance/noBarrelFile: _\nexport {\n  /** @deprecated */\n  KeyAuthorization as z_KeyAuthorization,\n  /** @deprecated */\n  SignatureEnvelope as z_SignatureEnvelope,\n  /** @deprecated */\n  TxEnvelopeTempo as z_TxEnvelopeTempo,\n} from 'ox/tempo'\n", "import { p256 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['sign', 'verify'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates an ECDH P256 key pair for key agreement that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * - a `publicKey` of type {@link ox#PublicKey.PublicKey}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPairECDH()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPairECDH(\n  options: createKeyPairECDH.Options = {},\n): Promise<createKeyPairECDH.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['deriveKey', 'deriveBits'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPairECDH {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key using Web Crypto APIs.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = await WebCryptoP256.createKeyPairECDH()\n * const { publicKey: publicKeyB } = await WebCryptoP256.createKeyPairECDH()\n *\n * const sharedSecret = await WebCryptoP256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport async function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): Promise<getSharedSecret.ReturnType<as>> {\n  const { as = 'Hex', privateKey, publicKey } = options\n\n  if (privateKey.algorithm.name === 'ECDSA') {\n    throw new Error(\n      'privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.',\n    )\n  }\n\n  const publicKeyCrypto = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(publicKey),\n    { name: 'ECDH', namedCurve: 'P-256' },\n    false,\n    [],\n  )\n\n  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKeyCrypto,\n    },\n    privateKey,\n    256, // 32 bytes * 8 bits/byte\n  )\n\n  const sharedSecret = new Uint8Array(sharedSecretBuffer)\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation (must be a CryptoKey for ECDH).\n     */\n    privateKey: CryptoKey\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | PublicKey.toBytes.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(\n  options: sign.Options,\n): Promise<Signature.Signature<false>> {\n  const { payload, privateKey } = options\n  const signature = await globalThis.crypto.subtle.sign(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    privateKey,\n    Bytes.from(payload),\n  )\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature))\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32))\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64))\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s\n  return { r, s }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /** Payload to sign. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** ECDSA private key. */\n    privateKey: CryptoKey\n  }\n\n  type ErrorType = Bytes.fromArray.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options: verify.Options): Promise<boolean> {\n  const { payload, signature } = options\n\n  const publicKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(options.publicKey),\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    true,\n    ['verify'],\n  )\n\n  return await globalThis.crypto.subtle.verify(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    publicKey,\n    Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)),\n    Bytes.from(payload),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<false>\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "// TODO: Find opportunities to make this file less duplicated + more simplified with Viem v3.\n\nimport type { Address } from 'abitype'\nimport * as Hex from 'ox/Hex'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport {\n  type AuthorizationTempo,\n  type KeyAuthorization,\n  type TransactionReceipt as ox_TransactionReceipt,\n  SignatureEnvelope,\n  TxEnvelopeTempo as TxTempo,\n} from 'ox/tempo'\nimport type { Account } from '../accounts/types.js'\nimport type { FeeValuesEIP1559 } from '../types/fee.js'\nimport type { Signature as viem_Signature } from '../types/misc.js'\nimport type {\n  RpcTransaction as viem_RpcTransaction,\n  RpcTransactionRequest as viem_RpcTransactionRequest,\n} from '../types/rpc.js'\nimport type {\n  AccessList,\n  TransactionBase,\n  TransactionRequestBase,\n  TransactionSerializableBase,\n  TransactionSerializedGeneric,\n  Transaction as viem_Transaction,\n  TransactionReceipt as viem_TransactionReceipt,\n  TransactionRequest as viem_TransactionRequest,\n  TransactionSerializable as viem_TransactionSerializable,\n  TransactionSerialized as viem_TransactionSerialized,\n  TransactionType as viem_TransactionType,\n} from '../types/transaction.js'\nimport type { ExactPartial, OneOf, PartialBy } from '../types/utils.js'\nimport { getTransactionType as viem_getTransactionType } from '../utils/transaction/getTransactionType.js'\nimport {\n  type ParseTransactionReturnType,\n  parseTransaction as viem_parseTransaction,\n} from '../utils/transaction/parseTransaction.js'\nimport { serializeTransaction as viem_serializeTransaction } from '../utils/transaction/serializeTransaction.js'\n\nexport type Transaction<\n  bigintType = bigint,\n  numberType = number,\n  pending extends boolean = false,\n> = OneOf<\n  | viem_Transaction<bigintType, numberType, pending>\n  | TransactionTempo<bigintType, numberType, pending>\n>\nexport type TransactionRpc<pending extends boolean = false> = OneOf<\n  | viem_RpcTransaction<pending>\n  | (Omit<\n      TransactionTempo<Hex.Hex, Hex.Hex, pending, '0x76'>,\n      'authorizationList' | 'keyAuthorization' | 'signature'\n    > & {\n      authorizationList?: AuthorizationTempo.ListRpc | undefined\n      keyAuthorization?: KeyAuthorization.Rpc | null | undefined\n      signature: SignatureEnvelope.SignatureEnvelopeRpc\n    })\n>\n\nexport type TransactionTempo<\n  quantity = bigint,\n  index = number,\n  isPending extends boolean = boolean,\n  type = 'tempo',\n> = PartialBy<\n  Omit<TransactionBase<quantity, index, isPending>, 'input' | 'value' | 'to'>,\n  'r' | 's' | 'v' | 'yParity'\n> & {\n  accessList: AccessList\n  authorizationList?: AuthorizationTempo.ListSigned<quantity, index> | undefined\n  calls: readonly TxTempo.Call<quantity>[]\n  chainId: index\n  feeToken?: Address | undefined\n  feePayerSignature?: viem_Signature | undefined\n  keyAuthorization?: KeyAuthorization.Signed<quantity, index> | null | undefined\n  nonceKey?: quantity | undefined\n  signature: SignatureEnvelope.SignatureEnvelope\n  type: type\n  validBefore?: index | undefined\n  validAfter?: index | undefined\n} & FeeValuesEIP1559<quantity>\n\nexport type TransactionRequest<\n  bigintType = bigint,\n  numberType = number,\n> = OneOf<\n  | viem_TransactionRequest<bigintType, numberType>\n  | TransactionRequestTempo<bigintType, numberType>\n>\nexport type TransactionRequestRpc = OneOf<\n  viem_RpcTransactionRequest | TransactionRequestTempo<Hex.Hex, Hex.Hex, '0x76'>\n>\n\nexport type TransactionReceipt<\n  quantity = bigint,\n  index = number,\n  status = 'success' | 'reverted',\n  type = TransactionType,\n> = viem_TransactionReceipt<quantity, index, status, type> & {\n  feePayer?: Address | undefined\n  feeToken?: Address | undefined\n}\n\nexport type TransactionReceiptRpc = TransactionReceipt<\n  Hex.Hex,\n  Hex.Hex,\n  ox_TransactionReceipt.RpcStatus,\n  ox_TransactionReceipt.RpcType\n>\n\nexport type TransactionRequestTempo<\n  quantity = bigint,\n  index = number,\n  type = 'tempo',\n> = TransactionRequestBase<quantity, index, type> &\n  ExactPartial<FeeValuesEIP1559<quantity>> & {\n    accessList?: AccessList | undefined\n    keyAuthorization?: KeyAuthorization.Signed<quantity, index> | undefined\n    calls?: readonly TxTempo.Call<quantity>[] | undefined\n    feePayer?: Account | true | undefined\n    feeToken?: Address | bigint | undefined\n    nonceKey?: 'random' | quantity | undefined\n    validBefore?: index | undefined\n    validAfter?: index | undefined\n  }\n\nexport type TransactionSerializable = OneOf<\n  viem_TransactionSerializable | TransactionSerializableTempo\n>\n\nexport type TransactionSerializableTempo<\n  quantity = bigint,\n  index = number,\n> = TransactionSerializableBase<quantity, index> &\n  ExactPartial<FeeValuesEIP1559<quantity>> & {\n    accessList?: AccessList | undefined\n    calls: readonly TxTempo.Call<quantity>[]\n    chainId: number\n    feeToken?: Address | bigint | undefined\n    feePayerSignature?: viem_Signature | null | undefined\n    keyAuthorization?: KeyAuthorization.Signed<quantity, index> | undefined\n    nonceKey?: quantity | undefined\n    signature?: SignatureEnvelope.SignatureEnvelope<quantity, index> | undefined\n    validBefore?: index | undefined\n    validAfter?: index | undefined\n    type?: 'tempo' | undefined\n  }\n\nexport type TransactionSerialized<\n  type extends TransactionType = TransactionType,\n> = viem_TransactionSerialized<type> | TransactionSerializedTempo\n\nexport type TransactionSerializedTempo = `0x76${string}`\n\nexport type TransactionType = viem_TransactionType | 'tempo'\n\nexport function getType(\n  transaction: Record<string, unknown>,\n): Transaction['type'] {\n  const account = transaction.account as\n    | { keyType?: string | undefined }\n    | undefined\n  if (\n    (account?.keyType && account.keyType !== 'secp256k1') ||\n    typeof transaction.calls !== 'undefined' ||\n    typeof transaction.feePayer !== 'undefined' ||\n    typeof transaction.feeToken !== 'undefined' ||\n    typeof transaction.keyAuthorization !== 'undefined' ||\n    typeof transaction.nonceKey !== 'undefined' ||\n    typeof transaction.signature !== 'undefined' ||\n    typeof transaction.validBefore !== 'undefined' ||\n    typeof transaction.validAfter !== 'undefined'\n  )\n    return 'tempo' as never\n  if (transaction.type) return transaction.type as never\n  return viem_getTransactionType(transaction) as never\n}\n\nexport function isTempo(transaction: Record<string, unknown>) {\n  try {\n    const type = getType(transaction)\n    return type === 'tempo'\n  } catch {\n    return false\n  }\n}\n\nexport function deserialize<\n  const serialized extends TransactionSerializedGeneric,\n>(serializedTransaction: serialized): deserialize.ReturnValue<serialized> {\n  const type = Hex.slice(serializedTransaction, 0, 1)\n  if (type === '0x76') {\n    const from =\n      Hex.slice(serializedTransaction, -6) === '0xfeefeefeefee'\n        ? Hex.slice(serializedTransaction, -26, -6)\n        : undefined\n    return {\n      ...deserializeTempo(serializedTransaction as `0x76${string}`),\n      from,\n    } as never\n  }\n  return viem_parseTransaction(serializedTransaction) as never\n}\n\nexport declare namespace deserialize {\n  export type ReturnValue<\n    serialized extends\n      TransactionSerializedGeneric = TransactionSerializedGeneric,\n  > = serialized extends TransactionSerializedTempo\n    ? TransactionSerializableTempo\n    : ParseTransactionReturnType<serialized>\n}\n\nexport async function serialize(\n  transaction: TransactionSerializable & {\n    feePayer?: Account | true | undefined\n    from?: Address | undefined\n  },\n  signature?:\n    | OneOf<SignatureEnvelope.SignatureEnvelope | viem_Signature>\n    | undefined,\n) {\n  // If the transaction is not a Tempo transaction, route to Viem serializer.\n  if (!isTempo(transaction)) {\n    if (signature && 'type' in signature && signature.type !== 'secp256k1')\n      throw new Error(\n        'Unsupported signature type. Expected `secp256k1` but got `' +\n          signature.type +\n          '`.',\n      )\n    if (signature && 'type' in signature) {\n      const { r, s, yParity } = signature?.signature!\n      return viem_serializeTransaction(transaction as never, {\n        r: Hex.fromNumber(r, { size: 32 }),\n        s: Hex.fromNumber(s, { size: 32 }),\n        yParity,\n      })\n    }\n    return viem_serializeTransaction(transaction as never, signature)\n  }\n\n  const type = getType(transaction)\n  if (type === 'tempo')\n    return serializeTempo(\n      transaction as TransactionSerializableTempo,\n      signature,\n    )\n\n  throw new Error('Unsupported transaction type')\n}\n\n////////////////////////////////////////////////////////////////////////////////////\n// Internal\n\n/** @internal */\nfunction deserializeTempo(\n  serializedTransaction: TransactionSerializedTempo,\n): TransactionSerializableTempo {\n  const { feePayerSignature, nonce, ...tx } = TxTempo.deserialize(\n    serializedTransaction,\n  )\n  return {\n    ...tx,\n    nonce: Number(nonce ?? 0n),\n    feePayerSignature: feePayerSignature\n      ? {\n          r: Hex.fromNumber(feePayerSignature.r, { size: 32 }),\n          s: Hex.fromNumber(feePayerSignature.s, { size: 32 }),\n          yParity: feePayerSignature.yParity,\n        }\n      : feePayerSignature,\n  } satisfies TransactionSerializableTempo\n}\n\n/** @internal */\nasync function serializeTempo(\n  transaction: TransactionSerializableTempo & {\n    feePayer?: Account | true | undefined\n    from?: Address | undefined\n  },\n  sig?: OneOf<SignatureEnvelope.SignatureEnvelope | viem_Signature> | undefined,\n) {\n  const signature = (() => {\n    if (transaction.signature) return transaction.signature\n    if (sig && 'type' in sig) return sig as SignatureEnvelope.SignatureEnvelope\n    if (sig)\n      return SignatureEnvelope.from({\n        r: BigInt(sig.r!),\n        s: BigInt(sig.s!),\n        yParity: Number(sig.yParity!),\n      })\n    return undefined\n  })()\n\n  const { chainId, feePayer, feePayerSignature, nonce, ...rest } = transaction\n\n  const transaction_ox = {\n    ...rest,\n    calls: rest.calls?.length\n      ? rest.calls\n      : [\n          {\n            to:\n              rest.to ||\n              (!rest.data || rest.data === '0x'\n                ? '0x0000000000000000000000000000000000000000'\n                : undefined),\n            value: rest.value,\n            data: rest.data,\n          },\n        ],\n    chainId: Number(chainId),\n    feePayerSignature: feePayerSignature\n      ? {\n          r: BigInt(feePayerSignature.r!),\n          s: BigInt(feePayerSignature.s!),\n          yParity: Number(feePayerSignature.yParity),\n        }\n      : feePayer\n        ? null\n        : undefined,\n    type: 'tempo',\n    ...(nonce ? { nonce: BigInt(nonce) } : {}),\n  } satisfies TxTempo.TxEnvelopeTempo\n\n  // If we have marked the transaction as intended to be paid\n  // by a fee payer (feePayer: true), we will not use the fee token\n  // as the fee payer will choose their fee token.\n  if (feePayer === true) delete transaction_ox.feeToken\n\n  if (signature && typeof transaction.feePayer === 'object') {\n    const tx = TxTempo.from(transaction_ox, {\n      signature,\n    })\n\n    const sender = (() => {\n      if (transaction.from) return transaction.from\n      if (signature.type === 'secp256k1')\n        return Secp256k1.recoverAddress({\n          payload: TxTempo.getSignPayload(tx),\n          signature: signature.signature,\n        })\n      throw new Error('Unable to extract sender from transaction or signature.')\n    })()\n\n    const hash = TxTempo.getFeePayerSignPayload(tx, {\n      sender,\n    })\n\n    const feePayerSignature = await transaction.feePayer.sign!({\n      hash,\n    })\n\n    return TxTempo.serialize(tx, {\n      feePayerSignature: Signature.from(feePayerSignature),\n    })\n  }\n\n  if (feePayer === true) {\n    const serialized = TxTempo.serialize(transaction_ox, {\n      feePayerSignature: null,\n      signature,\n    })\n    // if the transaction is ready to be sent off (signed), add the sender\n    // and a fee marker to the serialized transaction, so the fee payer proxy\n    // can infer the sender address.\n    if (transaction.from && signature)\n      return Hex.concat(serialized, transaction.from, '0xfeefeefeefee')\n    return serialized\n  }\n\n  return TxTempo.serialize(\n    // If we have specified a fee payer, the user will not be signing over the fee token.\n    // Defer the fee token signing to the fee payer.\n    { ...transaction_ox, ...(feePayer ? { feeToken: undefined } : {}) },\n    {\n      feePayerSignature: undefined,\n      signature,\n    },\n  )\n}\n\n// Export types required for inference.\n// biome-ignore lint/performance/noBarrelFile: _\nexport {\n  /** @deprecated */\n  KeyAuthorization as z_KeyAuthorization,\n  /** @deprecated */\n  SignatureEnvelope as z_SignatureEnvelope,\n  /** @deprecated */\n  TxEnvelopeTempo as z_TxEnvelopeTempo,\n} from 'ox/tempo'\n", "export const accountImplementation =\n  '0x7702c00000000000000000000000000000000000'\nexport const accountRegistrar = '0x7702ac0000000000000000000000000000000000'\nexport const feeManager = '0xfeec000000000000000000000000000000000000'\nexport const nonceManager = '0x4e4F4E4345000000000000000000000000000000'\nexport const pathUsd = '0x20c0000000000000000000000000000000000000'\nexport const stablecoinExchange = '0xdec0000000000000000000000000000000000000'\nexport const tip20Factory = '0x20fc000000000000000000000000000000000000'\nexport const tip403Registry = '0x403c000000000000000000000000000000000000'\n", "// biome-ignore lint/performance/noBarrelFile: _\nexport * as amm from './amm.js'\nexport * as dex from './dex.js'\nexport * as faucet from './faucet.js'\nexport * as fee from './fee.js'\nexport * as nonce from './nonce.js'\nexport * as policy from './policy.js'\nexport * as reward from './reward.js'\nexport * as token from './token.js'\n", "import type { Address } from 'abitype'\nimport { PoolId, TokenId } from 'ox/tempo'\nimport type { Account } from '../../accounts/types.js'\nimport type { MulticallParameters } from '../../actions/public/multicall.js'\nimport { multicall } from '../../actions/public/multicall.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { Compute, OneOf, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Gets the reserves for a liquidity pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const pool = await Actions.amm.getPool(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The pool reserves.\n */\nexport async function getPool<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getPool.Parameters,\n): Promise<getPool.ReturnValue> {\n  const { userToken, validatorToken, ...rest } = parameters\n  const [pool, totalSupply] = await multicall(client, {\n    ...rest,\n    contracts: getPool.calls({ userToken, validatorToken }),\n    allowFailure: false,\n    deployless: true,\n  })\n  return {\n    reserveUserToken: pool.reserveUserToken,\n    reserveValidatorToken: pool.reserveValidatorToken,\n    totalSupply,\n  }\n}\n\nexport namespace getPool {\n  export type Parameters = UnionOmit<\n    MulticallParameters,\n    'allowFailure' | 'contracts' | 'deployless'\n  > &\n    Args\n\n  export type Args = {\n    /** Address or ID of the user token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = Compute<{\n    /** Reserve of user token. */\n    reserveUserToken: bigint\n    /** Reserve of validator token. */\n    reserveValidatorToken: bigint\n    /** Total supply of LP tokens. */\n    totalSupply: bigint\n  }>\n\n  /**\n   * Defines calls to the `getPool` and `totalSupply` functions.\n   *\n   * @param args - Arguments.\n   * @returns The calls.\n   */\n  export function calls(args: Args) {\n    const { userToken, validatorToken } = args\n    return [\n      defineCall({\n        address: Addresses.feeManager,\n        abi: Abis.feeAmm,\n        args: [TokenId.toAddress(userToken), TokenId.toAddress(validatorToken)],\n        functionName: 'getPool',\n      }),\n      defineCall({\n        address: Addresses.feeManager,\n        abi: Abis.feeAmm,\n        args: [PoolId.from({ userToken, validatorToken })],\n        functionName: 'totalSupply',\n      }),\n    ] as const\n  }\n}\n\n/**\n * Gets the LP token balance for an account in a specific pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const poolId = await Actions.amm.getPoolId(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n * })\n *\n * const balance = await Actions.amm.getLiquidityBalance(client, {\n *   poolId,\n *   address: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The LP token balance.\n */\nexport async function getLiquidityBalance<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getLiquidityBalance.Parameters,\n): Promise<getLiquidityBalance.ReturnValue> {\n  const { address, poolId, userToken, validatorToken, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getLiquidityBalance.call({\n      address,\n      poolId,\n      userToken,\n      validatorToken,\n    } as never),\n  })\n}\n\nexport namespace getLiquidityBalance {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Address to check balance for. */\n    address: Address\n  } & OneOf<\n    | {\n        /** Pool ID. */\n        poolId: Hex\n      }\n    | {\n        /** User token. */\n        userToken: TokenId.TokenIdOrAddress\n        /** Validator token. */\n        validatorToken: TokenId.TokenIdOrAddress\n      }\n  >\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.feeAmm,\n    'liquidityBalances',\n    never\n  >\n\n  /**\n   * Defines a call to the `liquidityBalances` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { address } = args\n    const poolId = (() => {\n      if ('poolId' in args && args.poolId) return args.poolId!\n      if ('userToken' in args && 'validatorToken' in args)\n        return PoolId.from({\n          userToken: args.userToken,\n          validatorToken: args.validatorToken,\n        })\n      throw new Error(\n        '`poolId`, or `userToken` and `validatorToken` must be provided.',\n      )\n    })()\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      args: [poolId, address],\n      functionName: 'liquidityBalances',\n    })\n  }\n}\n\n/**\n * Performs a rebalance swap from validator token to user token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.rebalanceSwap(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n *   amountOut: 100n,\n *   to: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function rebalanceSwap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: rebalanceSwap.Parameters<chain, account>,\n): Promise<rebalanceSwap.ReturnValue> {\n  return rebalanceSwap.inner(writeContract, client, parameters)\n}\n\nexport namespace rebalanceSwap {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of user token to receive. */\n    amountOut: bigint\n    /** Address to send the user token to. */\n    to: Address\n    /** Address or ID of the user token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: rebalanceSwap.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { userToken, validatorToken, amountOut, to, ...rest } = parameters\n    const call = rebalanceSwap.call({\n      userToken,\n      validatorToken,\n      amountOut,\n      to,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `rebalanceSwap` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.amm.rebalanceSwap.call({\n   *       userToken: '0x20c0...beef',\n   *       validatorToken: '0x20c0...babe',\n   *       amountOut: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *     actions.amm.rebalanceSwap.call({\n   *       userToken: '0x20c0...babe',\n   *       validatorToken: '0x20c0...babe',\n   *       amountOut: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { userToken, validatorToken, amountOut, to } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      functionName: 'rebalanceSwap',\n      args: [\n        TokenId.toAddress(userToken),\n        TokenId.toAddress(validatorToken),\n        amountOut,\n        to,\n      ],\n    })\n  }\n\n  /**\n   * Extracts the `RebalanceSwap` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `RebalanceSwap` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeAmm,\n      logs,\n      eventName: 'RebalanceSwap',\n      strict: true,\n    })\n    if (!log) throw new Error('`RebalanceSwap` event not found.')\n    return log\n  }\n}\n\n/**\n * Performs a rebalance swap from validator token to user token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.amm.rebalanceSwapSync(client, {\n *   userToken: '0x...',\n *   validatorToken: '0x...',\n *   amountOut: 100n,\n *   to: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function rebalanceSwapSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: rebalanceSwapSync.Parameters<chain, account>,\n): Promise<rebalanceSwapSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await rebalanceSwap.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = rebalanceSwap.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace rebalanceSwapSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = rebalanceSwap.Parameters<chain, account>\n\n  export type Args = rebalanceSwap.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeAmm,\n      'RebalanceSwap',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n}\n\n/**\n * Adds liquidity to a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.mint(client, {\n *   userTokenAddress: '0x20c0...beef',\n *   validatorTokenAddress: '0x20c0...babe',\n *   validatorTokenAmount: 100n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function mint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mint.Parameters<chain, account>,\n): Promise<mint.ReturnValue> {\n  return mint.inner(writeContract, client, parameters)\n}\n\nexport namespace mint {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address to mint LP tokens to. */\n    to: Address\n    /** User token address. */\n    userTokenAddress: TokenId.TokenIdOrAddress\n    /** Validator token address. */\n    validatorTokenAddress: TokenId.TokenIdOrAddress\n    /** Amount of validator token to add. */\n    validatorTokenAmount: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: mint.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const {\n      to,\n      userTokenAddress,\n      validatorTokenAddress,\n      validatorTokenAmount,\n      ...rest\n    } = parameters\n    const call = mint.call({\n      to,\n      userTokenAddress,\n      validatorTokenAddress,\n      validatorTokenAmount,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `mint` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.amm.mint.call({\n   *       userTokenAddress: '0x20c0...beef',\n   *       validatorTokenAddress: '0x20c0...babe',\n   *       validatorTokenAmount: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *     actions.amm.mint.call({\n   *       userTokenAddress: '0x20c0...babe',\n   *       validatorTokenAddress: '0x20c0...babe',\n   *       validatorTokenAmount: 100n,\n   *       to: '0xfeed...fede',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const {\n      to,\n      userTokenAddress,\n      validatorTokenAddress,\n      validatorTokenAmount,\n    } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      functionName: 'mintWithValidatorToken',\n      args: [\n        TokenId.toAddress(userTokenAddress),\n        TokenId.toAddress(validatorTokenAddress),\n        validatorTokenAmount,\n        to,\n      ],\n    })\n  }\n\n  /**\n   * Extracts the `Mint` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `Mint` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeAmm,\n      logs,\n      eventName: 'Mint',\n      strict: true,\n    })\n    if (!log) throw new Error('`Mint` event not found.')\n    return log\n  }\n}\n\n/**\n * Adds liquidity to a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.mint(client, {\n *   userTokenAddress: '0x20c0...beef',\n *   validatorTokenAddress: '0x20c0...babe',\n *   validatorTokenAmount: 100n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function mintSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mintSync.Parameters<chain, account>,\n): Promise<mintSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await mint.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = mint.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace mintSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = mint.Parameters<chain, account>\n\n  export type Args = mint.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeAmm,\n      'Mint',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n}\n\n/**\n * Removes liquidity from a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.amm.burn(client, {\n *   userToken: '0x20c0...beef',\n *   validatorToken: '0x20c0...babe',\n *   liquidity: 50n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burn.Parameters<chain, account>,\n): Promise<burn.ReturnValue> {\n  return burn.inner(writeContract, client, parameters)\n}\n\nexport namespace burn {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of LP tokens to burn. */\n    liquidity: bigint\n    /** Address to send tokens to. */\n    to: Address\n    /** Address or ID of the user token. */\n    userToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the validator token. */\n    validatorToken: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: burn.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { liquidity, to, userToken, validatorToken, ...rest } = parameters\n    const call = burn.call({ liquidity, to, userToken, validatorToken })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `burn` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.amm.burn.call({\n   *       liquidity: 100n,\n   *       to: '0xfeed...fede',\n   *       userToken: '0x20c0...beef',\n   *       validatorToken: '0x20c0...babe',\n   *     }),\n   *     actions.amm.burn.call({\n   *       liquidity: 100n,\n   *       to: '0xfeed...fede',\n   *       userToken: '0x20c0...babe',\n   *       validatorToken: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { liquidity, to, userToken, validatorToken } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeAmm,\n      functionName: 'burn',\n      args: [\n        TokenId.toAddress(userToken),\n        TokenId.toAddress(validatorToken),\n        liquidity,\n        to,\n      ],\n    })\n  }\n\n  /**\n   * Extracts the `Burn` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `Burn` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeAmm,\n      logs,\n      eventName: 'Burn',\n      strict: true,\n    })\n    if (!log) throw new Error('`Burn` event not found.')\n    return log\n  }\n}\n\n/**\n * Removes liquidity from a pool.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.amm.burnSync(client, {\n *   userToken: '0x20c0...beef',\n *   validatorToken: '0x20c0...babe',\n *   liquidity: 50n,\n *   to: '0xfeed...fede',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnSync.Parameters<chain, account>,\n): Promise<burnSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await burn.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = burn.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace burnSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = burn.Parameters<chain, account>\n\n  export type Args = burn.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeAmm,\n      'Burn',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n}\n\n/**\n * Watches for rebalance swap events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchRebalanceSwap(client, {\n *   onRebalanceSwap: (args, log) => {\n *     console.log('Rebalance swap:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRebalanceSwap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchRebalanceSwap.Parameters,\n) {\n  const { onRebalanceSwap, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'RebalanceSwap',\n    args:\n      userToken !== undefined && validatorToken !== undefined\n        ? {\n            userToken: TokenId.toAddress(userToken),\n            validatorToken: TokenId.toAddress(validatorToken),\n          }\n        : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onRebalanceSwap(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRebalanceSwap {\n  export type Args = GetEventArgs<\n    typeof Abis.feeAmm,\n    'RebalanceSwap',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'RebalanceSwap'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'RebalanceSwap', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a rebalance swap occurs. */\n    onRebalanceSwap: (args: Args, log: Log) => void\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n\n/**\n * Watches for fee swap events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchFeeSwap(client, {\n *   onFeeSwap: (args, log) => {\n *     console.log('Fee swap:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchFeeSwap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchFeeSwap.Parameters,\n) {\n  const { onFeeSwap, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'FeeSwap',\n    args:\n      userToken !== undefined && validatorToken !== undefined\n        ? {\n            userToken: TokenId.toAddress(userToken),\n            validatorToken: TokenId.toAddress(validatorToken),\n          }\n        : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onFeeSwap(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchFeeSwap {\n  export type Args = GetEventArgs<\n    typeof Abis.feeAmm,\n    'FeeSwap',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'FeeSwap'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'FeeSwap', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a fee swap occurs. */\n    onFeeSwap: (args: Args, log: Log) => void\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n\n/**\n * Watches for liquidity mint events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchMint(client, {\n *   onMint: (args, log) => {\n *     console.log('Liquidity added:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchMint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchMint.Parameters) {\n  const { onMint, sender, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'Mint',\n    args: {\n      ...(sender !== undefined && {\n        sender: TokenId.toAddress(sender),\n      }),\n      ...(userToken !== undefined && {\n        userToken: TokenId.toAddress(userToken),\n      }),\n      ...(validatorToken !== undefined && {\n        validatorToken: TokenId.toAddress(validatorToken),\n      }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs)\n        onMint(\n          {\n            liquidity: log.args.liquidity,\n            sender: log.args.sender,\n            userToken: {\n              address: log.args.userToken,\n              amount: log.args.amountUserToken,\n            },\n            validatorToken: {\n              address: log.args.validatorToken,\n              amount: log.args.amountValidatorToken,\n            },\n          },\n          log,\n        )\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchMint {\n  export type Args = {\n    liquidity: bigint\n    sender: Address\n    userToken: {\n      address: Address\n      amount: bigint\n    }\n    validatorToken: {\n      address: Address\n      amount: bigint\n    }\n  }\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'Mint'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'Mint', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when liquidity is added. */\n    onMint: (args: Args, log: Log) => void\n    /** Address or ID of the sender to filter events. */\n    sender?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n\n/**\n * Watches for liquidity burn events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.amm.watchBurn(client, {\n *   onBurn: (args, log) => {\n *     console.log('Liquidity removed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBurn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchBurn.Parameters) {\n  const { onBurn, userToken, validatorToken, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeAmm,\n    eventName: 'Burn',\n    args:\n      userToken !== undefined && validatorToken !== undefined\n        ? {\n            userToken: TokenId.toAddress(userToken),\n            validatorToken: TokenId.toAddress(validatorToken),\n          }\n        : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onBurn(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchBurn {\n  export type Args = GetEventArgs<\n    typeof Abis.feeAmm,\n    'Burn',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeAmm, 'Burn'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeAmm, 'Burn', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when liquidity is removed. */\n    onBurn: (args: Args, log: Log) => void\n    /** Address or ID of the user token to filter events. */\n    userToken?: TokenId.TokenIdOrAddress | undefined\n    /** Address or ID of the validator token to filter events. */\n    validatorToken?: TokenId.TokenIdOrAddress | undefined\n  }\n}\n", "import type { Abi, AbiStateMutability, Address } from 'abitype'\nimport type {\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ExtractAbiItem,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { encodeFunctionData } from '../../utils/index.js'\n\nexport function defineCall<\n  const abi extends Abi,\n  const functionName extends ContractFunctionName<abi, AbiStateMutability>,\n  call extends ContractFunctionParameters<\n    abi,\n    AbiStateMutability,\n    functionName\n  >,\n>(\n  call:\n    | call\n    | ContractFunctionParameters<abi, AbiStateMutability, functionName>,\n): ContractFunctionParameters<\n  [ExtractAbiItem<abi, functionName>],\n  AbiStateMutability,\n  functionName\n> & {\n  data: Hex\n  to: Address\n} {\n  return {\n    ...(call as any),\n    data: encodeFunctionData(call as never),\n    to: call.address,\n  } as const\n}\n\n/**\n * Normalizes a value into a structured-clone compatible format.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone\n * @internal\n */\nexport function normalizeValue<type>(value: type): type {\n  if (Array.isArray(value)) return value.map(normalizeValue) as never\n  if (typeof value === 'function') return undefined as never\n  if (typeof value !== 'object' || value === null) return value\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    try {\n      return structuredClone(value)\n    } catch {\n      return undefined as never\n    }\n\n  const normalized: Record<string, unknown> = {}\n  for (const [k, v] of Object.entries(value)) normalized[k] = normalizeValue(v)\n  return normalized as never\n}\n", "import type { Address } from 'abitype'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport {\n  type ReadContractReturnType,\n  readContract,\n} from '../../actions/public/readContract.js'\nimport {\n  type WatchContractEventParameters,\n  watchContractEvent,\n} from '../../actions/public/watchContractEvent.js'\nimport {\n  type WriteContractReturnType,\n  writeContract,\n} from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log as viem_Log } from '../../types/log.js'\nimport type { Compute, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type {\n  GetAccountParameter,\n  ReadParameters,\n  WriteParameters,\n} from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Order type for limit orders.\n */\ntype OrderType = 'buy' | 'sell'\n\n/**\n * Buys a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.buy(client, {\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n *   amountOut: parseUnits('100', 6),\n *   maxAmountIn: parseUnits('105', 6),\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function buy<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: buy.Parameters<chain, account>,\n): Promise<buy.ReturnValue> {\n  return buy.inner(writeContract, client, parameters)\n}\n\nexport namespace buy {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokenOut to buy. */\n    amountOut: bigint\n    /** Maximum amount of tokenIn to spend. */\n    maxAmountIn: bigint\n    /** Address of the token to spend. */\n    tokenIn: Address\n    /** Address of the token to buy. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: buy.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { tokenIn, tokenOut, amountOut, maxAmountIn, ...rest } = parameters\n    const call = buy.call({ tokenIn, tokenOut, amountOut, maxAmountIn })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `swapExactAmountOut` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.buy.call({\n   *       tokenIn: '0x20c0...beef',\n   *       tokenOut: '0x20c0...babe',\n   *       amountOut: parseUnits('100', 6),\n   *       maxAmountIn: parseUnits('105', 6),\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountOut, maxAmountIn } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'swapExactAmountOut',\n      args: [tokenIn, tokenOut, amountOut, maxAmountIn],\n    })\n  }\n}\n\n/**\n * Buys a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.buySync(client, {\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n *   amountOut: parseUnits('100', 6),\n *   maxAmountIn: parseUnits('105', 6),\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function buySync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: buySync.Parameters<chain, account>,\n): Promise<buySync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await buy.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace buySync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = buy.Parameters<chain, account>\n\n  export type Args = buy.Args\n\n  export type ReturnValue = Compute<{\n    /** Transaction receipt. */\n    receipt: TransactionReceipt\n  }>\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Cancels an order from the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.cancel(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function cancel<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: cancel.Parameters<chain, account>,\n): Promise<cancel.ReturnValue> {\n  return cancel.inner(writeContract, client, parameters)\n}\n\nexport namespace cancel {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Order ID to cancel. */\n    orderId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: cancel.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { orderId, ...rest } = parameters\n    const call = cancel.call({ orderId })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `cancel` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.cancel.call({\n   *       orderId: 123n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { orderId } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'cancel',\n      args: [orderId],\n    })\n  }\n\n  /**\n   * Extracts the `OrderCancelled` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `OrderCancelled` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinExchange,\n      logs,\n      eventName: 'OrderCancelled',\n      strict: true,\n    })\n    if (!log) throw new Error('`OrderCancelled` event not found.')\n    return log\n  }\n}\n\n/**\n * Cancels an order from the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.cancelSync(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function cancelSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: cancelSync.Parameters<chain, account>,\n): Promise<cancelSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await cancel.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = cancel.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace cancelSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = cancel.Parameters<chain, account>\n\n  export type Args = cancel.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinExchange,\n      'OrderCancelled',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Creates a new trading pair on the DEX.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.createPair(client, {\n *   base: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function createPair<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createPair.Parameters<chain, account>,\n): Promise<createPair.ReturnValue> {\n  return createPair.inner(writeContract, client, parameters)\n}\n\nexport namespace createPair {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address of the base token for the pair. */\n    base: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: createPair.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { base, ...rest } = parameters\n    const call = createPair.call({ base })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `createPair` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.createPair.call({\n   *       base: '0x20c0...beef',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { base } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'createPair',\n      args: [base],\n    })\n  }\n\n  /**\n   * Extracts the `PairCreated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `PairCreated` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinExchange,\n      logs,\n      eventName: 'PairCreated',\n      strict: true,\n    })\n    if (!log) throw new Error('`PairCreated` event not found.')\n    return log\n  }\n}\n\n/**\n * Creates a new trading pair on the DEX.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.createPairSync(client, {\n *   base: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createPairSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createPairSync.Parameters<chain, account>,\n): Promise<createPairSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await createPair.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = createPair.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace createPairSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = createPair.Parameters<chain, account>\n\n  export type Args = createPair.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinExchange,\n      'PairCreated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Gets a user's token balance on the DEX.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const balance = await Actions.dex.getBalance(client, {\n *   account: '0x...',\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The user's token balance on the DEX.\n */\nexport async function getBalance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getBalance.Parameters<account>,\n): Promise<getBalance.ReturnValue> {\n  const { account: acc = client.account, token, ...rest } = parameters\n  const address = acc ? parseAccount(acc).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...rest,\n    ...getBalance.call({ account: address, token }),\n  })\n}\n\nexport namespace getBalance {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account> & Args\n\n  export type Args = {\n    /** Address of the account. */\n    account: Address\n    /** Address of the token. */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinExchange,\n    'balanceOf',\n    never\n  >\n\n  /**\n   * Defines a call to the `balanceOf` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      args: [account, token],\n      functionName: 'balanceOf',\n    })\n  }\n}\n\n/**\n * Gets the quote for buying a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const amountIn = await Actions.dex.getBuyQuote(client, {\n *   amountOut: parseUnits('100', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The amount of tokenIn needed to buy the specified amountOut.\n */\nexport async function getBuyQuote<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getBuyQuote.Parameters,\n): Promise<getBuyQuote.ReturnValue> {\n  const { tokenIn, tokenOut, amountOut, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getBuyQuote.call({ tokenIn, tokenOut, amountOut }),\n  })\n}\n\nexport namespace getBuyQuote {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Amount of tokenOut to buy. */\n    amountOut: bigint\n    /** Address of the token to spend. */\n    tokenIn: Address\n    /** Address of the token to buy. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinExchange,\n    'quoteSwapExactAmountOut',\n    never\n  >\n\n  /**\n   * Defines a call to the `quoteSwapExactAmountOut` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountOut } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      args: [tokenIn, tokenOut, amountOut],\n      functionName: 'quoteSwapExactAmountOut',\n    })\n  }\n}\n\n/**\n * Gets an order's details from the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const order = await Actions.dex.getOrder(client, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The order details.\n */\nexport async function getOrder<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getOrder.Parameters,\n): Promise<getOrder.ReturnValue> {\n  const { orderId, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getOrder.call({ orderId }),\n  })\n}\n\nexport namespace getOrder {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Order ID to query. */\n    orderId: bigint\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinExchange,\n    'getOrder',\n    never\n  >\n\n  /**\n   * Defines a call to the `getOrder` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { orderId } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      args: [orderId],\n      functionName: 'getOrder',\n    })\n  }\n}\n\n/**\n * Gets orderbook information for a trading pair.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const book = await Actions.dex.getOrderbook(client, {\n *   base: '0x20c...11',\n *   quote: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The orderbook information.\n */\nexport async function getOrderbook<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getOrderbook.Parameters,\n): Promise<getOrderbook.ReturnValue> {\n  const { base, quote, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getOrderbook.call({ base, quote }),\n  })\n}\n\nexport namespace getOrderbook {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Address of the base token. */\n    base: Address\n    /** Address of the quote token. */\n    quote: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinExchange,\n    'books',\n    never\n  >\n\n  /**\n   * Defines a call to the `books` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { base, quote } = args\n    const pairKey = getPairKey(base, quote)\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      args: [pairKey],\n      functionName: 'books',\n    })\n  }\n}\n\n/**\n * Gets the price level information at a specific tick.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions, Tick } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const level = await Actions.dex.getTickLevel(client, {\n *   base: '0x20c...11',\n *   tick: Tick.fromPrice('1.001'),\n *   isBid: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The price level information.\n */\nexport async function getTickLevel<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getTickLevel.Parameters,\n): Promise<getTickLevel.ReturnValue> {\n  const { base, tick, isBid, ...rest } = parameters\n  const [head, tail, totalLiquidity] = await readContract(client, {\n    ...rest,\n    ...getTickLevel.call({ base, tick, isBid }),\n  })\n  return { head, tail, totalLiquidity }\n}\n\nexport namespace getTickLevel {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Address of the base token. */\n    base: Address\n    /** Whether to query the bid side (true) or ask side (false). */\n    isBid: boolean\n    /** Price tick to query. */\n    tick: number\n  }\n\n  export type ReturnValue = {\n    /** Order ID of the first order at this tick (0 if empty) */\n    head: bigint\n    /** Order ID of the last order at this tick (0 if empty) */\n    tail: bigint\n    /** Total liquidity available at this tick level */\n    totalLiquidity: bigint\n  }\n\n  /**\n   * Defines a call to the `getTickLevel` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { base, tick, isBid } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      args: [base, tick, isBid],\n      functionName: 'getTickLevel',\n    })\n  }\n}\n\n/**\n * Gets the quote for selling a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const amountOut = await Actions.dex.getSellQuote(client, {\n *   amountIn: parseUnits('100', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The amount of tokenOut received for selling the specified amountIn.\n */\nexport async function getSellQuote<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getSellQuote.Parameters,\n): Promise<getSellQuote.ReturnValue> {\n  const { tokenIn, tokenOut, amountIn, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getSellQuote.call({ tokenIn, tokenOut, amountIn }),\n  })\n}\n\nexport namespace getSellQuote {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Amount of tokenIn to sell. */\n    amountIn: bigint\n    /** Address of the token to sell. */\n    tokenIn: Address\n    /** Address of the token to receive. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.stablecoinExchange,\n    'quoteSwapExactAmountIn',\n    never\n  >\n\n  /**\n   * Defines a call to the `quoteSwapExactAmountIn` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountIn } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      args: [tokenIn, tokenOut, amountIn],\n      functionName: 'quoteSwapExactAmountIn',\n    })\n  }\n}\n\n/**\n * Places a limit order on the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions, Tick } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.place(client, {\n *   amount: parseUnits('100', 6),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function place<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: place.Parameters<chain, account>,\n): Promise<place.ReturnValue> {\n  return place.inner(writeContract, client, parameters)\n}\n\nexport namespace place {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to place in the order. */\n    amount: bigint\n    /** Price tick for the order. */\n    tick: number\n    /** Address of the base token. */\n    token: Address\n    /** Order type - 'buy' to buy the token, 'sell' to sell it. */\n    type: OrderType\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: place.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, token, type, tick, ...rest } = parameters\n    const call = place.call({ amount, token, type, tick })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `place` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions, Tick } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.place.call({\n   *       amount: parseUnits('100', 6),\n   *       tick: Tick.fromPrice('0.99'),\n   *       token: '0x20c0...beef',\n   *       type: 'buy',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, amount, type, tick } = args\n    const isBid = type === 'buy'\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'place',\n      args: [token, amount, isBid, tick],\n    })\n  }\n\n  /**\n   * Extracts the `OrderPlaced` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `OrderPlaced` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinExchange,\n      logs,\n      eventName: 'OrderPlaced',\n      strict: true,\n    })\n    if (!log) throw new Error('`OrderPlaced` event not found.')\n    return log\n  }\n}\n\n/**\n * Places a flip order that automatically flips when filled.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions, Tick } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.placeFlip(client, {\n *   amount: parseUnits('100', 6),\n *   flipTick: Tick.fromPrice('1.01'),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function placeFlip<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: placeFlip.Parameters<chain, account>,\n): Promise<placeFlip.ReturnValue> {\n  return placeFlip.inner(writeContract, client, parameters)\n}\n\nexport namespace placeFlip {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to place in the order. */\n    amount: bigint\n    /** Target tick to flip to when order is filled. */\n    flipTick: number\n    /** Price tick for the order. */\n    tick: number\n    /** Address of the base token. */\n    token: Address\n    /** Order type - 'buy' to buy the token, 'sell' to sell it. */\n    type: OrderType\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: placeFlip.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, flipTick, tick, token, type, ...rest } = parameters\n    const call = placeFlip.call({ amount, flipTick, tick, token, type })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `placeFlip` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions, Tick } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.placeFlip.call({\n   *       amount: parseUnits('100', 6),\n   *       flipTick: Tick.fromPrice('1.01'),\n   *       tick: Tick.fromPrice('0.99'),\n   *       token: '0x20c0...beef',\n   *       type: 'buy',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, amount, type, tick, flipTick } = args\n    const isBid = type === 'buy'\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'placeFlip',\n      args: [token, amount, isBid, tick, flipTick],\n    })\n  }\n\n  /**\n   * Extracts the `FlipOrderPlaced` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `FlipOrderPlaced` event.\n   */\n  export function extractEvent(logs: viem_Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.stablecoinExchange,\n      logs,\n      eventName: 'FlipOrderPlaced',\n      strict: true,\n    })\n    if (!log) throw new Error('`FlipOrderPlaced` event not found.')\n    return log\n  }\n}\n\n/**\n * Places a flip order that automatically flips when filled.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions, Tick } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.placeFlipSync(client, {\n *   amount: parseUnits('100', 6),\n *   flipTick: Tick.fromPrice('1.01'),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function placeFlipSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: placeFlipSync.Parameters<chain, account>,\n): Promise<placeFlipSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await placeFlip.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = placeFlip.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace placeFlipSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = placeFlip.Parameters<chain, account>\n\n  export type Args = placeFlip.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinExchange,\n      'FlipOrderPlaced',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Places a limit order on the orderbook.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions, Tick } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.placeSync(client, {\n *   amount: parseUnits('100', 6),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function placeSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: placeSync.Parameters<chain, account>,\n): Promise<placeSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await place.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = place.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace placeSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = place.Parameters<chain, account>\n\n  export type Args = place.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.stablecoinExchange,\n      'OrderPlaced',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sells a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.sell(client, {\n *   amountIn: parseUnits('100', 6),\n *   minAmountOut: parseUnits('95', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function sell<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: sell.Parameters<chain, account>,\n): Promise<sell.ReturnValue> {\n  return sell.inner(writeContract, client, parameters)\n}\n\nexport namespace sell {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokenIn to sell. */\n    amountIn: bigint\n    /** Minimum amount of tokenOut to receive. */\n    minAmountOut: bigint\n    /** Address of the token to sell. */\n    tokenIn: Address\n    /** Address of the token to receive. */\n    tokenOut: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: sell.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { tokenIn, tokenOut, amountIn, minAmountOut, ...rest } = parameters\n    const call = sell.call({ tokenIn, tokenOut, amountIn, minAmountOut })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `swapExactAmountIn` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.sell.call({\n   *       amountIn: parseUnits('100', 6),\n   *       minAmountOut: parseUnits('95', 6),\n   *       tokenIn: '0x20c0...beef',\n   *       tokenOut: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { tokenIn, tokenOut, amountIn, minAmountOut } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'swapExactAmountIn',\n      args: [tokenIn, tokenOut, amountIn, minAmountOut],\n    })\n  }\n}\n\n/**\n * Sells a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createClient, http, parseUnits } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.sellSync(client, {\n *   amountIn: parseUnits('100', 6),\n *   minAmountOut: parseUnits('95', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function sellSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: sellSync.Parameters<chain, account>,\n): Promise<sellSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await sell.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace sellSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = sell.Parameters<chain, account>\n\n  export type Args = sell.Args\n\n  export type ReturnValue = Compute<{\n    /** Transaction receipt. */\n    receipt: TransactionReceipt\n  }>\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for flip order placed events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchFlipOrderPlaced(client, {\n *   onFlipOrderPlaced: (args, log) => {\n *     console.log('Flip order placed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchFlipOrderPlaced<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchFlipOrderPlaced.Parameters,\n) {\n  const { onFlipOrderPlaced, maker, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinExchange,\n    abi: Abis.stablecoinExchange,\n    eventName: 'FlipOrderPlaced',\n    args: {\n      ...(maker !== undefined && { maker }),\n      ...(token !== undefined && { token }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) onFlipOrderPlaced(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchFlipOrderPlaced {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinExchange,\n    'FlipOrderPlaced',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinExchange, 'FlipOrderPlaced'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinExchange,\n      'FlipOrderPlaced',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Address of the maker to filter events. */\n    maker?: Address | undefined\n    /** Callback to invoke when a flip order is placed. */\n    onFlipOrderPlaced: (args: Args, log: Log) => void\n    /** Address of the token to filter events. */\n    token?: Address | undefined\n  }\n}\n\n/**\n * Watches for order cancelled events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchOrderCancelled(client, {\n *   onOrderCancelled: (args, log) => {\n *     console.log('Order cancelled:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderCancelled<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchOrderCancelled.Parameters,\n) {\n  const { onOrderCancelled, orderId, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinExchange,\n    abi: Abis.stablecoinExchange,\n    eventName: 'OrderCancelled',\n    args: orderId !== undefined ? { orderId } : undefined,\n    onLogs: (logs) => {\n      for (const log of logs) onOrderCancelled(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchOrderCancelled {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinExchange,\n    'OrderCancelled',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinExchange, 'OrderCancelled'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinExchange,\n      'OrderCancelled',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when an order is cancelled. */\n    onOrderCancelled: (args: Args, log: Log) => void\n    /** Order ID to filter events. */\n    orderId?: bigint | undefined\n  }\n}\n\n/**\n * Watches for order filled events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchOrderFilled(client, {\n *   onOrderFilled: (args, log) => {\n *     console.log('Order filled:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderFilled<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchOrderFilled.Parameters,\n) {\n  const { onOrderFilled, maker, taker, orderId, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinExchange,\n    abi: Abis.stablecoinExchange,\n    eventName: 'OrderFilled',\n    args: {\n      ...(orderId !== undefined && { orderId }),\n      ...(maker !== undefined && { maker }),\n      ...(taker !== undefined && { taker }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) onOrderFilled(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchOrderFilled {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinExchange,\n    'OrderFilled',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinExchange, 'OrderFilled'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinExchange,\n      'OrderFilled',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Address of the maker to filter events. */\n    maker?: Address | undefined\n    /** Callback to invoke when an order is filled. */\n    onOrderFilled: (args: Args, log: Log) => void\n    /** Order ID to filter events. */\n    orderId?: bigint | undefined\n    /** Address of the taker to filter events. */\n    taker?: Address | undefined\n  }\n}\n\n/**\n * Watches for order placed events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.dex.watchOrderPlaced(client, {\n *   onOrderPlaced: (args, log) => {\n *     console.log('Order placed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderPlaced<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchOrderPlaced.Parameters,\n) {\n  const { onOrderPlaced, maker, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.stablecoinExchange,\n    abi: Abis.stablecoinExchange,\n    eventName: 'OrderPlaced',\n    args: {\n      ...(maker !== undefined && { maker }),\n      ...(token !== undefined && { token }),\n    },\n    onLogs: (logs) => {\n      for (const log of logs) onOrderPlaced(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchOrderPlaced {\n  export type Args = GetEventArgs<\n    typeof Abis.stablecoinExchange,\n    'OrderPlaced',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.stablecoinExchange, 'OrderPlaced'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.stablecoinExchange,\n      'OrderPlaced',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Address of the maker to filter events. */\n    maker?: Address | undefined\n    /** Callback to invoke when an order is placed. */\n    onOrderPlaced: (args: Args, log: Log) => void\n    /** Address of the token to filter events. */\n    token?: Address | undefined\n  }\n}\n\n/**\n * Withdraws tokens from the DEX to the caller's wallet.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.dex.withdraw(client, {\n *   amount: 100n,\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function withdraw<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: withdraw.Parameters<chain, account>,\n): Promise<withdraw.ReturnValue> {\n  return withdraw.inner(writeContract, client, parameters)\n}\n\nexport namespace withdraw {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount to withdraw. */\n    amount: bigint\n    /** Address of the token to withdraw. */\n    token: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: withdraw.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, amount, ...rest } = parameters\n    const call = withdraw.call({ token, amount })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `withdraw` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, parseUnits, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     Actions.dex.withdraw.call({\n   *       amount: parseUnits('100', 6),\n   *       token: '0x20c0...beef',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, amount } = args\n    return defineCall({\n      address: Addresses.stablecoinExchange,\n      abi: Abis.stablecoinExchange,\n      functionName: 'withdraw',\n      args: [token, amount],\n    })\n  }\n}\n\n/**\n * Withdraws tokens from the DEX to the caller's wallet.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.dex.withdrawSync(client, {\n *   amount: 100n,\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function withdrawSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: withdrawSync.Parameters<chain, account>,\n): Promise<withdrawSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await withdraw.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return { receipt }\n}\n\nexport namespace withdrawSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = withdraw.Parameters<chain, account>\n\n  export type Args = withdraw.Args\n\n  export type ReturnValue = Compute<{\n    /** Transaction receipt. */\n    receipt: TransactionReceipt\n  }>\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\nfunction getPairKey(base: Address, quote: Address) {\n  const [tokenA, tokenB] =\n    Hex.toBigInt(base) < Hex.toBigInt(quote) ? [base, quote] : [quote, base]\n  return Hash.keccak256(Hex.concat(tokenA, tokenB))\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { waitForTransactionReceipt } from '../../actions/public/waitForTransactionReceipt.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Funds an account with an initial amount of set token(s)\n * on Tempo's testnet.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hashes = await Actions.faucet.fund(client, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function fund<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: fund.Parameters,\n): Promise<fund.ReturnValue> {\n  const account = parseAccount(parameters.account)\n  return client.request<{\n    Method: 'tempo_fundAddress'\n    Parameters: [address: Address]\n    ReturnType: readonly Hash[]\n  }>({\n    method: 'tempo_fundAddress',\n    params: [account.address],\n  })\n}\n\nexport declare namespace fund {\n  export type Parameters = {\n    /** Account to fund. */\n    account: Account | Address\n  }\n\n  export type ReturnValue = readonly Hash[]\n}\n\n/**\n * Funds an account with an initial amount of set token(s)\n * on Tempo's testnet. Waits for the transactions to be included\n * on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const hashes = await Actions.faucet.fundSync(client, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function fundSync<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: fundSync.Parameters,\n): Promise<fundSync.ReturnValue> {\n  const { timeout = 10_000 } = parameters\n  const account = parseAccount(parameters.account)\n  const hashes = await client.request<{\n    Method: 'tempo_fundAddress'\n    Parameters: [address: Address]\n    ReturnType: readonly Hash[]\n  }>({\n    method: 'tempo_fundAddress',\n    params: [account.address],\n  })\n  const receipts = await Promise.all(\n    hashes.map((hash) =>\n      waitForTransactionReceipt(client, {\n        hash,\n        checkReplacement: false,\n        timeout,\n      }),\n    ),\n  )\n  return receipts\n}\n\nexport declare namespace fundSync {\n  export type Parameters = {\n    /** Account to fund. */\n    account: Account | Address\n    /** Timeout. */\n    timeout?: number | undefined\n  }\n\n  export type ReturnValue = readonly TransactionReceipt[]\n}\n", "import type { Address } from 'abitype'\nimport { TokenId } from 'ox/tempo'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { zeroAddress } from '../../constants/address.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Compute, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type {\n  GetAccountParameter,\n  ReadParameters,\n  WriteParameters,\n} from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Gets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { address, id } = await Actions.fee.getUserToken(client)\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function getUserToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  ...parameters: account extends Account\n    ? [getUserToken.Parameters<account>] | []\n    : [getUserToken.Parameters<account>]\n): Promise<getUserToken.ReturnValue> {\n  const { account: account_ = client.account, ...rest } = parameters[0] ?? {}\n  if (!account_) throw new Error('account is required.')\n  const account = parseAccount(account_)\n  const address = await readContract(client, {\n    ...rest,\n    ...getUserToken.call({ account: account.address }),\n  })\n  if (address === zeroAddress) return null\n  return {\n    address,\n    id: TokenId.fromAddress(address),\n  }\n}\n\nexport namespace getUserToken {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account>\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n  }\n\n  export type ReturnValue = Compute<{\n    address: Address\n    id: bigint\n  } | null>\n\n  /**\n   * Defines a call to the `userTokens` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeManager,\n      args: [account],\n      functionName: 'userTokens',\n    })\n  }\n}\n\n/**\n * Sets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.fee.setUserToken(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setUserToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setUserToken.Parameters<chain, account>,\n): Promise<setUserToken.ReturnValue> {\n  return setUserToken.inner(writeContract, client, parameters)\n}\n\nexport namespace setUserToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setUserToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = setUserToken.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setUserToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.fee.setUserToken.call({\n   *       token: '0x20c0...beef',\n   *     }),\n   *     actions.fee.setUserToken.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: Addresses.feeManager,\n      abi: Abis.feeManager,\n      functionName: 'setUserToken',\n      args: [TokenId.toAddress(token)],\n    })\n  }\n\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.feeManager,\n      logs,\n      eventName: 'UserTokenSet',\n      strict: true,\n    })\n    if (!log) throw new Error('`UserTokenSet` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.fee.setUserTokenSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setUserTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setUserTokenSync.Parameters<chain, account>,\n): Promise<setUserTokenSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setUserToken.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setUserToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setUserTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setUserToken.Parameters<chain, account>\n\n  export type Args = setUserToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.feeManager,\n      'UserTokenSet',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for user token set events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.fee.watchSetUserToken(client, {\n *   onUserTokenSet: (args, log) => {\n *     console.log('User token set:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchSetUserToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchSetUserToken.Parameters,\n) {\n  const { onUserTokenSet, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.feeManager,\n    abi: Abis.feeManager,\n    eventName: 'UserTokenSet',\n    onLogs: (logs) => {\n      for (const log of logs) onUserTokenSet(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchSetUserToken {\n  export type Args = GetEventArgs<\n    typeof Abis.feeManager,\n    'UserTokenSet',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.feeManager, 'UserTokenSet'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.feeManager, 'UserTokenSet', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a user token is set. */\n    onUserTokenSet: (args: Args, log: Log) => void\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log as viem_Log } from '../../types/log.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Gets the nonce for an account and nonce key.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const nonce = await Actions.nonce.getNonce(client, {\n *   account: '0x...',\n *   nonceKey: 1n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The nonce value.\n */\nexport async function getNonce<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getNonce.Parameters,\n): Promise<getNonce.ReturnValue> {\n  const { account, nonceKey, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getNonce.call({ account, nonceKey }),\n  })\n}\n\nexport namespace getNonce {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n    /** Nonce key (must be > 0, key 0 is reserved for protocol nonces). */\n    nonceKey: bigint\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.nonce,\n    'getNonce',\n    never\n  >\n\n  /**\n   * Defines a call to the `getNonce` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [\n   *     Actions.nonce.getNonce.call({ account: '0x...', nonceKey: 1n }),\n   *     Actions.nonce.getNonce.call({ account: '0x...', nonceKey: 2n }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, nonceKey } = args\n    return defineCall({\n      address: Addresses.nonceManager,\n      abi: Abis.nonce,\n      args: [account, nonceKey],\n      functionName: 'getNonce',\n    })\n  }\n}\n\n/**\n * @deprecated This function has been deprecated post-AllegroModerato. It will be removed in a future version.\n */\nexport async function getNonceKeyCount<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getNonceKeyCount.Parameters,\n): Promise<getNonceKeyCount.ReturnValue> {\n  const { account, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...getNonceKeyCount.call({ account }),\n  })\n}\n\nexport namespace getNonceKeyCount {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.nonce,\n    'getActiveNonceKeyCount',\n    never\n  >\n\n  /**\n   * Defines a call to the `getNonceKeyCount` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`multicall`](https://viem.sh/docs/contract/multicall): execute multiple calls in parallel\n   *\n   * @example\n   * ```ts\n   * import { createClient, http } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.multicall({\n   *   contracts: [\n   *     Actions.nonce.getNonceKeyCount.call({ account: '0x...' }),\n   *     Actions.nonce.getNonceKeyCount.call({ account: '0x...' }),\n   *   ],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account } = args\n    return defineCall({\n      address: Addresses.nonceManager,\n      abi: Abis.nonce,\n      args: [account],\n      functionName: 'getActiveNonceKeyCount',\n    })\n  }\n}\n\n/**\n * @deprecated This function has been deprecated post-AllegroModerato. It will be removed in a future version.\n */\nexport function watchNonceIncremented<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchNonceIncremented.Parameters,\n) {\n  const { onNonceIncremented, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.nonceManager,\n    abi: Abis.nonce,\n    eventName: 'NonceIncremented',\n    onLogs: (logs) => {\n      for (const log of logs) onNonceIncremented(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchNonceIncremented {\n  export type Args = GetEventArgs<\n    typeof Abis.nonce,\n    'NonceIncremented',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.nonce, 'NonceIncremented'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.nonce, 'NonceIncremented', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a nonce is incremented. */\n    onNonceIncremented: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for active key count changed events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' }),\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.nonce.watchActiveKeyCountChanged(client, {\n *   onActiveKeyCountChanged: (args, log) => {\n *     console.log('Active key count changed:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchActiveKeyCountChanged<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchActiveKeyCountChanged.Parameters,\n) {\n  const { onActiveKeyCountChanged, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.nonceManager,\n    abi: Abis.nonce,\n    eventName: 'ActiveKeyCountChanged',\n    onLogs: (logs) => {\n      for (const log of logs) onActiveKeyCountChanged(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchActiveKeyCountChanged {\n  export type Args = GetEventArgs<\n    typeof Abis.nonce,\n    'ActiveKeyCountChanged',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.nonce, 'ActiveKeyCountChanged'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.nonce,\n      'ActiveKeyCountChanged',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when the active key count changes. */\n    onActiveKeyCountChanged: (args: Args, log: Log) => void\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { WatchContractEventParameters } from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Compute, UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\nexport type PolicyType = 'whitelist' | 'blacklist'\n\nconst policyTypeMap = {\n  whitelist: 0,\n  blacklist: 1,\n} as const\n\n/**\n * Creates a new policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { hash, policyId } = await Actions.policy.create(client, {\n *   admin: '0x...',\n *   type: 'whitelist',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash and policy ID.\n */\nexport async function create<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: create.Parameters<chain, account>,\n): Promise<create.ReturnValue> {\n  return create.inner(writeContract, client, parameters)\n}\n\nexport namespace create {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'admin'> & {\n      /** Address of the policy admin. */\n      admin?: Address | undefined\n    }\n\n  export type Args = {\n    /** Optional array of accounts to initialize the policy with. */\n    addresses?: readonly Address[] | undefined\n    /** Address of the policy admin. */\n    admin: Address\n    /** Type of policy to create. */\n    type: PolicyType\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const {\n      account = client.account,\n      addresses,\n      chain = client.chain,\n      type,\n      ...rest\n    } = parameters\n\n    if (!account) throw new Error('`account` is required')\n\n    const admin = parseAccount(account).address!\n\n    const call = create.call({ admin, type, addresses })\n    return action(client, {\n      ...rest,\n      account,\n      chain,\n      ...call,\n    } as never) as never\n  }\n\n  /**\n   * Defines a call to the `createPolicy` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.create.call({\n   *       admin: '0xfeed...fede',\n   *       type: 'whitelist',\n   *     }),\n   *     actions.policy.create.call({\n   *       admin: '0xfeed...fede',\n   *       type: 'blacklist',\n   *       addresses: ['0x20c0...beef', '0x20c0...babe'],\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { admin, type, addresses } = args\n    const config = (() => {\n      if (addresses)\n        return {\n          functionName: 'createPolicyWithAccounts',\n          args: [admin, policyTypeMap[type], addresses],\n        } as const\n      return {\n        functionName: 'createPolicy',\n        args: [admin, policyTypeMap[type]],\n      } as const\n    })()\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      ...config,\n    })\n  }\n\n  /**\n   * Extracts the `PolicyCreated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `PolicyCreated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'PolicyCreated',\n      strict: true,\n    })\n    if (!log) throw new Error('`PolicyCreated` event not found.')\n    return log\n  }\n}\n\n/**\n * Creates a new policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.createSync(client, {\n *   admin: '0x...',\n *   type: 'whitelist',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createSync.Parameters<chain, account>,\n): Promise<createSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await create.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = create.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace createSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = create.Parameters<chain, account>\n\n  export type Args = create.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'PolicyCreated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sets the admin for a policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.policy.setAdmin(client, {\n *   policyId: 2n,\n *   admin: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setAdmin<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setAdmin.Parameters<chain, account>,\n): Promise<setAdmin.ReturnValue> {\n  return setAdmin.inner(writeContract, client, parameters)\n}\n\nexport namespace setAdmin {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New admin address. */\n    admin: Address\n    /** Policy ID. */\n    policyId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setAdmin.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { policyId, admin, ...rest } = parameters\n    const call = setAdmin.call({ policyId, admin })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setPolicyAdmin` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.setAdmin.call({\n   *       policyId: 2n,\n   *       admin: '0xfeed...fede',\n   *     }),\n   *     actions.policy.setAdmin.call({\n   *       policyId: 3n,\n   *       admin: '0xfeed...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, admin } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      functionName: 'setPolicyAdmin',\n      args: [policyId, admin],\n    })\n  }\n\n  /**\n   * Extracts the `PolicyAdminUpdated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `PolicyAdminUpdated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'PolicyAdminUpdated',\n      strict: true,\n    })\n    if (!log) throw new Error('`PolicyAdminUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the admin for a policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.setAdminSync(client, {\n *   policyId: 2n,\n *   admin: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setAdminSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setAdminSync.Parameters<chain, account>,\n): Promise<setAdminSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setAdmin.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setAdmin.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setAdminSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setAdmin.Parameters<chain, account>\n\n  export type Args = setAdmin.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'PolicyAdminUpdated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Modifies a policy whitelist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.policy.modifyWhitelist(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   allowed: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function modifyWhitelist<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyWhitelist.Parameters<chain, account>,\n): Promise<modifyWhitelist.ReturnValue> {\n  return modifyWhitelist.inner(writeContract, client, parameters)\n}\n\nexport namespace modifyWhitelist {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Target account address. */\n    address: Address\n    /** Whether the account is allowed. */\n    allowed: boolean\n    /** Policy ID. */\n    policyId: bigint\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: modifyWhitelist.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { address: targetAccount, allowed, policyId, ...rest } = parameters\n    const call = modifyWhitelist.call({\n      address: targetAccount,\n      allowed,\n      policyId,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `modifyPolicyWhitelist` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.modifyWhitelist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...beef',\n   *       allowed: true,\n   *     }),\n   *     actions.policy.modifyWhitelist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...babe',\n   *       allowed: false,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, address, allowed } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      functionName: 'modifyPolicyWhitelist',\n      args: [policyId, address, allowed],\n    })\n  }\n\n  /**\n   * Extracts the `WhitelistUpdated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `WhitelistUpdated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'WhitelistUpdated',\n      strict: true,\n    })\n    if (!log) throw new Error('`WhitelistUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Modifies a policy whitelist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.modifyWhitelistSync(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   allowed: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function modifyWhitelistSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyWhitelistSync.Parameters<chain, account>,\n): Promise<modifyWhitelistSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await modifyWhitelist.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = modifyWhitelist.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace modifyWhitelistSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = modifyWhitelist.Parameters<chain, account>\n\n  export type Args = modifyWhitelist.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'WhitelistUpdated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Modifies a policy blacklist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.policy.modifyBlacklist(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   restricted: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function modifyBlacklist<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyBlacklist.Parameters<chain, account>,\n): Promise<modifyBlacklist.ReturnValue> {\n  return modifyBlacklist.inner(writeContract, client, parameters)\n}\n\nexport namespace modifyBlacklist {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Target account address. */\n    address: Address\n    /** Policy ID. */\n    policyId: bigint\n    /** Whether the account is restricted. */\n    restricted: boolean\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: modifyBlacklist.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { address: targetAccount, policyId, restricted, ...rest } = parameters\n    const call = modifyBlacklist.call({\n      address: targetAccount,\n      policyId,\n      restricted,\n    })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `modifyPolicyBlacklist` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.policy.modifyBlacklist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...beef',\n   *       restricted: true,\n   *     }),\n   *     actions.policy.modifyBlacklist.call({\n   *       policyId: 2n,\n   *       address: '0x20c0...babe',\n   *       restricted: false,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, address, restricted } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      functionName: 'modifyPolicyBlacklist',\n      args: [policyId, address, restricted],\n    })\n  }\n\n  /**\n   * Extracts the `BlacklistUpdated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `BlacklistUpdated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip403Registry,\n      logs,\n      eventName: 'BlacklistUpdated',\n      strict: true,\n    })\n    if (!log) throw new Error('`BlacklistUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Modifies a policy blacklist.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.policy.modifyBlacklistSync(client, {\n *   policyId: 2n,\n *   account: '0x...',\n *   restricted: true,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function modifyBlacklistSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: modifyBlacklistSync.Parameters<chain, account>,\n): Promise<modifyBlacklistSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await modifyBlacklist.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = modifyBlacklist.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace modifyBlacklistSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = modifyBlacklist.Parameters<chain, account>\n\n  export type Args = modifyBlacklist.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip403Registry,\n      'BlacklistUpdated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Gets policy data.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const data = await Actions.policy.getData(client, {\n *   policyId: 2n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The policy data.\n */\nexport async function getData<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getData.Parameters,\n): Promise<getData.ReturnValue> {\n  const { policyId, ...rest } = parameters\n  const result = await readContract(client, {\n    ...rest,\n    ...getData.call({ policyId }),\n  })\n  return {\n    admin: result[1],\n    type: result[0] === 0 ? 'whitelist' : 'blacklist',\n  }\n}\n\nexport namespace getData {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Policy ID. */\n    policyId: bigint\n  }\n\n  export type ReturnValue = Compute<{\n    /** Admin address. */\n    admin: Address\n    /** Policy type. */\n    type: PolicyType\n  }>\n\n  /**\n   * Defines a call to the `policyData` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      args: [policyId],\n      functionName: 'policyData',\n    })\n  }\n}\n\n/**\n * Checks if a user is authorized by a policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const authorized = await Actions.policy.isAuthorized(client, {\n *   policyId: 2n,\n *   user: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Whether the user is authorized.\n */\nexport async function isAuthorized<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: isAuthorized.Parameters,\n): Promise<isAuthorized.ReturnValue> {\n  const { policyId, user, ...rest } = parameters\n  return readContract(client, {\n    ...rest,\n    ...isAuthorized.call({ policyId, user }),\n  })\n}\n\nexport namespace isAuthorized {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Policy ID. */\n    policyId: bigint\n    /** User address to check. */\n    user: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip403Registry,\n    'isAuthorized',\n    never\n  >\n\n  /**\n   * Defines a call to the `isAuthorized` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { policyId, user } = args\n    return defineCall({\n      address: Addresses.tip403Registry,\n      abi: Abis.tip403Registry,\n      args: [policyId, user],\n      functionName: 'isAuthorized',\n    })\n  }\n}\n\n/**\n * Watches for policy creation events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchCreate(client, {\n *   onPolicyCreated: (args, log) => {\n *     console.log('Policy created:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchCreate<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchCreate.Parameters,\n) {\n  const { onPolicyCreated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'PolicyCreated',\n    onLogs: (logs) => {\n      for (const log of logs)\n        onPolicyCreated(\n          {\n            ...log.args,\n            type: log.args.policyType === 0 ? 'whitelist' : 'blacklist',\n          },\n          log,\n        )\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchCreate {\n  export type Args = Compute<{\n    policyId: bigint\n    updater: Address\n    type: PolicyType\n  }>\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'PolicyCreated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'PolicyCreated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a policy is created. */\n    onPolicyCreated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for policy admin update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchAdminUpdated(client, {\n *   onAdminUpdated: (args, log) => {\n *     console.log('Policy admin updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchAdminUpdated<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchAdminUpdated.Parameters,\n) {\n  const { onAdminUpdated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'PolicyAdminUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onAdminUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchAdminUpdated {\n  export type Args = GetEventArgs<\n    typeof Abis.tip403Registry,\n    'PolicyAdminUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'PolicyAdminUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'PolicyAdminUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a policy admin is updated. */\n    onAdminUpdated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for whitelist update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchWhitelistUpdated(client, {\n *   onWhitelistUpdated: (args, log) => {\n *     console.log('Whitelist updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchWhitelistUpdated<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchWhitelistUpdated.Parameters,\n) {\n  const { onWhitelistUpdated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'WhitelistUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onWhitelistUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchWhitelistUpdated {\n  export type Args = GetEventArgs<\n    typeof Abis.tip403Registry,\n    'WhitelistUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'WhitelistUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'WhitelistUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a whitelist is updated. */\n    onWhitelistUpdated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for blacklist update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.policy.watchBlacklistUpdated(client, {\n *   onBlacklistUpdated: (args, log) => {\n *     console.log('Blacklist updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBlacklistUpdated<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchBlacklistUpdated.Parameters,\n) {\n  const { onBlacklistUpdated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip403Registry,\n    abi: Abis.tip403Registry,\n    eventName: 'BlacklistUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onBlacklistUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchBlacklistUpdated {\n  export type Args = GetEventArgs<\n    typeof Abis.tip403Registry,\n    'BlacklistUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip403Registry, 'BlacklistUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip403Registry,\n      'BlacklistUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a blacklist is updated. */\n    onBlacklistUpdated: (args: Args, log: Log) => void\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type {\n  WatchContractEventParameters,\n  WatchContractEventReturnType,\n} from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport type { ReadParameters, WriteParameters } from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\n\n/**\n * Claims accumulated rewards for a recipient.\n *\n * This function allows a reward recipient to claim their accumulated rewards\n * and receive them as token transfers to their own balance.\n *\n * - Accrues all pending rewards up to the current block timestamp.\n * - Updates the caller's reward accounting.\n * - Transfers the caller's accumulated `rewardBalance` from the token contract to the caller.\n * - If the contract's balance is insufficient, claims up to the available amount.\n * - Returns the actual amount claimed.\n *\n * Notes:\n * - Reverts with `Paused` if the token is paused.\n * - Reverts with `PolicyForbids` if the caller is not authorized to receive tokens under TIP-403.\n * - If opted in, the claimed amount is added back to `optedInSupply` since it goes to the recipient's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.reward.claim(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function claim<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: claim.Parameters<chain, account>,\n): Promise<claim.ReturnValue> {\n  return claim.inner(writeContract, client, parameters)\n}\n\nexport namespace claim {\n  export type Args = {\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = claim.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `claimRewards` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const hash = await client.sendTransaction({\n   *   calls: [actions.reward.claim.call({\n   *     token: '0x20c0000000000000000000000000000000000001',\n   *   })],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [],\n      functionName: 'claimRewards',\n    })\n  }\n}\n\n/**\n * Claims accumulated rewards for a recipient and waits for confirmation.\n *\n * This function allows a reward recipient to claim their accumulated rewards\n * and receive them as token transfers to their own balance.\n *\n * Behavior:\n * - Accrues all pending rewards up to the current block timestamp.\n * - Updates the caller's reward accounting.\n * - Transfers the caller's accumulated `rewardBalance` from the token contract to the caller.\n * - If the contract's balance is insufficient, claims up to the available amount.\n *\n * Notes:\n * - Reverts with `Paused` if the token is paused.\n * - Reverts with `PolicyForbids` if the caller is not authorized to receive tokens under TIP-403.\n * - If opted in, the claimed amount is added back to `optedInSupply` since it goes to the recipient's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { receipt } = await Actions.reward.claimSync(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The amount claimed and transaction receipt.\n */\nexport async function claimSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: claimSync.Parameters<chain, account>,\n): Promise<claimSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await claim.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  return {\n    receipt,\n  } as never\n}\n\nexport namespace claimSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & claim.Args\n\n  export type ReturnValue = {\n    /** The transaction receipt */\n    receipt: Awaited<ReturnType<typeof writeContractSync>>\n  }\n\n  export type ErrorType = claim.ErrorType\n}\n\n/**\n * Gets the total reward per second rate for all active streams.\n *\n * Returns the current aggregate per-second emission rate scaled by `ACC_PRECISION` (1e18).\n * This value represents the sum of all active reward streams' emission rates.\n * The rate decreases when streams end (via `finalizeStreams`) or are canceled.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const rate = await Actions.rewards.getTotalPerSecond(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The total reward per second (scaled by 1e18).\n */\nexport async function getTotalPerSecond<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getTotalPerSecond.Parameters,\n): Promise<getTotalPerSecond.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getTotalPerSecond.call(parameters),\n  })\n}\n\nexport namespace getTotalPerSecond {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'totalRewardPerSecond',\n    never\n  >\n\n  /**\n   * Defines a call to the `totalRewardPerSecond` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [],\n      functionName: 'totalRewardPerSecond',\n    })\n  }\n}\n\n/**\n * Gets the reward information for a specific account.\n *\n * Returns the reward recipient address, reward per token value, and accumulated reward balance for the specified account.\n * This information includes:\n * - `rewardRecipient`: The address designated to receive rewards (zero address if opted out)\n * - `rewardPerToken`: The reward per token value for this account\n * - `rewardBalance`: The accumulated reward balance waiting to be claimed\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const info = await Actions.reward.getUserRewardInfo(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The user's reward information (recipient, rewardPerToken, rewardBalance).\n */\nexport async function getUserRewardInfo<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getUserRewardInfo.Parameters,\n): Promise<getUserRewardInfo.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getUserRewardInfo.call(parameters),\n  })\n}\n\nexport namespace getUserRewardInfo {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** The account address to query reward info for */\n    account: Address\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'userRewardInfo',\n    never\n  >\n\n  /**\n   * Defines a call to the `userRewardInfo` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [account],\n      functionName: 'userRewardInfo',\n    })\n  }\n}\n\n/**\n * Sets or changes the reward recipient for a token holder.\n *\n * This function allows a token holder to designate who should receive their share of rewards:\n * - If `recipient` is the zero address, opts out from rewards distribution.\n * - Otherwise, opts in and sets `recipient` as the address that will receive accrued rewards.\n * - Can be called with `recipient == msg.sender` to receive rewards directly.\n * - Automatically distributes any accrued rewards to the current recipient before changing.\n *\n * TIP-403 Policy:\n * - Reverts with `PolicyForbids` if `recipient` is not the zero address and either the holder or recipient is not authorized to receive tokens under the token's transfer policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.rewards.setRecipient(client, {\n *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setRecipient<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRecipient.Parameters<chain, account>,\n): Promise<setRecipient.ReturnValue> {\n  return setRecipient.inner(writeContract, client, parameters)\n}\n\n/**\n * Sets or changes the reward recipient for a token holder and waits for confirmation.\n *\n * This function allows a token holder to designate who should receive their share of rewards:\n * - If `recipient` is the zero address, opts out from rewards distribution.\n * - Otherwise, opts in and sets `recipient` as the address that will receive accrued rewards.\n * - Can be called with `recipient == msg.sender` to receive rewards directly.\n * - Automatically distributes any accrued rewards to the current recipient before changing.\n *\n * TIP-403 Policy:\n * - Reverts with `PolicyForbids` if `recipient` is not the zero address and either the holder or recipient is not authorized to receive tokens under the token's transfer policy.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { holder, recipient, receipt } = await Actions.rewards.setRecipientSync(client, {\n *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The holder, recipient, and transaction receipt.\n */\nexport async function setRecipientSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRecipientSync.Parameters<chain, account>,\n): Promise<setRecipientSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setRecipient.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setRecipient.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setRecipient {\n  export type Args = {\n    /** The reward recipient address (use zero address to opt out of rewards) */\n    recipient: Address\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { recipient, token, ...rest } = parameters\n    const call = setRecipient.call({ recipient, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setRecipient` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const hash = await client.sendTransaction({\n   *   calls: [actions.rewards.setRecipient.call({\n   *     recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n   *     token: '0x20c0000000000000000000000000000000000001',\n   *   })],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { recipient, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [recipient],\n      functionName: 'setRewardRecipient',\n    })\n  }\n\n  /**\n   * Extracts the `RewardRecipientSet` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `RewardRecipientSet` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RewardRecipientSet',\n      strict: true,\n    })\n    if (!log) throw new Error('`RewardRecipientSet` event not found.')\n    return log\n  }\n}\n\nexport declare namespace setRecipientSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & setRecipient.Args\n\n  export type ReturnValue = {\n    /** The token holder address who set their reward recipient */\n    holder: Address\n    /** The transaction receipt */\n    receipt: Awaited<ReturnType<typeof writeContractSync>>\n    /** The reward recipient address (zero address indicates opt-out) */\n    recipient: Address\n  }\n\n  export type ErrorType = setRecipient.ErrorType\n}\n\n/**\n * Starts a new reward stream that distributes tokens to opted-in holders.\n *\n * Behavior:\n * - Transfers `amount` of tokens from the caller into the token contract's reward pool.\n * - If `seconds == 0`: Immediately distributes `amount` to current opted-in holders by increasing `rewardPerTokenStored`.\n *   Returns stream ID `0`. Distribution occurs when holders interact with the token (transfers, etc.).\n * - If `seconds > 0`: Starts a linear stream that emits evenly from `block.timestamp` to `block.timestamp + seconds`.\n *   Returns a unique stream ID for later cancellation.\n *\n * Notes:\n * - Reverts with `InvalidAmount` if `amount == 0`.\n * - Allowed even when `optedInSupply == 0` (tokens distributed while no one is opted in are locked permanently).\n * - The transfer from caller to pool is subject to TIP-403 policy checks.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hash = await Actions.rewards.start(client, {\n *   amount: 100000000000000000000n,\n *   seconds: 86400,\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function start<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: start.Parameters<chain, account>,\n): Promise<start.ReturnValue> {\n  return start.inner(writeContract, client, parameters)\n}\n\n/**\n * Starts a new reward stream that distributes tokens to opted-in holders and waits for confirmation.\n *\n * Behavior:\n * - Transfers `amount` of tokens from the caller into the token contract's reward pool.\n * - If `seconds == 0`: Immediately distributes `amount` to current opted-in holders by increasing `rewardPerTokenStored`.\n *   Returns stream ID `0`. Distribution occurs when holders interact with the token (transfers, etc.).\n * - If `seconds > 0`: Starts a linear stream that emits evenly from `block.timestamp` to `block.timestamp + seconds`.\n *   Returns a unique stream ID for later cancellation.\n *\n * Notes:\n * - Reverts with `InvalidAmount` if `amount == 0`.\n * - Allowed even when `optedInSupply == 0` (tokens distributed while no one is opted in are locked permanently).\n * - The transfer from caller to pool is subject to TIP-403 policy checks.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const { id, receipt } = await Actions.rewards.startSync(client, {\n *   amount: 100000000000000000000n,\n *   seconds: 86400,\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The stream ID, funder, amount, duration, and transaction receipt.\n */\nexport async function startSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: startSync.Parameters<chain, account>,\n): Promise<startSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await start.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = start.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace start {\n  export type Args = {\n    /** The amount of tokens to distribute (must be > 0) */\n    amount: bigint\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, token, ...rest } = parameters\n    const call = start.call({ amount, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `start` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const hash = await client.sendTransaction({\n   *   calls: [actions.rewards.start.call({\n   *     amount: 100000000000000000000n,\n   *     seconds: 86400,\n   *     token: '0x20c0000000000000000000000000000000000001',\n   *   })],\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { amount, token } = args\n    return defineCall({\n      address: token,\n      abi: Abis.tip20,\n      args: [amount, 0],\n      functionName: 'startReward',\n    })\n  }\n\n  /**\n   * Extracts the `RewardScheduled` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `RewardScheduled` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RewardScheduled',\n      strict: true,\n    })\n    if (!log) throw new Error('`RewardScheduled` event not found.')\n    return log\n  }\n}\n\nexport declare namespace startSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & start.Args\n\n  export type ReturnValue = {\n    /** The total amount allocated to the stream */\n    amount: bigint\n    /** The duration of the stream in seconds (0 for immediate distributions) */\n    durationSeconds: number\n    /** The address that funded the stream */\n    funder: Address\n    /** The unique stream ID (0 for immediate distributions, >0 for streaming distributions) */\n    id: bigint\n    /** The transaction receipt */\n    receipt: Awaited<ReturnType<typeof writeContractSync>>\n  }\n\n  export type ErrorType = start.ErrorType\n}\n\n/**\n * Watches for reward scheduled events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.reward.watchRewardScheduled(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   onRewardScheduled: (args, log) => {\n *     console.log('Reward scheduled:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRewardScheduled<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchRewardScheduled.Parameters,\n) {\n  const { onRewardScheduled, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: token,\n    abi: Abis.tip20,\n    eventName: 'RewardScheduled',\n    onLogs: (logs) => {\n      for (const log of logs) onRewardScheduled(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRewardScheduled {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RewardScheduled',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RewardScheduled'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'RewardScheduled', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when rewards are scheduled. */\n    onRewardScheduled: (args: Args, log: Log) => void\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = WatchContractEventReturnType\n}\n\n/**\n * Watches for reward recipient set events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = Actions.reward.watchRewardRecipientSet(client, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   onRewardRecipientSet: (args, log) => {\n *     console.log('Reward recipient set:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRewardRecipientSet<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchRewardRecipientSet.Parameters,\n) {\n  const { onRewardRecipientSet, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: token,\n    abi: Abis.tip20,\n    eventName: 'RewardRecipientSet',\n    onLogs: (logs) => {\n      for (const log of logs) onRewardRecipientSet(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRewardRecipientSet {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RewardRecipientSet',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RewardRecipientSet'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'RewardRecipientSet', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a reward recipient is set. */\n    onRewardRecipientSet: (args: Args, log: Log) => void\n    /** The TIP20 token address */\n    token: Address\n  }\n\n  export type ReturnValue = WatchContractEventReturnType\n}\n", "import type { Address } from 'abitype'\nimport * as Hex from 'ox/Hex'\nimport { TokenId, TokenRole } from 'ox/tempo'\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { multicall } from '../../actions/public/multicall.js'\nimport type { ReadContractReturnType } from '../../actions/public/readContract.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type {\n  WatchContractEventParameters,\n  WatchContractEventReturnType,\n} from '../../actions/public/watchContractEvent.js'\nimport { watchContractEvent } from '../../actions/public/watchContractEvent.js'\nimport { sendTransaction } from '../../actions/wallet/sendTransaction.js'\nimport {\n  type SendTransactionSyncParameters,\n  sendTransactionSync,\n} from '../../actions/wallet/sendTransactionSync.js'\nimport type { WriteContractReturnType } from '../../actions/wallet/writeContract.js'\nimport { writeContract } from '../../actions/wallet/writeContract.js'\nimport { writeContractSync } from '../../actions/wallet/writeContractSync.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ExtractAbiItem, GetEventArgs } from '../../types/contract.js'\nimport type { Log, Log as viem_Log } from '../../types/log.js'\nimport type { Compute, OneOf, UnionOmit } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport * as Abis from '../Abis.js'\nimport * as Addresses from '../Addresses.js'\nimport type {\n  GetAccountParameter,\n  ReadParameters,\n  WriteParameters,\n} from '../internal/types.js'\nimport { defineCall } from '../internal/utils.js'\nimport type { TransactionReceipt } from '../Transaction.js'\n\n/**\n * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.approve(client, {\n *   spender: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function approve<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: approve.Parameters<chain, account>,\n): Promise<approve.ReturnValue> {\n  const { token, ...rest } = parameters\n  return approve.inner(writeContract, client, parameters, { ...rest, token })\n}\n\nexport namespace approve {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to approve. */\n    amount: bigint\n    /** Address of the spender. */\n    spender: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: approve.Parameters<chain, account>,\n    args: Args,\n  ): Promise<ReturnType<action>> {\n    const call = approve.call(args)\n    return (await action(client, {\n      ...parameters,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `approve` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.approve.call({\n   *       spender: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { spender, amount, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'approve',\n      args: [spender, amount],\n    })\n  }\n\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Approval',\n    })\n    if (!log) throw new Error('`Approval` event not found.')\n    return log\n  }\n}\n\n/**\n * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.approveSync(client, {\n *   spender: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function approveSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: approveSync.Parameters<chain, account>,\n): Promise<approveSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await approve.inner(\n    writeContractSync,\n    client,\n    { ...parameters, throwOnReceiptRevert } as never,\n    rest,\n  )\n  const { args } = approve.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace approveSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = approve.Parameters<chain, account>\n\n  export type Args = approve.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'Approval',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Burns TIP20 tokens from a blocked address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burnBlocked(client, {\n *   from: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burnBlocked<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnBlocked.Parameters<chain, account>,\n): Promise<burnBlocked.ReturnValue> {\n  return burnBlocked.inner(writeContract, client, parameters)\n}\n\nexport namespace burnBlocked {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to burn. */\n    amount: bigint\n    /** Address to burn tokens from. */\n    from: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: burnBlocked.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, from, token, ...rest } = parameters\n    const call = burnBlocked.call({ amount, from, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `burnBlocked` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.burnBlocked.call({\n   *       from: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { from, amount, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'burnBlocked',\n      args: [from, amount],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'BurnBlocked',\n    })\n    if (!log) throw new Error('`BurnBlocked` event not found.')\n    return log\n  }\n}\n\n/**\n * Burns TIP20 tokens from a blocked address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burnBlockedSync(client, {\n *   from: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnBlockedSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnBlockedSync.Parameters<chain, account>,\n): Promise<burnBlockedSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await burnBlocked.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = burnBlocked.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace burnBlockedSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = burnBlocked.Parameters<chain, account>\n\n  export type Args = burnBlocked.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'BurnBlocked',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Burns TIP20 tokens from the caller's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burn(client, {\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function burn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burn.Parameters<chain, account>,\n): Promise<burn.ReturnValue> {\n  return burn.inner(writeContract, client, parameters)\n}\n\nexport namespace burn {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to burn. */\n    amount: bigint\n    /** Memo to include in the transfer. */\n    memo?: Hex.Hex | undefined\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: burn.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, memo, token, ...rest } = parameters\n    const call = burn.call({ amount, memo, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `burn` or `burnWithMemo` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.burn.call({\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { amount, memo, token } = args\n    const callArgs = memo\n      ? ({\n          functionName: 'burnWithMemo',\n          args: [amount, Hex.padLeft(memo, 32)],\n        } as const)\n      : ({\n          functionName: 'burn',\n          args: [amount],\n        } as const)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      ...callArgs,\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Burn',\n    })\n    if (!log) throw new Error('`Burn` event not found.')\n    return log\n  }\n}\n\n/**\n * Burns TIP20 tokens from the caller's balance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.burnSync(client, {\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: burnSync.Parameters<chain, account>,\n): Promise<burnSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await burn.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = burn.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace burnSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = burn.Parameters<chain, account>\n\n  export type Args = burn.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'Burn',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Changes the transfer policy ID for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.changeTransferPolicy(client, {\n *   token: '0x...',\n *   policyId: 1n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function changeTransferPolicy<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeTransferPolicy.Parameters<chain, account>,\n): Promise<changeTransferPolicy.ReturnValue> {\n  return changeTransferPolicy.inner(writeContract, client, parameters)\n}\n\nexport namespace changeTransferPolicy {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New transfer policy ID. */\n    policyId: bigint\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: changeTransferPolicy.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { policyId, token, ...rest } = parameters\n    const call = changeTransferPolicy.call({ policyId, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `changeTransferPolicyId` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.changeTransferPolicy.call({\n   *       token: '0x20c0...babe',\n   *       policyId: 1n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, policyId } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'changeTransferPolicyId',\n      args: [policyId],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'TransferPolicyUpdate',\n    })\n    if (!log) throw new Error('`TransferPolicyUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Changes the transfer policy ID for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.changeTransferPolicySync(client, {\n *   token: '0x...',\n *   policyId: 1n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function changeTransferPolicySync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: changeTransferPolicySync.Parameters<chain, account>,\n): Promise<changeTransferPolicySync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await changeTransferPolicy.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = changeTransferPolicy.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace changeTransferPolicySync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = changeTransferPolicy.Parameters<chain, account>\n\n  export type Args = changeTransferPolicy.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'TransferPolicyUpdate',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Creates a new TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.create(client, {\n *   name: 'My Token',\n *   symbol: 'MTK',\n *   currency: 'USD',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function create<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: create.Parameters<chain, account>,\n): Promise<create.ReturnValue> {\n  return create.inner(writeContract, client, parameters)\n}\n\nexport namespace create {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'admin'> &\n    (account extends Account\n      ? { admin?: Account | Address | undefined }\n      : { admin: Account | Address })\n\n  export type Args = {\n    /** Admin address. */\n    admin: Address\n    /** Currency (e.g. \"USD\"). */\n    currency: string\n    /** Token name. */\n    name: string\n    /** quote token. */\n    quoteToken?: TokenId.TokenIdOrAddress | undefined\n    /** Token symbol. */\n    symbol: string\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: any,\n  ): Promise<ReturnType<action>> {\n    const {\n      account = client.account,\n      admin: admin_ = client.account,\n      chain = client.chain,\n      ...rest\n    } = parameters\n    const admin = admin_ ? parseAccount(admin_) : undefined\n    if (!admin) throw new Error('admin is required.')\n\n    const call = create.call({ ...rest, admin: admin.address })\n\n    return (await action(\n      client as never,\n      {\n        ...parameters,\n        account,\n        chain,\n        ...call,\n      } as never,\n    )) as never\n  }\n\n  /**\n   * Defines a call to the `createToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.create.call({\n   *       name: 'My Token',\n   *       symbol: 'MTK',\n   *       currency: 'USD',\n   *       admin: '0xfeed...fede',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const {\n      name,\n      symbol,\n      currency,\n      quoteToken = Addresses.pathUsd,\n      admin,\n    } = args\n    return defineCall({\n      address: Addresses.tip20Factory,\n      abi: Abis.tip20Factory,\n      args: [name, symbol, currency, TokenId.toAddress(quoteToken), admin],\n      functionName: 'createToken',\n    })\n  }\n\n  /**\n   * Extracts the `TokenCreated` event from logs.\n   *\n   * @param logs - The logs.\n   * @returns The `TokenCreated` event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20Factory,\n      logs,\n      eventName: 'TokenCreated',\n      strict: true,\n    })\n    if (!log) throw new Error('`TokenCreated` event not found.')\n    return log\n  }\n}\n\n/**\n * Creates a new TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.createSync(client, {\n *   name: 'My Token',\n *   symbol: 'MTK',\n *   currency: 'USD',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: createSync.Parameters<chain, account>,\n): Promise<createSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await create.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n\n  const { args } = create.extractEvent(receipt.logs)\n\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace createSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = create.Parameters<chain, account>\n\n  export type Args = create.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20Factory,\n      'TokenCreated',\n      { IndexedOnly: false; Required: true }\n    > & {\n      /** Transaction receipt. */\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Gets TIP20 token allowance.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const allowance = await Actions.token.getAllowance(client, {\n *   spender: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The token allowance.\n */\nexport async function getAllowance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getAllowance.Parameters<account>,\n): Promise<getAllowance.ReturnValue> {\n  const { account = client.account } = parameters\n  const address = account ? parseAccount(account).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...parameters,\n    ...getAllowance.call({ ...parameters, account: address }),\n  })\n}\n\nexport namespace getAllowance {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account> & Omit<Args, 'account'> & {}\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n    /** Address of the spender. */\n    spender: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'allowance',\n    never\n  >\n\n  /**\n   * Defines a call to the `allowance` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, spender, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'allowance',\n      args: [account, spender],\n    })\n  }\n}\n\n/**\n * Gets TIP20 token balance for an address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const balance = await Actions.token.getBalance(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The token balance.\n */\nexport async function getBalance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getBalance.Parameters<account>,\n): Promise<getBalance.ReturnValue> {\n  const { account = client.account, ...rest } = parameters\n  const address = account ? parseAccount(account).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...rest,\n    ...getBalance.call({ account: address, ...rest }),\n  })\n}\n\nexport namespace getBalance {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & GetAccountParameter<account> & Omit<Args, 'account'>\n\n  export type Args = {\n    /** Account address. */\n    account: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'balanceOf',\n    never\n  >\n\n  /**\n   * Defines a call to the `balanceOf` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'balanceOf',\n      args: [account],\n    })\n  }\n}\n\n/**\n * Gets TIP20 token metadata including name, symbol, currency, decimals, and total supply.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const metadata = await Actions.token.getMetadata(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The token metadata.\n */\nexport async function getMetadata<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getMetadata.Parameters,\n): Promise<getMetadata.ReturnValue> {\n  const { token, ...rest } = parameters\n  const address = TokenId.toAddress(token)\n  const abi = Abis.tip20\n\n  if (TokenId.from(token) === TokenId.fromAddress(Addresses.pathUsd))\n    return multicall(client, {\n      ...rest,\n      contracts: [\n        {\n          address,\n          abi,\n          functionName: 'currency',\n        },\n        {\n          address,\n          abi,\n          functionName: 'decimals',\n        },\n        {\n          address,\n          abi,\n          functionName: 'name',\n        },\n        {\n          address,\n          abi,\n          functionName: 'symbol',\n        },\n        {\n          address,\n          abi,\n          functionName: 'totalSupply',\n        },\n      ] as const,\n      allowFailure: false,\n      deployless: true,\n    }).then(([currency, decimals, name, symbol, totalSupply]) => ({\n      name,\n      symbol,\n      currency,\n      decimals,\n      totalSupply,\n    }))\n\n  return multicall(client, {\n    ...rest,\n    contracts: [\n      {\n        address,\n        abi,\n        functionName: 'currency',\n      },\n      {\n        address,\n        abi,\n        functionName: 'decimals',\n      },\n      {\n        address,\n        abi,\n        functionName: 'quoteToken',\n      },\n      {\n        address,\n        abi,\n        functionName: 'name',\n      },\n      {\n        address,\n        abi,\n        functionName: 'paused',\n      },\n      {\n        address,\n        abi,\n        functionName: 'supplyCap',\n      },\n      {\n        address,\n        abi,\n        functionName: 'symbol',\n      },\n      {\n        address,\n        abi,\n        functionName: 'totalSupply',\n      },\n      {\n        address,\n        abi,\n        functionName: 'transferPolicyId',\n      },\n    ] as const,\n    allowFailure: false,\n    deployless: true,\n  }).then(\n    ([\n      currency,\n      decimals,\n      quoteToken,\n      name,\n      paused,\n      supplyCap,\n      symbol,\n      totalSupply,\n      transferPolicyId,\n    ]) => ({\n      name,\n      symbol,\n      currency,\n      decimals,\n      quoteToken,\n      totalSupply,\n      paused,\n      supplyCap,\n      transferPolicyId,\n    }),\n  )\n}\n\nexport declare namespace getMetadata {\n  export type Parameters = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = Compute<{\n    /**\n     * Currency (e.g. \"USD\").\n     */\n    currency: string\n    /**\n     * Decimals of the token.\n     */\n    decimals: number\n    /**\n     * Quote token.\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    quoteToken?: Address | undefined\n    /**\n     * Name of the token.\n     */\n    name: string\n    /**\n     * Whether the token is paused.\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    paused?: boolean | undefined\n    /**\n     * Supply cap.\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    supplyCap?: bigint | undefined\n    /**\n     * Symbol of the token.\n     */\n    symbol: string\n    /**\n     * Total supply of the token.\n     */\n    totalSupply: bigint\n    /**\n     * Transfer policy ID.\n     * 0=\"always-reject\", 1=\"always-allow\", >2=custom policy\n     *\n     * Returns `undefined` for the default quote token (`0x20c...0000`).\n     */\n    transferPolicyId?: bigint | undefined\n  }>\n}\n\n/**\n * Gets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const adminRole = await Actions.token.getRoleAdmin(client, {\n *   role: 'issuer',\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The admin role hash.\n */\nexport async function getRoleAdmin<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getRoleAdmin.Parameters,\n): Promise<getRoleAdmin.ReturnValue> {\n  return readContract(client, {\n    ...parameters,\n    ...getRoleAdmin.call(parameters),\n  })\n}\n\nexport namespace getRoleAdmin {\n  export type Parameters = ReadParameters & Args\n\n  export type Args = {\n    /** Role to get admin for. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'getRoleAdmin',\n    never\n  >\n\n  /**\n   * Defines a call to the `getRoleAdmin` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { role, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'getRoleAdmin',\n      args: [TokenRole.serialize(role)],\n    })\n  }\n}\n\n/**\n * Checks if an account has a specific role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const hasRole = await Actions.token.hasRole(client, {\n *   account: '0x...',\n *   role: 'issuer',\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Whether the account has the role.\n */\nexport async function hasRole<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: hasRole.Parameters<account>,\n): Promise<hasRole.ReturnValue> {\n  const { account = client.account } = parameters\n  const address = account ? parseAccount(account).address : undefined\n  if (!address) throw new Error('account is required.')\n  return readContract(client, {\n    ...parameters,\n    ...hasRole.call({ ...parameters, account: address }),\n  })\n}\n\nexport namespace hasRole {\n  export type Parameters<\n    account extends Account | undefined = Account | undefined,\n  > = ReadParameters & Omit<Args, 'account'> & GetAccountParameter<account>\n\n  export type Args = {\n    /** Account address to check. */\n    account: Address\n    /** Role to check. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = ReadContractReturnType<\n    typeof Abis.tip20,\n    'hasRole',\n    never\n  >\n\n  /**\n   * Defines a call to the `hasRole` function.\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { account, role, token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'hasRole',\n      args: [account, TokenRole.serialize(role)],\n    })\n  }\n}\n\n/**\n * Grants a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.grantRoles(client, {\n *   token: '0x...',\n *   to: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function grantRoles<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: grantRoles.Parameters<chain, account>,\n): Promise<grantRoles.ReturnValue> {\n  return grantRoles.inner(sendTransaction, client, parameters)\n}\n\nexport namespace grantRoles {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'role'> & {\n      /** Role to grant. */\n      roles: readonly TokenRole.TokenRole[]\n    }\n\n  export type Args = {\n    /** Role to grant. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n    /** Address to grant the role to. */\n    to: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof sendTransaction | typeof sendTransactionSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: grantRoles.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    return (await action(client, {\n      ...parameters,\n      calls: parameters.roles.map((role) => {\n        const call = grantRoles.call({ ...parameters, role })\n        return {\n          ...call,\n          data: encodeFunctionData(call),\n        }\n      }),\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `grantRole` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.grantRoles.call({\n   *       token: '0x20c0...babe',\n   *       to: '0x20c0...beef',\n   *       role: 'issuer',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, to, role } = args\n    const roleHash = TokenRole.serialize(role)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'grantRole',\n      args: [roleHash, to],\n    })\n  }\n\n  /**\n   * Extracts the events from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The events.\n   */\n  export function extractEvents(logs: Log[]) {\n    const events = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleMembershipUpdated',\n    })\n    if (events.length === 0)\n      throw new Error('`RoleMembershipUpdated` events not found.')\n    return events\n  }\n}\n\n/**\n * Grants a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.grantRolesSync(client, {\n *   token: '0x...',\n *   to: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function grantRolesSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: grantRolesSync.Parameters<chain, account>,\n): Promise<grantRolesSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await grantRoles.inner(sendTransactionSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const events = grantRoles.extractEvents(receipt.logs)\n  const value = events.map((event) => event.args)\n  return {\n    receipt,\n    value,\n  }\n}\n\nexport namespace grantRolesSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = grantRoles.Parameters<chain, account>\n\n  export type Args = grantRoles.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n    value: readonly GetEventArgs<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      { IndexedOnly: false; Required: true }\n    >[]\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Mints TIP20 tokens to an address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.mint(client, {\n *   to: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function mint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mint.Parameters<chain, account>,\n): Promise<mint.ReturnValue> {\n  return mint.inner(writeContract, client, parameters)\n}\n\nexport namespace mint {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to mint. */\n    amount: bigint\n    /** Memo to include in the mint. */\n    memo?: Hex.Hex | undefined\n    /** Address to mint tokens to. */\n    to: Address\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: any,\n  ): Promise<ReturnType<action>> {\n    const call = mint.call(parameters)\n    return (await action(client, {\n      ...parameters,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `mint` or `mintWithMemo` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.mint.call({\n   *       to: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { to, amount, memo, token } = args\n    const callArgs = memo\n      ? ({\n          functionName: 'mintWithMemo',\n          args: [to, amount, Hex.padLeft(memo, 32)],\n        } as const)\n      : ({\n          functionName: 'mint',\n          args: [to, amount],\n        } as const)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      ...callArgs,\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Mint',\n    })\n    if (!log) throw new Error('`Mint` event not found.')\n    return log\n  }\n}\n\n/**\n * Mints TIP20 tokens to an address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.mintSync(client, {\n *   to: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function mintSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: mintSync.Parameters<chain, account>,\n): Promise<mintSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await mint.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = mint.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace mintSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = mint.Parameters<chain, account>\n\n  export type Args = mint.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'Mint',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Pauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.pause(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function pause<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: pause.Parameters<chain, account>,\n): Promise<pause.ReturnValue> {\n  return pause.inner(writeContract, client, parameters)\n}\n\nexport namespace pause {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: pause.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = pause.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `pause` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.pause.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'pause',\n      args: [],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'PauseStateUpdate',\n    })\n    if (!log) throw new Error('`PauseStateUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Pauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.pauseSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function pauseSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: pauseSync.Parameters<chain, account>,\n): Promise<pauseSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await pause.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = pause.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  }\n}\n\nexport namespace pauseSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = pause.Parameters<chain, account>\n\n  export type Args = pause.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'PauseStateUpdate',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Renounces a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.renounceRoles(client, {\n *   token: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function renounceRoles<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: renounceRoles.Parameters<chain, account>,\n): Promise<renounceRoles.ReturnValue> {\n  return renounceRoles.inner(sendTransaction, client, parameters)\n}\n\nexport namespace renounceRoles {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> &\n    Omit<Args, 'role'> & {\n      /** Roles to renounce. */\n      roles: readonly TokenRole.TokenRole[]\n    }\n\n  export type Args = {\n    /** Role to renounce. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof sendTransaction | typeof sendTransactionSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: renounceRoles.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    return (await action(client, {\n      ...parameters,\n      calls: parameters.roles.map((role) => {\n        const call = renounceRoles.call({ ...parameters, role })\n        return {\n          ...call,\n          data: encodeFunctionData(call),\n        }\n      }),\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `renounceRole` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.renounceRoles.call({\n   *       token: '0x20c0...babe',\n   *       role: 'issuer',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, role } = args\n    const roleHash = TokenRole.serialize(role)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'renounceRole',\n      args: [roleHash],\n    })\n  }\n\n  /**\n   * Extracts the events from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The events.\n   */\n  export function extractEvents(logs: Log[]) {\n    const events = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleMembershipUpdated',\n    })\n    if (events.length === 0)\n      throw new Error('`RoleMembershipUpdated` events not found.')\n    return events\n  }\n}\n\n/**\n * Renounces a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.renounceRolesSync(client, {\n *   token: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function renounceRolesSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: renounceRolesSync.Parameters<chain, account>,\n): Promise<renounceRolesSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await renounceRoles.inner(sendTransactionSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const events = renounceRoles.extractEvents(receipt.logs)\n  const value = events.map((event) => event.args)\n  return {\n    receipt,\n    value,\n  }\n}\n\nexport namespace renounceRolesSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = renounceRoles.Parameters<chain, account>\n\n  export type Args = renounceRoles.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n    value: readonly GetEventArgs<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      { IndexedOnly: false; Required: true }\n    >[]\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Revokes a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.revokeRoles(client, {\n *   token: '0x...',\n *   from: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function revokeRoles<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: revokeRoles.Parameters<chain, account>,\n): Promise<revokeRoles.ReturnValue> {\n  return revokeRoles.inner(sendTransaction, client, parameters)\n}\n\nexport namespace revokeRoles {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = SendTransactionSyncParameters<chain, account> &\n    Omit<Args, 'role'> & {\n      /** Role to revoke. */\n      roles: readonly TokenRole.TokenRole[]\n    }\n\n  export type Args = {\n    /** Address to revoke the role from. */\n    from: Address\n    /** Role to revoke. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof sendTransaction | typeof sendTransactionSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: revokeRoles.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    return (await action(client, {\n      ...parameters,\n      calls: parameters.roles.map((role) => {\n        const call = revokeRoles.call({ ...parameters, role })\n        return {\n          ...call,\n          data: encodeFunctionData(call),\n        }\n      }),\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `revokeRole` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.revokeRoles.call({\n   *       token: '0x20c0...babe',\n   *       from: '0x20c0...beef',\n   *       role: 'issuer',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, from, role } = args\n    const roleHash = TokenRole.serialize(role)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'revokeRole',\n      args: [roleHash, from],\n    })\n  }\n\n  /**\n   * Extracts the events from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The events.\n   */\n  export function extractEvents(logs: Log[]) {\n    const events = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleMembershipUpdated',\n    })\n    if (events.length === 0)\n      throw new Error('`RoleMembershipUpdated` events not found.')\n    return events\n  }\n}\n\n/**\n * Revokes a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.revokeRolesSync(client, {\n *   token: '0x...',\n *   from: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function revokeRolesSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: revokeRolesSync.Parameters<chain, account>,\n): Promise<revokeRolesSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await revokeRoles.inner(sendTransactionSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const events = revokeRoles.extractEvents(receipt.logs)\n  const value = events.map((event) => event.args)\n  return {\n    receipt,\n    value,\n  }\n}\n\nexport namespace revokeRolesSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = revokeRoles.Parameters<chain, account>\n\n  export type Args = revokeRoles.Args\n\n  export type ReturnValue = {\n    receipt: TransactionReceipt\n    value: readonly GetEventArgs<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      { IndexedOnly: false; Required: true }\n    >[]\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sets the supply cap for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setSupplyCap(client, {\n *   token: '0x...',\n *   supplyCap: 1000000n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setSupplyCap<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setSupplyCap.Parameters<chain, account>,\n): Promise<setSupplyCap.ReturnValue> {\n  return setSupplyCap.inner(writeContract, client, parameters)\n}\n\nexport namespace setSupplyCap {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New supply cap. */\n    supplyCap: bigint\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setSupplyCap.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { supplyCap, token, ...rest } = parameters\n    const call = setSupplyCap.call({ supplyCap, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setSupplyCap` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.setSupplyCap.call({\n   *       token: '0x20c0...babe',\n   *       supplyCap: 1000000n,\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, supplyCap } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'setSupplyCap',\n      args: [supplyCap],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'SupplyCapUpdate',\n    })\n    if (!log) throw new Error('`SupplyCapUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the supply cap for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setSupplyCapSync(client, {\n *   token: '0x...',\n *   supplyCap: 1000000n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setSupplyCapSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setSupplyCapSync.Parameters<chain, account>,\n): Promise<setSupplyCapSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setSupplyCap.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setSupplyCap.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setSupplyCapSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setSupplyCap.Parameters<chain, account>\n\n  export type Args = setSupplyCap.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'SupplyCapUpdate',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Sets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setRoleAdmin(client, {\n *   token: '0x...',\n *   role: 'issuer',\n *   adminRole: 'admin',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setRoleAdmin<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRoleAdmin.Parameters<chain, account>,\n): Promise<setRoleAdmin.ReturnValue> {\n  return setRoleAdmin.inner(writeContract, client, parameters)\n}\n\nexport namespace setRoleAdmin {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New admin role. */\n    adminRole: TokenRole.TokenRole\n    /** Role to set admin for. */\n    role: TokenRole.TokenRole\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: setRoleAdmin.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { adminRole, role, token, ...rest } = parameters\n    const call = setRoleAdmin.call({ adminRole, role, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `setRoleAdmin` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.setRoleAdmin.call({\n   *       token: '0x20c0...babe',\n   *       role: 'issuer',\n   *       adminRole: 'admin',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, role, adminRole } = args\n    const roleHash = TokenRole.serialize(role)\n    const adminRoleHash = TokenRole.serialize(adminRole)\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'setRoleAdmin',\n      args: [roleHash, adminRoleHash],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'RoleAdminUpdated',\n    })\n    if (!log) throw new Error('`RoleAdminUpdated` event not found.')\n    return log\n  }\n}\n\n/**\n * Sets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.setRoleAdminSync(client, {\n *   token: '0x...',\n *   role: 'issuer',\n *   adminRole: 'admin',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setRoleAdminSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: setRoleAdminSync.Parameters<chain, account>,\n): Promise<setRoleAdminSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await setRoleAdmin.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = setRoleAdmin.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace setRoleAdminSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = setRoleAdmin.Parameters<chain, account>\n\n  export type Args = setRoleAdmin.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'RoleAdminUpdated',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Transfers TIP20 tokens to another address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.transfer(client, {\n *   to: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function transfer<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: transfer.Parameters<chain, account>,\n): Promise<transfer.ReturnValue> {\n  return transfer.inner(writeContract, client, parameters)\n}\n\nexport namespace transfer {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Amount of tokens to transfer. */\n    amount: bigint\n    /** Address to transfer tokens from. */\n    from?: Address | undefined\n    /** Memo to include in the transfer. */\n    memo?: Hex.Hex | undefined\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n    /** Address to transfer tokens to. */\n    to: Address\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: transfer.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { amount, from, memo, token, to, ...rest } = parameters\n    const call = transfer.call({ amount, from, memo, token, to })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `transfer`, `transferFrom`, `transferWithMemo`, or `transferFromWithMemo` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.transfer.call({\n   *       to: '0x20c0...beef',\n   *       amount: 100n,\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { amount, from, memo, token, to } = args\n    const callArgs = (() => {\n      if (memo && from)\n        return {\n          functionName: 'transferFromWithMemo',\n          args: [from, to, amount, Hex.padLeft(memo, 32)],\n        } as const\n      if (memo)\n        return {\n          functionName: 'transferWithMemo',\n          args: [to, amount, Hex.padLeft(memo, 32)],\n        } as const\n      if (from)\n        return {\n          functionName: 'transferFrom',\n          args: [from, to, amount],\n        } as const\n      return {\n        functionName: 'transfer',\n        args: [to, amount],\n      } as const\n    })()\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      ...callArgs,\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'Transfer',\n    })\n    if (!log) throw new Error('`Transfer` event not found.')\n    return log\n  }\n}\n\n/**\n * Transfers TIP20 tokens to another address.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.transferSync(client, {\n *   to: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function transferSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: transferSync.Parameters<chain, account>,\n): Promise<transferSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await transfer.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = transfer.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace transferSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = transfer.Parameters<chain, account>\n\n  export type Args = transfer.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'Transfer',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Unpauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.unpause(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function unpause<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: unpause.Parameters<chain, account>,\n): Promise<unpause.ReturnValue> {\n  return unpause.inner(writeContract, client, parameters)\n}\n\nexport namespace unpause {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: unpause.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = unpause.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `unpause` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.unpause.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'unpause',\n      args: [],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'PauseStateUpdate',\n    })\n    if (!log) throw new Error('`PauseStateUpdate` event not found.')\n    return log\n  }\n}\n\n/**\n * Unpauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.unpauseSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function unpauseSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: unpauseSync.Parameters<chain, account>,\n): Promise<unpauseSync.ReturnValue> {\n  const { throwOnReceiptRevert = true, ...rest } = parameters\n  const receipt = await unpause.inner(writeContractSync, client, {\n    ...rest,\n    throwOnReceiptRevert,\n  } as never)\n  const { args } = unpause.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace unpauseSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = unpause.Parameters<chain, account>\n\n  export type Args = unpause.Args\n\n  export type ReturnValue = GetEventArgs<\n    typeof Abis.tip20,\n    'PauseStateUpdate',\n    { IndexedOnly: false; Required: true }\n  > & {\n    receipt: TransactionReceipt\n  }\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.prepareUpdateQuoteToken(client, {\n *   token: '0x...',\n *   quoteToken: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function prepareUpdateQuoteToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: prepareUpdateQuoteToken.Parameters<chain, account>,\n): Promise<prepareUpdateQuoteToken.ReturnValue> {\n  return prepareUpdateQuoteToken.inner(writeContract, client, parameters)\n}\n\nexport namespace prepareUpdateQuoteToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** New quote token address. */\n    quoteToken: TokenId.TokenIdOrAddress\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: prepareUpdateQuoteToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { quoteToken, token, ...rest } = parameters\n    const call = prepareUpdateQuoteToken.call({ quoteToken, token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `prepareUpdateQuoteToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.prepareUpdateQuoteToken.call({\n   *       token: '0x20c0...babe',\n   *       quoteToken: '0x20c0...cafe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token, quoteToken } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'setNextQuoteToken',\n      args: [TokenId.toAddress(quoteToken)],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'NextQuoteTokenSet',\n    })\n    if (!log) throw new Error('`NextQuoteTokenSet` event not found.')\n    return log\n  }\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.prepareUpdateQuoteTokenSync(client, {\n *   token: '0x...',\n *   quoteToken: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function prepareUpdateQuoteTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: prepareUpdateQuoteTokenSync.Parameters<chain, account>,\n): Promise<prepareUpdateQuoteTokenSync.ReturnValue> {\n  const receipt = await prepareUpdateQuoteToken.inner(\n    writeContractSync,\n    client,\n    parameters,\n  )\n  const { args } = prepareUpdateQuoteToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace prepareUpdateQuoteTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = prepareUpdateQuoteToken.Parameters<chain, account>\n\n  export type Args = prepareUpdateQuoteToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'NextQuoteTokenSet',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.updateQuoteToken(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function updateQuoteToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: updateQuoteToken.Parameters<chain, account>,\n): Promise<updateQuoteToken.ReturnValue> {\n  return updateQuoteToken.inner(writeContract, client, parameters)\n}\n\nexport namespace updateQuoteToken {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = WriteParameters<chain, account> & Args\n\n  export type Args = {\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WriteContractReturnType\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n\n  /** @internal */\n  export async function inner<\n    action extends typeof writeContract | typeof writeContractSync,\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n  >(\n    action: action,\n    client: Client<Transport, chain, account>,\n    parameters: updateQuoteToken.Parameters<chain, account>,\n  ): Promise<ReturnType<action>> {\n    const { token, ...rest } = parameters\n    const call = updateQuoteToken.call({ token })\n    return (await action(client, {\n      ...rest,\n      ...call,\n    } as never)) as never\n  }\n\n  /**\n   * Defines a call to the `updateQuoteToken` function.\n   *\n   * Can be passed as a parameter to:\n   * - [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas): estimate the gas cost of the call\n   * - [`simulateContract`](https://viem.sh/docs/contract/simulateContract): simulate the call\n   * - [`sendCalls`](https://viem.sh/docs/actions/wallet/sendCalls): send multiple calls\n   *\n   * @example\n   * ```ts\n   * import { createClient, http, walletActions } from 'viem'\n   * import { tempo } from 'tempo.ts/chains'\n   * import { Actions } from 'tempo.ts/viem'\n   *\n   * const client = createClient({\n   *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n   *   transport: http(),\n   * }).extend(walletActions)\n   *\n   * const { result } = await client.sendCalls({\n   *   calls: [\n   *     actions.token.updateQuoteToken.call({\n   *       token: '0x20c0...babe',\n   *     }),\n   *   ]\n   * })\n   * ```\n   *\n   * @param args - Arguments.\n   * @returns The call.\n   */\n  export function call(args: Args) {\n    const { token } = args\n    return defineCall({\n      address: TokenId.toAddress(token),\n      abi: Abis.tip20,\n      functionName: 'completeQuoteTokenUpdate',\n      args: [],\n    })\n  }\n\n  /**\n   * Extracts the event from the logs.\n   *\n   * @param logs - Logs.\n   * @returns The event.\n   */\n  export function extractEvent(logs: Log[]) {\n    const [log] = parseEventLogs({\n      abi: Abis.tip20,\n      logs,\n      eventName: 'QuoteTokenUpdate',\n    })\n    if (!log) throw new Error('`QuoteTokenUpdateCompleted` event not found.')\n    return log\n  }\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const result = await Actions.token.updateQuoteTokenSync(client, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function updateQuoteTokenSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: updateQuoteTokenSync.Parameters<chain, account>,\n): Promise<updateQuoteTokenSync.ReturnValue> {\n  const receipt = await updateQuoteToken.inner(\n    writeContractSync,\n    client,\n    parameters,\n  )\n  const { args } = updateQuoteToken.extractEvent(receipt.logs)\n  return {\n    ...args,\n    receipt,\n  } as never\n}\n\nexport namespace updateQuoteTokenSync {\n  export type Parameters<\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  > = updateQuoteToken.Parameters<chain, account>\n\n  export type Args = updateQuoteToken.Args\n\n  export type ReturnValue = Compute<\n    GetEventArgs<\n      typeof Abis.tip20,\n      'QuoteTokenUpdate',\n      {\n        IndexedOnly: false\n        Required: true\n      }\n    > & {\n      receipt: TransactionReceipt\n    }\n  >\n\n  // TODO: exhaustive error type\n  export type ErrorType = BaseErrorType\n}\n\n/**\n * Watches for TIP20 token approval events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchApprove(client, {\n *   onApproval: (args, log) => {\n *     console.log('Approval:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchApprove<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchApprove.Parameters,\n) {\n  const { onApproval, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Approval',\n    onLogs: (logs) => {\n      for (const log of logs) onApproval(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchApprove {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Approval',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Approval'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Approval', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are approved. */\n    onApproval: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token burn events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchBurn(client, {\n *   onBurn: (args, log) => {\n *     console.log('Burn:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBurn<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchBurn.Parameters) {\n  const { onBurn, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Burn',\n    onLogs: (logs) => {\n      for (const log of logs) onBurn(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchBurn {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Burn',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Burn'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Burn', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are burned. */\n    onBurn: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for new TIP20 tokens created.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchCreate(client, {\n *   onTokenCreated: (args, log) => {\n *     console.log('Token created:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchCreate<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchCreate.Parameters,\n) {\n  const { onTokenCreated, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: Addresses.tip20Factory,\n    abi: Abis.tip20Factory,\n    eventName: 'TokenCreated',\n    onLogs: (logs) => {\n      for (const log of logs) onTokenCreated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchCreate {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20Factory,\n    'TokenCreated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20Factory, 'TokenCreated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip20Factory,\n      'TokenCreated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a new TIP20 token is created. */\n    onTokenCreated: (args: Args, log: Log) => void\n  }\n}\n\n/**\n * Watches for TIP20 token mint events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchMint(client, {\n *   onMint: (args, log) => {\n *     console.log('Mint:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchMint<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchMint.Parameters) {\n  const { onMint, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Mint',\n    onLogs: (logs) => {\n      for (const log of logs) onMint(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchMint {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Mint',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Mint'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Mint', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are minted. */\n    onMint: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n\n  export type ReturnValue = WatchContractEventReturnType\n}\n\n/**\n * Watches for TIP20 token role admin updates.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchAdminRole(client, {\n *   onRoleAdminUpdated: (args, log) => {\n *     console.log('Role admin updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchAdminRole<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchAdminRole.Parameters,\n) {\n  const { onRoleAdminUpdated, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'RoleAdminUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) onRoleAdminUpdated(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchAdminRole {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RoleAdminUpdated',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RoleAdminUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'RoleAdminUpdated', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a role admin is updated. */\n    onRoleAdminUpdated: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token role membership updates.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchRole(client, {\n *   onRoleUpdated: (args, log) => {\n *     console.log('Role updated:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRole<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, parameters: watchRole.Parameters) {\n  const { onRoleUpdated, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'RoleMembershipUpdated',\n    onLogs: (logs) => {\n      for (const log of logs) {\n        const type = log.args.hasRole ? 'granted' : 'revoked'\n        onRoleUpdated({ ...log.args, type }, log)\n      }\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchRole {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'RoleMembershipUpdated',\n    { IndexedOnly: false; Required: true }\n  > & {\n    /** Type of role update. */\n    type: 'granted' | 'revoked'\n  }\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'RoleMembershipUpdated'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<\n      typeof Abis.tip20,\n      'RoleMembershipUpdated',\n      true\n    >,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a role membership is updated. */\n    onRoleUpdated: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token transfer events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x...'),\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchTransfer(client, {\n *   onTransfer: (args, log) => {\n *     console.log('Transfer:', args)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchTransfer<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchTransfer.Parameters,\n) {\n  const { onTransfer, token, ...rest } = parameters\n  return watchContractEvent(client, {\n    ...rest,\n    address: TokenId.toAddress(token),\n    abi: Abis.tip20,\n    eventName: 'Transfer',\n    onLogs: (logs) => {\n      for (const log of logs) onTransfer(log.args, log)\n    },\n    strict: true,\n  })\n}\n\nexport declare namespace watchTransfer {\n  export type Args = GetEventArgs<\n    typeof Abis.tip20,\n    'Transfer',\n    { IndexedOnly: false; Required: true }\n  >\n\n  export type Log = viem_Log<\n    bigint,\n    number,\n    false,\n    ExtractAbiItem<typeof Abis.tip20, 'Transfer'>,\n    true\n  >\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, 'Transfer', true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when tokens are transferred. */\n    onTransfer: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n\n/**\n * Watches for TIP20 token quote token update events.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { tempo } from 'tempo.ts/chains'\n * import { Actions } from 'tempo.ts/viem'\n *\n * const client = createClient({\n *   chain: tempo({ feeToken: '0x20c0000000000000000000000000000000000001' })\n *   transport: http(),\n * })\n *\n * const unwatch = actions.token.watchUpdateQuoteToken(client, {\n *   onUpdateQuoteToken: (args, log) => {\n *     if (args.completed)\n *       console.log('quote token update completed:', args.newQuoteToken)\n *     else\n *       console.log('quote token update proposed:', args.newQuoteToken)\n *   },\n * })\n * ```\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchUpdateQuoteToken<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: watchUpdateQuoteToken.Parameters,\n) {\n  const { onUpdateQuoteToken, token, ...rest } = parameters\n  const address = TokenId.toAddress(token)\n\n  return watchContractEvent(client, {\n    ...rest,\n    address,\n    abi: Abis.tip20,\n    onLogs: (\n      logs: viem_Log<\n        bigint,\n        number,\n        false,\n        ExtractAbiItem<\n          typeof Abis.tip20,\n          'NextQuoteTokenSet' | 'QuoteTokenUpdate'\n        >,\n        true\n      >[],\n    ) => {\n      for (const log of logs) {\n        if (\n          log.eventName !== 'NextQuoteTokenSet' &&\n          log.eventName !== 'QuoteTokenUpdate'\n        )\n          continue\n\n        onUpdateQuoteToken(\n          {\n            ...log.args,\n            completed: log.eventName === 'QuoteTokenUpdate',\n          },\n          log,\n        )\n      }\n    },\n    strict: true,\n  } as never)\n}\n\nexport declare namespace watchUpdateQuoteToken {\n  export type Args = OneOf<\n    | GetEventArgs<\n        typeof Abis.tip20,\n        'NextQuoteTokenSet',\n        { IndexedOnly: false; Required: true }\n      >\n    | GetEventArgs<\n        typeof Abis.tip20,\n        'QuoteTokenUpdate',\n        { IndexedOnly: false; Required: true }\n      >\n  > & {\n    /** Whether the update has been completed. */\n    completed: boolean\n  }\n\n  export type Log = viem_Log\n\n  export type Parameters = UnionOmit<\n    WatchContractEventParameters<typeof Abis.tip20, any, true>,\n    'abi' | 'address' | 'batch' | 'eventName' | 'onLogs' | 'strict'\n  > & {\n    /** Callback to invoke when a quote token update is proposed or completed. */\n    onUpdateQuoteToken: (args: Args, log: Log) => void\n    /** Address or ID of the TIP20 token. */\n    token: TokenId.TokenIdOrAddress\n  }\n}\n", "import type { Errors, RpcRequest } from '../index.js'\nimport type {\n  Compute,\n  IsNarrowable,\n  IsNever,\n  OneOf,\n  UnionPartialBy,\n} from './internal/types.js'\n\n/** A JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcResponse<\n  result = unknown,\n  error extends ErrorObject = ErrorObject,\n> = Compute<\n  {\n    id: number\n    jsonrpc: '2.0'\n  } & OneOf<{ result: result } | { error: error }>\n>\n\n/** JSON-RPC error object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#error_object). */\nexport type ErrorObject = {\n  code: number\n  message: string\n  data?: unknown | undefined\n}\n\n/**\n * A type-safe interface to instantiate a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object).\n *\n * @example\n * ### Instantiating a Response Object\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * @example\n * ### Type-safe Instantiation\n *\n * If you have a JSON-RPC request object, you can use it to strongly-type the response. If a `request` is provided,\n * then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function from<\n  request extends RpcRequest.RpcRequest | undefined = undefined,\n  const response =\n    | (request extends RpcRequest.RpcRequest\n        ? request['_returnType']\n        : RpcResponse)\n    | unknown,\n>(\n  response: from.Response<request, response>,\n  options?: from.Options<request>,\n): Compute<from.ReturnType<response>>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(response: RpcResponse, options: any = {}): RpcResponse {\n  const { request } = options\n  return {\n    ...response,\n    id: response.id ?? request?.id,\n    jsonrpc: response.jsonrpc ?? request.jsonrpc,\n  }\n}\n\nexport declare namespace from {\n  type Response<\n    request extends RpcRequest.RpcRequest | undefined = undefined,\n    response = unknown,\n  > = response &\n    (request extends RpcRequest.RpcRequest\n      ? UnionPartialBy<RpcResponse<request['_returnType']>, 'id' | 'jsonrpc'>\n      : RpcResponse)\n\n  type Options<\n    request extends RpcRequest.RpcRequest | undefined =\n      | RpcRequest.RpcRequest\n      | undefined,\n  > = {\n    request?: request | RpcRequest.RpcRequest | undefined\n  }\n\n  type ReturnType<response> = IsNarrowable<response, RpcResponse> extends true\n    ? RpcResponse\n    : response & Readonly<{ id: number; jsonrpc: '2.0' }>\n}\n\n/**\n * A type-safe interface to parse a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object), and extract the result.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::tip\n *\n * If you don't need the return type, you can omit the options entirely.\n *\n * ```ts twoslash\n * // @noErrors\n * import { RpcResponse } from 'ox'\n *\n * const block = await fetch('https://1.rpc.thirdweb.com', {})\n *  .then((response) => response.json())\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code --]\n *  .then(RpcResponse.parse) // [!code ++]\n * ```\n * :::\n *\n * @example\n * ### Raw Mode\n *\n * If `raw` is `true`, the response will be returned as an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n *\n * const response = RpcResponse.parse({}, {\n *   request,\n *   raw: true, // [!code hl]\n * })\n *\n * response.result\n * //       ^?\n *\n *\n * response.error\n * //       ^?\n *\n *\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function parse<\n  const response extends RpcResponse | unknown,\n  returnType,\n  raw extends boolean = false,\n>(\n  response: response,\n  options: parse.Options<returnType, raw> = {},\n): parse.ReturnType<\n  unknown extends response\n    ? returnType\n    : response extends RpcResponse\n      ? response extends { result: infer result }\n        ? result\n        : never\n      : returnType,\n  raw\n> {\n  const { raw = false } = options\n  const response_ = response as RpcResponse\n  if (raw) return response as never\n  if (response_.error) throw parseError(response_.error)\n  return response_.result as never\n}\n\nexport declare namespace parse {\n  type Options<returnType, raw extends boolean = false> = {\n    /**\n     * JSON-RPC Method that was used to make the request. Used for typing the response.\n     */\n    request?:\n      | {\n          _returnType: returnType\n        }\n      | RpcRequest.RpcRequest\n      | undefined\n    /**\n     * Enables raw mode  responses will return an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n     *\n     * - `true`: a JSON-RPC response object will be returned with `result` and `error` properties.\n     * - `false`: the JSON-RPC response object's `result` property will be returned directly, and JSON-RPC Errors will be thrown.\n     *\n     * @default false\n     */\n    raw?: raw | boolean | undefined\n  }\n\n  type ReturnType<returnType, raw extends boolean = false> = Compute<\n    raw extends true ? RpcResponse<returnType> : returnType\n  >\n\n  type ErrorType =\n    | ParseError\n    | InvalidInputError\n    | ResourceNotFoundError\n    | ResourceUnavailableError\n    | TransactionRejectedError\n    | MethodNotSupportedError\n    | LimitExceededError\n    | VersionNotSupportedError\n    | InvalidRequestError\n    | MethodNotFoundError\n    | InvalidParamsError\n    | InternalError\n    | BaseErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a RPC Error instance.\n *\n * @example\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const error = RpcResponse.parseError({ code: -32000, message: 'unsupported method' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - Error.\n * @returns RPC Error instance.\n */\nexport function parseError<const error extends Error | ErrorObject | unknown>(\n  error: error | Error | ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = error as Error | ErrorObject\n\n  if (error_ instanceof Error && !('code' in error_))\n    return new InternalError({\n      cause: error_,\n      data: error_,\n      message: error_.message,\n      stack: error_.stack,\n    }) as never\n\n  const { code } = error_\n  if (code === InternalError.code)\n    return new InternalError(error_ as never) as never\n  if (code === InvalidInputError.code)\n    return new InvalidInputError(error_) as never\n  if (code === InvalidParamsError.code)\n    return new InvalidParamsError(error_) as never\n  if (code === InvalidRequestError.code)\n    return new InvalidRequestError(error_) as never\n  if (code === LimitExceededError.code)\n    return new LimitExceededError(error_) as never\n  if (code === MethodNotFoundError.code)\n    return new MethodNotFoundError(error_) as never\n  if (code === MethodNotSupportedError.code)\n    return new MethodNotSupportedError(error_) as never\n  if (code === ParseError.code) return new ParseError(error_) as never\n  if (code === ResourceNotFoundError.code)\n    return new ResourceNotFoundError(error_) as never\n  if (code === ResourceUnavailableError.code)\n    return new ResourceUnavailableError(error_) as never\n  if (code === TransactionRejectedError.code)\n    return new TransactionRejectedError(error_) as never\n  if (code === VersionNotSupportedError.code)\n    return new VersionNotSupportedError(error_) as never\n  return new InternalError({\n    cause: error_ instanceof Error ? error_ : undefined,\n    data: error_,\n    message: error_.message,\n    stack: error_ instanceof Error ? error_.stack : undefined,\n  }) as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends ErrorObject | unknown,\n    //\n    error = errorObject extends ErrorObject\n      ?\n          | (errorObject['code'] extends InternalError['code']\n              ? InternalError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InternalError\n              : never)\n          | (errorObject['code'] extends InvalidInputError['code']\n              ? InvalidInputError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidInputError\n              : never)\n          | (errorObject['code'] extends ResourceNotFoundError['code']\n              ? ResourceNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceNotFoundError\n              : never)\n          | (errorObject['code'] extends ResourceUnavailableError['code']\n              ? ResourceUnavailableError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceUnavailableError\n              : never)\n          | (errorObject['code'] extends TransactionRejectedError['code']\n              ? TransactionRejectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? TransactionRejectedError\n              : never)\n          | (errorObject['code'] extends ParseError['code']\n              ? ParseError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ParseError\n              : never)\n          | (errorObject['code'] extends MethodNotSupportedError['code']\n              ? MethodNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotSupportedError\n              : never)\n          | (errorObject['code'] extends LimitExceededError['code']\n              ? LimitExceededError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? LimitExceededError\n              : never)\n          | (errorObject['code'] extends VersionNotSupportedError['code']\n              ? VersionNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? VersionNotSupportedError\n              : never)\n          | (errorObject['code'] extends InvalidRequestError['code']\n              ? InvalidRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidRequestError\n              : never)\n          | (errorObject['code'] extends MethodNotFoundError['code']\n              ? MethodNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotFoundError\n              : never)\n          | (errorObject['code'] extends InvalidParamsError['code']\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BaseError\n              : never)\n      : parseError.ReturnType<ErrorObject>,\n  > = IsNever<error> extends true ? BaseError : error\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\n\n/** Thrown when a JSON-RPC error has occurred. */\nexport class BaseError extends Error {\n  override name = 'RpcResponse.BaseError'\n\n  override readonly cause: Error | undefined\n  override readonly stack: string\n  readonly code: number\n  readonly data?: unknown | undefined\n\n  constructor(\n    errorObject: ErrorObject & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    },\n  ) {\n    const { cause, code, message, data, stack } = errorObject\n\n    super(message, { cause })\n\n    this.cause = cause\n    this.code = code\n    this.data = data\n    this.stack = stack ?? ''\n  }\n}\n\n/** Thrown when the input to a JSON-RPC method is invalid. */\nexport class InvalidInputError extends BaseError {\n  static readonly code = -32000\n  override readonly code = -32000\n  override readonly name = 'RpcResponse.InvalidInputError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidInputError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Missing or invalid parameters.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is not found. */\nexport class ResourceNotFoundError extends BaseError {\n  static readonly code = -32001\n  override readonly code = -32001\n  override readonly name = 'RpcResponse.ResourceNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not found.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is unavailable. */\nexport class ResourceUnavailableError extends BaseError {\n  static readonly code = -32002\n  override readonly code = -32002\n  override readonly name = 'RpcResponse.ResourceUnavailableError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceUnavailableError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not available.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC transaction is rejected. */\nexport class TransactionRejectedError extends BaseError {\n  static readonly code = -32003\n  override readonly code = -32003\n  override readonly name = 'RpcResponse.TransactionRejectedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: TransactionRejectedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Transaction creation failed.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not supported. */\nexport class MethodNotSupportedError extends BaseError {\n  static readonly code = -32004\n  override readonly code = -32004\n  override readonly name = 'RpcResponse.MethodNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method is not implemented.',\n    })\n  }\n}\n\n/** Thrown when a rate-limit is exceeded. */\nexport class LimitExceededError extends BaseError {\n  static readonly code = -32005\n  override readonly code = -32005\n  override readonly name = 'RpcResponse.LimitExceededError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: LimitExceededError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Rate limit exceeded.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC version is not supported. */\nexport class VersionNotSupportedError extends BaseError {\n  static readonly code = -32006\n  override readonly code = -32006\n  override readonly name = 'RpcResponse.VersionNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: VersionNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'JSON-RPC version not supported.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC request is invalid. */\nexport class InvalidRequestError extends BaseError {\n  static readonly code = -32600\n  override readonly code = -32600\n  override readonly name = 'RpcResponse.InvalidRequestError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidRequestError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Input is not a valid JSON-RPC request.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not found. */\nexport class MethodNotFoundError extends BaseError {\n  static readonly code = -32601\n  override readonly code = -32601\n  override readonly name = 'RpcResponse.MethodNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method does not exist.',\n    })\n  }\n}\n\n/** Thrown when the parameters to a JSON-RPC method are invalid. */\nexport class InvalidParamsError extends BaseError {\n  static readonly code = -32602\n  override readonly code = -32602\n  override readonly name = 'RpcResponse.InvalidParamsError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidParamsError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Invalid method parameters.',\n    })\n  }\n}\n\n/** Thrown when an internal JSON-RPC error has occurred. */\nexport class InternalError extends BaseError {\n  static readonly code = -32603\n  override readonly code = -32603\n  override readonly name = 'RpcResponse.InternalError'\n\n  constructor(\n    parameters: Partial<Omit<ErrorObject, 'code'>> & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    } = {},\n  ) {\n    super({\n      cause: parameters.cause,\n      code: InternalError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Internal JSON-RPC error.',\n      stack: parameters.stack,\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC response is invalid. */\nexport class ParseError extends BaseError {\n  static readonly code = -32700\n  override readonly code = -32700\n  override readonly name = 'RpcResponse.ParseError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ParseError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Failed to parse JSON-RPC response.',\n    })\n  }\n}\n", "import { EventEmitter } from 'eventemitter3'\nimport type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute, IsNarrowable, IsNever } from './internal/types.js'\nimport * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Options for a {@link ox#Provider.Provider}. */\nexport type Options = {\n  /**\n   * RPC Schema to use for the Provider's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Generic`\n   */\n  schema?: RpcSchema.Generic | undefined\n}\n\n/** Root type for an EIP-1193 Provider. */\nexport type Provider<\n  options extends Options | undefined = undefined,\n  eventMap extends boolean | Record<string, unknown> = false,\n  ///\n  _schema extends RpcSchema.Generic = options extends {\n    schema: infer schema extends RpcSchema.Generic\n  }\n    ? schema\n    : RpcSchema.Default,\n> = Compute<\n  {\n    request: RequestFn<_schema>\n  } & (\n    | (eventMap extends true ? Emitter<EventMap> : never)\n    | (eventMap extends false ? Partial<Emitter<EventMap>> : never)\n    | (eventMap extends Record<string, unknown> ? Emitter<eventMap> : never)\n  )\n>\n\n/** Type for an EIP-1193 Provider's event emitter. */\nexport type Emitter<\n  eventMap extends Record<string, unknown> | undefined = undefined,\n> = Compute<EventEmitter<EventMap<eventMap>>>\n\n/** EIP-1193 Provider's `request` function. */\nexport type RequestFn<schema extends RpcSchema.Generic = RpcSchema.Generic> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n>(\n  parameters: RpcSchema_internal.ExtractRequestOpaque<schema, methodName>,\n) => Promise<RpcSchema.ExtractReturnType<schema, methodName>>\n\nexport type ConnectInfo = {\n  chainId: string\n}\n\nexport type Message = {\n  type: string\n  data: unknown\n}\n\nexport class ProviderRpcError extends Error {\n  override name = 'ProviderRpcError'\n\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\nexport type EventMap<\n  eventMap extends Record<string, unknown> | undefined = undefined,\n> = {\n  accountsChanged: (accounts: readonly Address.Address[]) => void\n  chainChanged: (chainId: string) => void\n  connect: (connectInfo: ConnectInfo) => void\n  disconnect: (error: ProviderRpcError) => void\n  message: (message: Message) => void\n} & (eventMap extends Record<string, unknown> ? eventMap : {})\n\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static readonly code = 4001\n  override readonly code = 4001\n  override readonly name = 'Provider.UserRejectedRequestError'\n\n  constructor({\n    message = 'The user rejected the request.',\n  }: { message?: string | undefined } = {}) {\n    super(4001, message)\n  }\n}\n\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  static readonly code = 4100\n  override readonly code = 4100\n  override readonly name = 'Provider.UnauthorizedError'\n\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.',\n  }: { message?: string | undefined } = {}) {\n    super(4100, message)\n  }\n}\n\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  static readonly code = 4200\n  override readonly code = 4200\n  override readonly name = 'Provider.UnsupportedMethodError'\n\n  constructor({\n    message = 'The provider does not support the requested method.',\n  }: { message?: string | undefined } = {}) {\n    super(4200, message)\n  }\n}\n\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  static readonly code = 4900\n  override readonly code = 4900\n  override readonly name = 'Provider.DisconnectedError'\n\n  constructor({\n    message = 'The provider is disconnected from all chains.',\n  }: { message?: string | undefined } = {}) {\n    super(4900, message)\n  }\n}\n\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static readonly code = 4901\n  override readonly code = 4901\n  override readonly name = 'Provider.ChainDisconnectedError'\n\n  constructor({\n    message = 'The provider is not connected to the requested chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4901, message)\n  }\n}\n\n/** An error occurred when attempting to switch chain. */\nexport class SwitchChainError extends ProviderRpcError {\n  static readonly code = 4902\n  override readonly code = 4902\n  override readonly name = 'Provider.SwitchChainError'\n\n  constructor({\n    message = 'An error occurred when attempting to switch chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4902, message)\n  }\n}\n\n/** This Wallet does not support a capability that was not marked as optional. */\nexport class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\n  static readonly code = 5700\n  override readonly code = 5700\n  override readonly name = 'Provider.UnsupportedNonOptionalCapabilityError'\n\n  constructor({\n    message = 'This Wallet does not support a capability that was not marked as optional.',\n  }: { message?: string | undefined } = {}) {\n    super(5700, message)\n  }\n}\n\n/** This Wallet does not support the requested chain ID. */\nexport class UnsupportedChainIdError extends ProviderRpcError {\n  static readonly code = 5710\n  override readonly code = 5710\n  override readonly name = 'Provider.UnsupportedChainIdError'\n\n  constructor({\n    message = 'This Wallet does not support the requested chain ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5710, message)\n  }\n}\n\n/** There is already a bundle submitted with this ID. */\nexport class DuplicateIdError extends ProviderRpcError {\n  static readonly code = 5720\n  override readonly code = 5720\n  override readonly name = 'Provider.DuplicateIdError'\n\n  constructor({\n    message = 'There is already a bundle submitted with this ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5720, message)\n  }\n}\n\n/** This bundle id is unknown / has not been submitted. */\nexport class UnknownBundleIdError extends ProviderRpcError {\n  static readonly code = 5730\n  override readonly code = 5730\n  override readonly name = 'Provider.UnknownBundleIdError'\n\n  constructor({\n    message = 'This bundle id is unknown / has not been submitted.',\n  }: { message?: string | undefined } = {}) {\n    super(5730, message)\n  }\n}\n\n/** The call bundle is too large for the Wallet to process. */\nexport class BundleTooLargeError extends ProviderRpcError {\n  static readonly code = 5740\n  override readonly code = 5740\n  override readonly name = 'Provider.BundleTooLargeError'\n\n  constructor({\n    message = 'The call bundle is too large for the Wallet to process.',\n  }: { message?: string | undefined } = {}) {\n    super(5740, message)\n  }\n}\n\n/** The Wallet can support atomicity after an upgrade, but the user rejected the upgrade. */\nexport class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\n  static readonly code = 5750\n  override readonly code = 5750\n  override readonly name = 'Provider.AtomicReadyWalletRejectedUpgradeError'\n\n  constructor({\n    message = 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',\n  }: { message?: string | undefined } = {}) {\n    super(5750, message)\n  }\n}\n\n/** The wallet does not support atomic execution but the request requires it. */\nexport class AtomicityNotSupportedError extends ProviderRpcError {\n  static readonly code = 5760\n  override readonly code = 5760\n  override readonly name = 'Provider.AtomicityNotSupportedError'\n\n  constructor({\n    message = 'The wallet does not support atomic execution but the request requires it.',\n  }: { message?: string | undefined } = {}) {\n    super(5760, message)\n  }\n}\n\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter<\n  eventMap extends Record<string, unknown> = Record<string, unknown>,\n>(): Emitter<eventMap> {\n  const emitter = new EventEmitter<EventMap<eventMap>>()\n\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter)\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter)\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter)\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter),\n  }\n}\n\nexport declare namespace createEmitter {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) {@link ox#Provider.Provider}\n * from an arbitrary [EIP-1193 Provider](https://eips.ethereum.org/EIPS/eip-1193) interface.\n *\n * @example\n * ### Instantiating with RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating with External Providers\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from an\n * external EIP-1193 Provider like `window.ethereum`.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating a Custom Provider\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from a\n * HTTP `fetch` JSON-RPC request. You can use this pattern to integrate with any asynchronous JSON-RPC\n * transport, including WebSockets and IPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.(from:function)} type.\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * The example below demonstrates how to instantiate a Provider with your own EIP-1193 flavored event emitter.\n *\n * This example is useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @param provider - The EIP-1193 provider to convert.\n * @returns An typed EIP-1193 Provider.\n */\nexport function from<\n  options extends Options | undefined,\n  //\n  provider extends from.Value<options> | undefined = undefined,\n>(\n  provider: provider | from.Value<options> | undefined,\n  options?: options | Options,\n): from.ReturnType<options, provider>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider: any, _options: Options = {}): Provider {\n  if (!provider) throw new IsUndefinedError()\n  return {\n    ...provider,\n    async request(args) {\n      try {\n        const result = await provider.request(args)\n        if (\n          result &&\n          typeof result === 'object' &&\n          'jsonrpc' in (result as { jsonrpc?: unknown })\n        )\n          return RpcResponse.parse(result) as never\n        return result\n      } catch (error) {\n        throw parseError(error)\n      }\n    },\n  }\n}\n\nexport declare namespace from {\n  type Value<options extends Options | undefined = undefined> = Partial<\n    Emitter<any>\n  > & {\n    request: (\n      parameters: options extends {\n        schema: infer schema extends RpcSchema.Generic\n      }\n        ? schema['Request']\n        : RpcSchema.Generic['Request'],\n    ) => unknown\n  }\n\n  type ReturnType<\n    options extends Options | undefined = Options | undefined,\n    provider extends from.Value<options> | undefined =\n      | from.Value<options>\n      | undefined,\n  > = Omit<provider, 'request'> & {\n    request: RequestFn<\n      options extends { schema: infer schema extends RpcSchema.Generic }\n        ? schema\n        : RpcSchema.Default\n    >\n  }\n\n  type ErrorType = IsUndefinedError | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a Provider error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError<\n  const error extends RpcResponse.ErrorObject | Error | unknown,\n>(\n  error: error | Error | RpcResponse.ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = RpcResponse.parseError(error)\n  if (error_ instanceof RpcResponse.InternalError) {\n    if (!error_.data) return error_ as never\n\n    const { code } = error_.data as RpcResponse.ErrorObject\n    if (code === DisconnectedError.code)\n      return new DisconnectedError(error_) as never\n    if (code === ChainDisconnectedError.code)\n      return new ChainDisconnectedError(error_) as never\n    if (code === UserRejectedRequestError.code)\n      return new UserRejectedRequestError(error_) as never\n    if (code === UnauthorizedError.code)\n      return new UnauthorizedError(error_) as never\n    if (code === UnsupportedMethodError.code)\n      return new UnsupportedMethodError(error_) as never\n    if (code === SwitchChainError.code)\n      return new SwitchChainError(error_) as never\n    if (code === AtomicReadyWalletRejectedUpgradeError.code)\n      return new AtomicReadyWalletRejectedUpgradeError(error_) as never\n    if (code === AtomicityNotSupportedError.code)\n      return new AtomicityNotSupportedError(error_) as never\n    if (code === BundleTooLargeError.code)\n      return new BundleTooLargeError(error_) as never\n    if (code === UnknownBundleIdError.code)\n      return new UnknownBundleIdError(error_) as never\n    if (code === DuplicateIdError.code)\n      return new DuplicateIdError(error_) as never\n    if (code === UnsupportedChainIdError.code)\n      return new UnsupportedChainIdError(error_) as never\n    if (code === UnsupportedNonOptionalCapabilityError.code)\n      return new UnsupportedNonOptionalCapabilityError(error_) as never\n  }\n  return error_ as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends RpcResponse.ErrorObject | unknown,\n    //\n    error = errorObject extends RpcResponse.ErrorObject\n      ?\n          | (errorObject['code'] extends DisconnectedError['code']\n              ? DisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DisconnectedError\n              : never)\n          | (errorObject['code'] extends ChainDisconnectedError['code']\n              ? ChainDisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ChainDisconnectedError\n              : never)\n          | (errorObject['code'] extends UserRejectedRequestError['code']\n              ? UserRejectedRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UserRejectedRequestError\n              : never)\n          | (errorObject['code'] extends UnauthorizedError['code']\n              ? UnauthorizedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnauthorizedError\n              : never)\n          | (errorObject['code'] extends UnsupportedMethodError['code']\n              ? UnsupportedMethodError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedMethodError\n              : never)\n          | (errorObject['code'] extends SwitchChainError['code']\n              ? SwitchChainError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? SwitchChainError\n              : never)\n          | (errorObject['code'] extends AtomicReadyWalletRejectedUpgradeError['code']\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (errorObject['code'] extends AtomicityNotSupportedError['code']\n              ? AtomicityNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicityNotSupportedError\n              : never)\n          | (errorObject['code'] extends BundleTooLargeError['code']\n              ? BundleTooLargeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BundleTooLargeError\n              : never)\n          | (errorObject['code'] extends UnknownBundleIdError['code']\n              ? UnknownBundleIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnknownBundleIdError\n              : never)\n          | (errorObject['code'] extends DuplicateIdError['code']\n              ? DuplicateIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DuplicateIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedChainIdError['code']\n              ? UnsupportedChainIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedChainIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedNonOptionalCapabilityError['code']\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n      : RpcResponse.parseError.ReturnType<RpcResponse.ErrorObject>,\n  > = IsNever<error> extends true\n    ? RpcResponse.parseError.ReturnType<errorObject>\n    : error\n}\n\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  override readonly name = 'Provider.IsUndefinedError'\n\n  constructor() {\n    super('`provider` is undefined.')\n  }\n}\n", "import type { Errors } from '../index.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute } from './internal/types.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** A JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcRequest<schema extends RpcSchema.Generic = RpcSchema.Generic> =\n  Compute<\n    schema extends any\n      ? schema['Request'] & {\n          id: number\n          jsonrpc: '2.0'\n          /** @deprecated internal */\n          _returnType: schema['ReturnType']\n        }\n      : never\n  >\n\n/** JSON-RPC request store type. */\nexport type Store<schema extends RpcSchema.Generic | undefined = undefined> =\n  Compute<{\n    prepare: <methodName extends RpcSchema.MethodNameGeneric>(\n      parameters: Compute<\n        schema extends RpcSchema.Generic\n          ? RpcSchema.ExtractRequest<schema, methodName>\n          : RpcSchema_internal.ExtractRequestOpaque<\n              RpcSchema.Default,\n              methodName\n            >\n      >,\n    ) => Compute<\n      RpcRequest<\n        RpcSchema.ExtractItem<\n          schema extends RpcSchema.Generic ? schema : RpcSchema.Default,\n          methodName\n        >\n      >\n    >\n    readonly id: number\n  }>\n\n/**\n * Creates a JSON-RPC request store to build requests with an incrementing `id`.\n *\n * Returns a type-safe `prepare` function to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using {@link ox#RpcSchema.from}.\n *\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * const schema = RpcSchema.from<{ // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobar' // [!code focus]\n *     params: [number] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * } | { // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobaz' // [!code focus]\n *     params: [string] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * }>() // [!code focus]\n *\n * const store = RpcRequest.createStore({ schema }) // [!code focus]\n *\n * const request = store.prepare({\n *   method: 'eth_foobar', // [!code focus]\n *   // ^?\n *   params: [42],\n * })\n * ```\n *\n * @param options - Request store options.\n * @returns The request store\n */\nexport function createStore<\n  schema extends RpcSchema.Generic | undefined = undefined,\n>(options: createStore.Options<schema> = {}): createStore.ReturnType<schema> {\n  let id = options.id ?? 0\n  return {\n    prepare(options) {\n      return from({\n        id: id++,\n        ...options,\n      } as never) as never\n    },\n    get id() {\n      return id\n    },\n  }\n}\n\nexport declare namespace createStore {\n  type Options<schema extends RpcSchema.Generic | undefined = undefined> = {\n    /** The initial request ID. */\n    id?: number\n    /** RPC Schema to use for the request store. */\n    schema?: schema | RpcSchema.Generic | undefined\n  }\n\n  type ReturnType<schema extends RpcSchema.Generic | undefined = undefined> =\n    Store<schema>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * A type-safe interface to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * :::warning\n *\n * You will likely want to use {@link ox#RpcRequest.(createStore:function)} instead as it will also manage `id`s and uses this function internally.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Build a request object.\n * const request = RpcRequest.from({ // [!code focus]\n *   id: 0, // [!code focus]\n *   method: 'eth_estimateGas', // [!code focus]\n *   params: [ // [!code focus]\n *     { // [!code focus]\n *       from: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]\n *       to: '0x0D44f617435088c947F00B31160f64b074e412B4', // [!code focus]\n *       value: '0x69420', // [!code focus]\n *     }, // [!code focus]\n *   ], // [!code focus]\n * }) // [!code focus]\n *\n * // 2. Send the JSON-RPC request via HTTP.\n * const gas = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 3. Parse the JSON-RPC response into a type-safe result.\n *  .then((response) => RpcResponse.parse(response, { request }))\n * ```\n *\n * @param options - JSON-RPC request options.\n * @returns The fully-formed JSON-RPC request object.\n */\nexport function from<methodName extends RpcSchema.MethodNameGeneric>(\n  options: from.Options<methodName>,\n): from.ReturnType<methodName> {\n  return {\n    ...options,\n    jsonrpc: '2.0',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcSchema_internal.ExtractRequestOpaque<RpcSchema.Default, methodName> & {\n      id: number\n    }\n  >\n\n  type ReturnType<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcRequest<RpcSchema.ExtractItem<RpcSchema.Default, methodName>>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as Address from 'ox/Address'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport * as Provider from 'ox/Provider'\nimport * as RpcRequest from 'ox/RpcRequest'\nimport type { LocalAccount } from '../accounts/types.js'\nimport { getTransactionReceipt } from '../actions/public/getTransactionReceipt.js'\nimport { sendTransaction } from '../actions/wallet/sendTransaction.js'\nimport { sendTransactionSync } from '../actions/wallet/sendTransactionSync.js'\nimport { createClient } from '../clients/createClient.js'\nimport {\n  createTransport,\n  type Transport,\n} from '../clients/transports/createTransport.js'\nimport type { Chain } from '../types/chain.js'\nimport type { ChainConfig } from './chainConfig.js'\nimport * as Transaction from './Transaction.js'\n\nexport type FeePayer = Transport<typeof withFeePayer.type>\n\n/**\n * Creates a fee payer transport that routes requests between\n * the default transport or the fee payer transport.\n *\n * The policy parameter controls how the fee payer handles transactions:\n * - `'sign-only'`: Fee payer co-signs the transaction and returns it to the client transport, which then broadcasts it via the default transport\n * - `'sign-and-broadcast'`: Fee payer co-signs and broadcasts the transaction directly\n *\n * @param defaultTransport - The default transport to use.\n * @param feePayerTransport - The fee payer transport to use.\n * @param parameters - Configuration parameters.\n * @returns A relay transport.\n */\nexport function withFeePayer(\n  defaultTransport: Transport,\n  relayTransport: Transport,\n  parameters?: withFeePayer.Parameters,\n): withFeePayer.ReturnValue {\n  const { policy = 'sign-only' } = parameters ?? {}\n\n  return (config) => {\n    const transport_default = defaultTransport(config)\n    const transport_relay = relayTransport(config)\n\n    return createTransport({\n      key: withFeePayer.type,\n      name: 'Relay Proxy',\n      async request({ method, params }, options) {\n        if (\n          method === 'eth_sendRawTransactionSync' ||\n          method === 'eth_sendRawTransaction'\n        ) {\n          const serialized = (params as any)[0] as `0x76${string}`\n          const transaction = Transaction.deserialize(serialized)\n\n          // If the transaction is intended to be sponsored, forward it to the relay.\n          if (transaction.feePayerSignature === null) {\n            // For 'sign-and-broadcast', relay signs and broadcasts\n            if (policy === 'sign-and-broadcast')\n              return transport_relay.request(\n                { method, params },\n                options,\n              ) as never\n\n            // For 'sign-only', request signature from relay using eth_signRawTransaction\n            {\n              // Request signature from relay using eth_signRawTransaction\n              const signedTransaction = await transport_relay.request(\n                {\n                  method: 'eth_signRawTransaction',\n                  params: [serialized],\n                },\n                options,\n              )\n\n              // Broadcast the signed transaction via the default transport\n              return transport_default.request(\n                { method, params: [signedTransaction] },\n                options,\n              ) as never\n            }\n          }\n        }\n        return transport_default.request({ method, params }, options) as never\n      },\n      type: withFeePayer.type,\n    })\n  }\n}\n\nexport declare namespace withFeePayer {\n  export const type = 'feePayer'\n\n  export type Parameters = {\n    /** Policy for how the fee payer should handle transactions. Defaults to `'sign-only'`. */\n    policy?: 'sign-only' | 'sign-and-broadcast' | undefined\n  }\n\n  export type ReturnValue = FeePayer\n}\n\n/**\n * Creates a transport that instruments a compatibility layer for\n * `wallet_` RPC actions (`sendCalls`, `getCallsStatus`, etc).\n *\n * @param transport - Transport to wrap.\n * @returns Transport.\n */\nexport function walletNamespaceCompat(\n  transport: Transport,\n  options: walletNamespaceCompat.Parameters,\n): Transport {\n  const { account } = options\n\n  const sendCallsMagic = Hash.keccak256(Hex.fromString('TEMPO_5792'))\n\n  return (options) => {\n    const t = transport(options)\n\n    const chain = options.chain as Chain & ChainConfig\n\n    return {\n      ...t,\n      async request(args: never) {\n        const request = RpcRequest.from(args)\n\n        const client = createClient({\n          chain,\n          transport,\n        })\n\n        if (request.method === 'wallet_sendCalls') {\n          const params = request.params[0] ?? {}\n          const { capabilities, chainId, from } = params\n          const { sync } = capabilities ?? {}\n\n          if (!chainId) throw new Provider.UnsupportedChainIdError()\n          if (Number(chainId) !== client.chain.id)\n            throw new Provider.UnsupportedChainIdError()\n          if (from && !Address.isEqual(from, account.address))\n            throw new Provider.DisconnectedError()\n\n          const calls = (params.calls ?? []).map((call) => ({\n            to: call.to,\n            value: call.value ? BigInt(call.value) : undefined,\n            data: call.data,\n          }))\n\n          const hash = await (async () => {\n            if (!sync)\n              return sendTransaction(client, {\n                account,\n                calls,\n              })\n\n            const { transactionHash } = await sendTransactionSync(client, {\n              account,\n              calls,\n            })\n            return transactionHash\n          })()\n\n          const id = Hex.concat(hash, Hex.padLeft(chainId, 32), sendCallsMagic)\n\n          return {\n            capabilities: { sync },\n            id,\n          }\n        }\n\n        if (request.method === 'wallet_getCallsStatus') {\n          const [id] = request.params ?? []\n          if (!id) throw new Error('`id` not found')\n          if (!id.endsWith(sendCallsMagic.slice(2)))\n            throw new Error('`id` not supported')\n          Hex.assert(id)\n\n          const hash = Hex.slice(id, 0, 32)\n          const chainId = Hex.slice(id, 32, 64)\n\n          const receipt = await getTransactionReceipt(client, { hash })\n          return {\n            atomic: true,\n            chainId: Number(chainId),\n            id,\n            receipts: [receipt],\n            status: receipt.status === 'success' ? 200 : 500,\n            version: '2.0.0',\n          }\n        }\n\n        return t.request(args)\n      },\n    } as never\n  }\n}\n\nexport declare namespace walletNamespaceCompat {\n  export type Parameters = {\n    account: LocalAccount\n  }\n}\n", "import * as Bytes from 'ox/Bytes'\nimport type * as Hex from 'ox/Hex'\nimport * as PublicKey from 'ox/PublicKey'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\n\nexport type P256Credential = {\n  id: WebAuthnP256.P256Credential['id']\n  publicKey: Hex.Hex\n  raw: WebAuthnP256.P256Credential['raw']\n}\n\n/**\n * Creates a WebAuthn credential (ie. a passkey).\n *\n * This function returns the credential object, which includes the public key.\n * It is recommended to store the public key against the credential in an external store\n * as it is not possible to extract a public key from a credential after it has been created.\n *\n * @example\n * ```ts\n * import { WebAuthnP256 } from 'tempo.ts/viem'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n * // {\n * //   id: 'oZ48...',\n * //   publicKey: '0x...',\n * // }\n * ```\n *\n * @param parameters WebAuthnP256 createCredential options.\n * @returns WebAuthn credential.\n */\nexport async function createCredential(\n  parameters: createCredential.Parameters,\n): Promise<createCredential.ReturnValue> {\n  const { createFn, label, rpId, userId } = parameters\n  const credential = await WebAuthnP256.createCredential({\n    ...parameters,\n    authenticatorSelection: {\n      ...parameters.authenticatorSelection,\n      requireResidentKey: true,\n      residentKey: 'required',\n      userVerification: 'required',\n    },\n    createFn,\n    extensions: {\n      ...parameters.extensions,\n      credProps: true,\n    },\n    rp: rpId\n      ? {\n          id: rpId,\n          name: rpId,\n        }\n      : undefined,\n    name: undefined as never,\n    user: {\n      displayName: label,\n      id: new Uint8Array(userId ?? Bytes.fromString(label)),\n      name: label,\n    },\n  })\n  return {\n    id: credential.id,\n    publicKey: PublicKey.toHex(credential.publicKey, {\n      includePrefix: false,\n    }),\n    raw: credential.raw,\n  }\n}\n\nexport declare namespace createCredential {\n  export type Parameters = Omit<\n    WebAuthnP256.createCredential.Options,\n    'rp' | 'user'\n  > & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?: WebAuthnP256.createCredential.Options['createFn'] | undefined\n    /** Label. */\n    label: string\n    /** Relying Party ID. */\n    rpId?: string | undefined\n    /** User ID. */\n    userId?: Bytes.Bytes | undefined\n  }\n\n  export type ReturnValue = P256Credential\n}\n\n/**\n * Gets a WebAuthn credential (ie. a passkey), and optionally signs over a digest/hash.\n *\n * A `getPublicKey` function is required to fetch the public key paired with the credential\n * from an external store. It is not possible to extract a public key from a credential after\n * the credential has been created with `WebAuthnP256.createCredential`.\n *\n * @example\n * ```ts\n * import { WebAuthnP256 } from 'tempo.ts/viem'\n *\n * const credential = await WebAuthnP256.getCredential({\n *   async getPublicKey(credential) {\n *     // Get public key from store\n *     return store.getPublicKey(credential.id)\n *   }\n * })\n * ```\n *\n * @param parameters WebAuthnP256 getCredential options.\n * @returns WebAuthn credential.\n */\nexport async function getCredential(\n  parameters: getCredential.Parameters,\n): Promise<getCredential.ReturnValue> {\n  const { metadata, raw, signature } = await WebAuthnP256.sign({\n    ...parameters,\n    challenge: parameters.hash ?? '0x',\n  })\n  const publicKey = await parameters.getPublicKey(raw)\n  return {\n    id: raw.id,\n    metadata,\n    publicKey,\n    raw,\n    signature,\n  }\n}\n\nexport declare namespace getCredential {\n  export type Parameters = Omit<WebAuthnP256.sign.Options, 'challenge'> & {\n    hash?: Hex.Hex | undefined\n    getPublicKey: (\n      credential: WebAuthnP256.P256Credential['raw'],\n    ) => Promise<Hex.Hex>\n  }\n\n  export type ReturnValue = WebAuthnP256.sign.ReturnType & {\n    id: string\n    publicKey: Hex.Hex\n  }\n}\n", "// biome-ignore lint/performance/noBarrelFile: _\nexport { createKeyPair } from 'ox/WebCryptoP256'\n", "import type * as Query from '@tanstack/query-core'\nimport { type Config, getConnectorClient } from '@wagmi/core'\nimport type { ChainIdParameter, ConnectorParameter } from '@wagmi/core/internal'\nimport type { Account } from 'viem'\nimport { Actions } from 'viem/tempo'\nimport type { PartialBy, RequiredBy, UnionOmit } from '../../internal/types.js'\n\n/**\n * Buys a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.buy(config, {\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n *   amountOut: parseUnits('100', 6),\n *   maxAmountIn: parseUnits('105', 6),\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function buy<config extends Config>(\n  config: config,\n  parameters: buy.Parameters<config>,\n): Promise<Actions.dex.buy.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.buy(client, parameters as never)\n}\n\nexport declare namespace buy {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.buy.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.buy.ReturnValue\n\n  export type ErrorType = Actions.dex.buy.ErrorType\n}\n\n/**\n * Buys a specific amount of tokens.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.buySync(config, {\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n *   amountOut: parseUnits('100', 6),\n *   maxAmountIn: parseUnits('105', 6),\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function buySync<config extends Config>(\n  config: config,\n  parameters: buySync.Parameters<config>,\n): Promise<Actions.dex.buySync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.buySync(client, parameters as never)\n}\n\nexport declare namespace buySync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.buySync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.buySync.ReturnValue\n\n  export type ErrorType = Actions.dex.buySync.ErrorType\n}\n\n/**\n * Cancels an order from the orderbook.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.cancel(config, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function cancel<config extends Config>(\n  config: config,\n  parameters: cancel.Parameters<config>,\n): Promise<Actions.dex.cancel.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.cancel(client, parameters as never)\n}\n\nexport declare namespace cancel {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.cancel.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.cancel.ReturnValue\n\n  export type ErrorType = Actions.dex.cancel.ErrorType\n}\n\n/**\n * Cancels an order from the orderbook.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.cancelSync(config, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function cancelSync<config extends Config>(\n  config: config,\n  parameters: cancelSync.Parameters<config>,\n): Promise<Actions.dex.cancelSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.cancelSync(client, parameters as never)\n}\n\nexport declare namespace cancelSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.cancelSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.cancelSync.ReturnValue\n\n  export type ErrorType = Actions.dex.cancelSync.ErrorType\n}\n\n/**\n * Creates a new trading pair on the DEX.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.createPair(config, {\n *   base: '0x20c...11',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function createPair<config extends Config>(\n  config: config,\n  parameters: createPair.Parameters<config>,\n): Promise<Actions.dex.createPair.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.createPair(client, parameters as never)\n}\n\nexport declare namespace createPair {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.createPair.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.createPair.ReturnValue\n\n  export type ErrorType = Actions.dex.createPair.ErrorType\n}\n\n/**\n * Creates a new trading pair on the DEX.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.createPairSync(config, {\n *   base: '0x20c...11',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createPairSync<config extends Config>(\n  config: config,\n  parameters: createPairSync.Parameters<config>,\n): Promise<Actions.dex.createPairSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.createPairSync(client, parameters as never)\n}\n\nexport declare namespace createPairSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.createPairSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.createPairSync.ReturnValue\n\n  export type ErrorType = Actions.dex.createPairSync.ErrorType\n}\n\n/**\n * Gets a user's token balance on the DEX.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const balance = await Actions.dex.getBalance(config, {\n *   account: '0x...',\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The user's token balance on the DEX.\n */\nexport function getBalance<config extends Config>(\n  config: config,\n  parameters: getBalance.Parameters<config>,\n): Promise<getBalance.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.getBalance(client, rest)\n}\n\nexport namespace getBalance {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.getBalance.Parameters\n\n  export type ReturnValue = Actions.dex.getBalance.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: PartialBy<Parameters<config>, 'account'>,\n  ) {\n    return ['getBalance', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, { account, ...parameters }] = queryKey\n        if (!account) throw new Error('account is required.')\n        return await getBalance(config, { account, ...parameters })\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getBalance.ReturnValue,\n    > = PartialBy<getBalance.Parameters<config>, 'account'> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getBalance.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getBalance.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getBalance.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets the quote for buying a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const amountIn = await Actions.dex.getBuyQuote(config, {\n *   amountOut: parseUnits('100', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The amount of tokenIn needed to buy the specified amountOut.\n */\nexport function getBuyQuote<config extends Config>(\n  config: config,\n  parameters: getBuyQuote.Parameters<config>,\n): Promise<getBuyQuote.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.getBuyQuote(client, rest)\n}\n\nexport namespace getBuyQuote {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.getBuyQuote.Parameters\n\n  export type ReturnValue = Actions.dex.getBuyQuote.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getBuyQuote', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getBuyQuote(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getBuyQuote.ReturnValue,\n    > = getBuyQuote.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getBuyQuote.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getBuyQuote.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getBuyQuote.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets an order's details from the orderbook.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const order = await Actions.dex.getOrder(config, {\n *   orderId: 123n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The order details.\n */\nexport function getOrder<config extends Config>(\n  config: config,\n  parameters: getOrder.Parameters<config>,\n): Promise<getOrder.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.getOrder(client, rest)\n}\n\nexport namespace getOrder {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.getOrder.Parameters\n\n  export type ReturnValue = Actions.dex.getOrder.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getOrder', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getOrder(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getOrder.ReturnValue,\n    > = getOrder.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getOrder.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getOrder.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getOrder.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets orderbook information for a trading pair.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const book = await Actions.dex.getOrderbook(config, {\n *   base: '0x20c...11',\n *   quote: '0x20c...20',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The orderbook information.\n */\nexport function getOrderbook<config extends Config>(\n  config: config,\n  parameters: getOrderbook.Parameters<config>,\n): Promise<getOrderbook.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.getOrderbook(client, rest)\n}\n\nexport namespace getOrderbook {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.getOrderbook.Parameters\n\n  export type ReturnValue = Actions.dex.getOrderbook.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getOrderbook', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getOrderbook(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getOrderbook.ReturnValue,\n    > = getOrderbook.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getOrderbook.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getOrderbook.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getOrderbook.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets the price level information at a specific tick.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions, Tick } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const level = await Actions.dex.getTickLevel(config, {\n *   base: '0x20c...11',\n *   tick: Tick.fromPrice('1.001'),\n *   isBid: true,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The price level information.\n */\nexport function getTickLevel<config extends Config>(\n  config: config,\n  parameters: getTickLevel.Parameters<config>,\n): Promise<getTickLevel.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.getTickLevel(client, rest)\n}\n\nexport namespace getTickLevel {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.getTickLevel.Parameters\n\n  export type ReturnValue = Actions.dex.getTickLevel.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getTickLevel', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getTickLevel(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getTickLevel.ReturnValue,\n    > = getTickLevel.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getTickLevel.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getTickLevel.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getTickLevel.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets the quote for selling a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const amountOut = await Actions.dex.getSellQuote(config, {\n *   amountIn: parseUnits('100', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The amount of tokenOut received for selling the specified amountIn.\n */\nexport function getSellQuote<config extends Config>(\n  config: config,\n  parameters: getSellQuote.Parameters<config>,\n): Promise<getSellQuote.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.getSellQuote(client, rest)\n}\n\nexport namespace getSellQuote {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.getSellQuote.Parameters\n\n  export type ReturnValue = Actions.dex.getSellQuote.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getSellQuote', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getSellQuote(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getSellQuote.ReturnValue,\n    > = getSellQuote.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getSellQuote.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getSellQuote.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getSellQuote.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Places a limit order on the orderbook.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.place(config, {\n *   amount: parseUnits('100', 6),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function place<config extends Config>(\n  config: config,\n  parameters: place.Parameters<config>,\n): Promise<Actions.dex.place.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.place(client, parameters as never)\n}\n\nexport declare namespace place {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.place.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.place.ReturnValue\n\n  export type ErrorType = Actions.dex.place.ErrorType\n}\n\n/**\n * Places a flip order that automatically flips when filled.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.placeFlip(config, {\n *   amount: parseUnits('100', 6),\n *   flipTick: Tick.fromPrice('1.01'),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function placeFlip<config extends Config>(\n  config: config,\n  parameters: placeFlip.Parameters<config>,\n): Promise<Actions.dex.placeFlip.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.placeFlip(client, parameters as never)\n}\n\nexport declare namespace placeFlip {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.placeFlip.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.placeFlip.ReturnValue\n\n  export type ErrorType = Actions.dex.placeFlip.ErrorType\n}\n\n/**\n * Places a flip order that automatically flips when filled.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.placeFlipSync(config, {\n *   amount: parseUnits('100', 6),\n *   flipTick: Tick.fromPrice('1.01'),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function placeFlipSync<config extends Config>(\n  config: config,\n  parameters: placeFlipSync.Parameters<config>,\n): Promise<Actions.dex.placeFlipSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.placeFlipSync(client, parameters as never)\n}\n\nexport declare namespace placeFlipSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.placeFlipSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.placeFlipSync.ReturnValue\n\n  export type ErrorType = Actions.dex.placeFlipSync.ErrorType\n}\n\n/**\n * Places a limit order on the orderbook.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.placeSync(config, {\n *   amount: parseUnits('100', 6),\n *   tick: Tick.fromPrice('0.99'),\n *   token: '0x20c...11',\n *   type: 'buy',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function placeSync<config extends Config>(\n  config: config,\n  parameters: placeSync.Parameters<config>,\n): Promise<Actions.dex.placeSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.placeSync(client, parameters as never)\n}\n\nexport declare namespace placeSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.placeSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.placeSync.ReturnValue\n\n  export type ErrorType = Actions.dex.placeSync.ErrorType\n}\n\n/**\n * Sells a specific amount of tokens.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.sell(config, {\n *   amountIn: parseUnits('100', 6),\n *   minAmountOut: parseUnits('95', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function sell<config extends Config>(\n  config: config,\n  parameters: sell.Parameters<config>,\n): Promise<Actions.dex.sell.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.sell(client, parameters as never)\n}\n\nexport declare namespace sell {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.sell.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.sell.ReturnValue\n\n  export type ErrorType = Actions.dex.sell.ErrorType\n}\n\n/**\n * Sells a specific amount of tokens.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.sellSync(config, {\n *   amountIn: parseUnits('100', 6),\n *   minAmountOut: parseUnits('95', 6),\n *   tokenIn: '0x20c...11',\n *   tokenOut: '0x20c...20',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function sellSync<config extends Config>(\n  config: config,\n  parameters: sellSync.Parameters<config>,\n): Promise<Actions.dex.sellSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.sellSync(client, parameters as never)\n}\n\nexport declare namespace sellSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.sellSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.sellSync.ReturnValue\n\n  export type ErrorType = Actions.dex.sellSync.ErrorType\n}\n\n/**\n * Watches for flip order placement events on the DEX.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.dex.watchFlipOrderPlaced(config, {\n *   onFlipOrderPlaced: (args, log) => {\n *     console.log('Flip order placed:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchFlipOrderPlaced<config extends Config>(\n  config: config,\n  parameters: watchFlipOrderPlaced.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.watchFlipOrderPlaced(client, rest)\n}\n\nexport declare namespace watchFlipOrderPlaced {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.watchFlipOrderPlaced.Parameters\n\n  export type Args = Actions.dex.watchFlipOrderPlaced.Args\n\n  export type Log = Actions.dex.watchFlipOrderPlaced.Log\n}\n\n/**\n * Watches for order cancellation events on the DEX.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.dex.watchOrderCancelled(config, {\n *   onOrderCancelled: (args, log) => {\n *     console.log('Order cancelled:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderCancelled<config extends Config>(\n  config: config,\n  parameters: watchOrderCancelled.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.watchOrderCancelled(client, rest)\n}\n\nexport declare namespace watchOrderCancelled {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.watchOrderCancelled.Parameters\n\n  export type Args = Actions.dex.watchOrderCancelled.Args\n\n  export type Log = Actions.dex.watchOrderCancelled.Log\n}\n\n/**\n * Watches for order filled events on the DEX.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.dex.watchOrderFilled(config, {\n *   onOrderFilled: (args, log) => {\n *     console.log('Order filled:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderFilled<config extends Config>(\n  config: config,\n  parameters: watchOrderFilled.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.watchOrderFilled(client, rest)\n}\n\nexport declare namespace watchOrderFilled {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.watchOrderFilled.Parameters\n\n  export type Args = Actions.dex.watchOrderFilled.Args\n\n  export type Log = Actions.dex.watchOrderFilled.Log\n}\n\n/**\n * Watches for order placement events on the DEX.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.dex.watchOrderPlaced(config, {\n *   onOrderPlaced: (args, log) => {\n *     console.log('Order placed:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchOrderPlaced<config extends Config>(\n  config: config,\n  parameters: watchOrderPlaced.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.dex.watchOrderPlaced(client, rest)\n}\n\nexport declare namespace watchOrderPlaced {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.dex.watchOrderPlaced.Parameters\n\n  export type Args = Actions.dex.watchOrderPlaced.Args\n\n  export type Log = Actions.dex.watchOrderPlaced.Log\n}\n\n/**\n * Withdraws tokens from the DEX to the caller's wallet.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.dex.withdraw(config, {\n *   amount: 100n,\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function withdraw<config extends Config>(\n  config: config,\n  parameters: withdraw.Parameters<config>,\n): Promise<Actions.dex.withdraw.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.withdraw(client, parameters as never)\n}\n\nexport declare namespace withdraw {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.withdraw.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.withdraw.ReturnValue\n\n  export type ErrorType = Actions.dex.withdraw.ErrorType\n}\n\n/**\n * Withdraws tokens from the DEX to the caller's wallet.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.dex.withdrawSync(config, {\n *   amount: 100n,\n *   token: '0x20c...11',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function withdrawSync<config extends Config>(\n  config: config,\n  parameters: withdrawSync.Parameters<config>,\n): Promise<Actions.dex.withdrawSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.dex.withdrawSync(client, parameters as never)\n}\n\nexport declare namespace withdrawSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.dex.withdrawSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.dex.withdrawSync.ReturnValue\n\n  export type ErrorType = Actions.dex.withdrawSync.ErrorType\n}\n", "import type { Config } from '@wagmi/core'\nimport type { ChainIdParameter, UnionCompute } from '@wagmi/core/internal'\nimport { Actions } from 'viem/tempo'\n\n/**\n * Funds an account with an initial amount of set token(s)\n * on Tempo's testnet.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hashes = await Actions.faucet.fund(config, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hashes.\n */\nexport async function fund<config extends Config>(\n  config: config,\n  parameters: fund.Parameters<config>,\n): Promise<fund.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.faucet.fund(client, rest)\n}\n\nexport declare namespace fund {\n  export type Parameters<config extends Config> = UnionCompute<\n    ChainIdParameter<config> & Actions.faucet.fund.Parameters\n  >\n\n  export type ReturnValue = Actions.faucet.fund.ReturnValue\n}\n\n/**\n * Funds an account with an initial amount of set token(s)\n * on Tempo's testnet. Returns with the transaction receipts.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const receipts = await Actions.faucet.fundSync(config, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hashes.\n */\nexport async function fundSync<config extends Config>(\n  config: config,\n  parameters: fundSync.Parameters<config>,\n): Promise<fundSync.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.faucet.fundSync(client, rest)\n}\n\nexport declare namespace fundSync {\n  export type Parameters<config extends Config> = UnionCompute<\n    ChainIdParameter<config> & Actions.faucet.fundSync.Parameters\n  >\n\n  export type ReturnValue = Actions.faucet.fundSync.ReturnValue\n}\n", "import type * as Query from '@tanstack/query-core'\nimport { type Config, getConnectorClient } from '@wagmi/core'\nimport type { ChainIdParameter, ConnectorParameter } from '@wagmi/core/internal'\nimport type { Account } from 'viem'\nimport { Actions } from 'viem/tempo'\nimport type { PartialBy, RequiredBy, UnionOmit } from '../../internal/types.js'\n\n/**\n * Gets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.fee.getUserToken(config, {\n *   account: '0x20c...0055',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport function getUserToken<config extends Config>(\n  config: config,\n  parameters: getUserToken.Parameters<config>,\n): Promise<getUserToken.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.fee.getUserToken(client, rest)\n}\n\nexport namespace getUserToken {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.fee.getUserToken.Parameters\n\n  export type ReturnValue = Actions.fee.getUserToken.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: PartialBy<Parameters<config>, 'account'>,\n  ) {\n    return ['getUserToken', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, { account, ...parameters }] = queryKey\n        if (!account) throw new Error('account is required.')\n        return await getUserToken(config, { account, ...parameters })\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getUserToken.ReturnValue,\n    > = PartialBy<getUserToken.Parameters<config>, 'account'> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getUserToken.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getUserToken.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getUserToken.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Sets the user's default fee token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.fee.setUserToken(config, {\n *   token: '0x20c...0055',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setUserToken<config extends Config>(\n  config: config,\n  parameters: setUserToken.Parameters<config>,\n): Promise<Actions.fee.setUserToken.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.fee.setUserToken(client, parameters as never)\n}\n\nexport declare namespace setUserToken {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.fee.setUserToken.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.fee.setUserToken.ReturnValue\n\n  export type ErrorType = Actions.fee.setUserToken.ErrorType\n}\n\n/**\n * Sets the user's default fee token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.fee.setUserTokenSync(config, {\n *   token: '0x20c...0055',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setUserTokenSync<config extends Config>(\n  config: config,\n  parameters: setUserTokenSync.Parameters<config>,\n): Promise<Actions.fee.setUserTokenSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.fee.setUserTokenSync(client, parameters as never)\n}\n\nexport declare namespace setUserTokenSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.fee.setUserTokenSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.fee.setUserTokenSync.ReturnValue\n\n  export type ErrorType = Actions.fee.setUserTokenSync.ErrorType\n}\n", "import type * as Query from '@tanstack/query-core'\nimport type { Config } from '@wagmi/core'\nimport type { ChainIdParameter } from '@wagmi/core/internal'\nimport { Actions } from 'viem/tempo'\nimport type { PartialBy, RequiredBy } from '../../internal/types.js'\n\n/**\n * Gets the nonce for an account and nonce key.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const nonce = await Actions.nonce.getNonce(config, {\n *   account: '0x...',\n *   nonceKey: 1n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The nonce value.\n */\nexport function getNonce<config extends Config>(\n  config: config,\n  parameters: getNonce.Parameters<config>,\n): Promise<getNonce.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.nonce.getNonce(client, rest)\n}\n\nexport namespace getNonce {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.nonce.getNonce.Parameters\n\n  export type ReturnValue = Actions.nonce.getNonce.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: PartialBy<Parameters<config>, 'account' | 'nonceKey'>,\n  ) {\n    return ['getNonce', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, { account, nonceKey, ...parameters }] = queryKey\n        if (!account) throw new Error('account is required.')\n        if (nonceKey === undefined) throw new Error('nonceKey is required.')\n        return await getNonce(config, { account, nonceKey, ...parameters })\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getNonce.ReturnValue,\n    > = PartialBy<getNonce.Parameters<config>, 'account' | 'nonceKey'> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getNonce.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getNonce.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getNonce.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Watches for nonce incremented events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.nonce.watchNonceIncremented(config, {\n *   onNonceIncremented: (args, log) => {\n *     console.log('Nonce incremented:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchNonceIncremented<config extends Config>(\n  config: config,\n  parameters: watchNonceIncremented.Parameters<config>,\n): () => void {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.nonce.watchNonceIncremented(client, rest)\n}\n\nexport declare namespace watchNonceIncremented {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.nonce.watchNonceIncremented.Parameters\n}\n", "import type * as Query from '@tanstack/query-core'\nimport { type Config, getConnectorClient } from '@wagmi/core'\nimport type { ChainIdParameter, ConnectorParameter } from '@wagmi/core/internal'\nimport type { Account } from 'viem'\nimport { Actions } from 'viem/tempo'\nimport type { RequiredBy, UnionOmit } from '../../internal/types.js'\n\n/**\n * Creates a new policy.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.policy.create(config, {\n *   type: 'whitelist',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function create<config extends Config>(\n  config: config,\n  parameters: create.Parameters<config>,\n): Promise<Actions.policy.create.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.create(client, parameters as never)\n}\n\nexport declare namespace create {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.create.Parameters<config['chains'][number], Account>,\n      'chain' | 'admin'\n    >\n\n  export type ReturnValue = Actions.policy.create.ReturnValue\n\n  export type ErrorType = Actions.policy.create.ErrorType\n}\n\n/**\n * Creates a new policy.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.policy.createSync(config, {\n *   type: 'whitelist',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createSync<config extends Config>(\n  config: config,\n  parameters: createSync.Parameters<config>,\n): Promise<Actions.policy.createSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.createSync(client, parameters as never)\n}\n\nexport declare namespace createSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.createSync.Parameters<config['chains'][number], Account>,\n      'chain' | 'admin'\n    >\n\n  export type ReturnValue = Actions.policy.createSync.ReturnValue\n\n  export type ErrorType = Actions.policy.createSync.ErrorType\n}\n\n/**\n * Sets the admin for a policy.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.policy.setAdmin(config, {\n *   policyId: 2n,\n *   admin: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function setAdmin<config extends Config>(\n  config: config,\n  parameters: setAdmin.Parameters<config>,\n): Promise<Actions.policy.setAdmin.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.setAdmin(client, parameters as never)\n}\n\nexport declare namespace setAdmin {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.setAdmin.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.policy.setAdmin.ReturnValue\n\n  export type ErrorType = Actions.policy.setAdmin.ErrorType\n}\n\n/**\n * Sets the admin for a policy.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.policy.setAdminSync(config, {\n *   policyId: 2n,\n *   admin: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setAdminSync<config extends Config>(\n  config: config,\n  parameters: setAdminSync.Parameters<config>,\n): Promise<Actions.policy.setAdminSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.setAdminSync(client, parameters as never)\n}\n\nexport declare namespace setAdminSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.setAdminSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.policy.setAdminSync.ReturnValue\n\n  export type ErrorType = Actions.policy.setAdminSync.ErrorType\n}\n\n/**\n * Modifies a policy whitelist.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.policy.modifyWhitelist(config, {\n *   policyId: 2n,\n *   address: '0x...',\n *   allowed: true,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function modifyWhitelist<config extends Config>(\n  config: config,\n  parameters: modifyWhitelist.Parameters<config>,\n): Promise<Actions.policy.modifyWhitelist.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.modifyWhitelist(client, parameters as never)\n}\n\nexport declare namespace modifyWhitelist {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.modifyWhitelist.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.policy.modifyWhitelist.ReturnValue\n\n  export type ErrorType = Actions.policy.modifyWhitelist.ErrorType\n}\n\n/**\n * Modifies a policy whitelist.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.policy.modifyWhitelistSync(config, {\n *   policyId: 2n,\n *   address: '0x...',\n *   allowed: true,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function modifyWhitelistSync<config extends Config>(\n  config: config,\n  parameters: modifyWhitelistSync.Parameters<config>,\n): Promise<Actions.policy.modifyWhitelistSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.modifyWhitelistSync(client, parameters as never)\n}\n\nexport declare namespace modifyWhitelistSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.modifyWhitelistSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.policy.modifyWhitelistSync.ReturnValue\n\n  export type ErrorType = Actions.policy.modifyWhitelistSync.ErrorType\n}\n\n/**\n * Modifies a policy blacklist.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.policy.modifyBlacklist(config, {\n *   policyId: 2n,\n *   address: '0x...',\n *   restricted: true,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function modifyBlacklist<config extends Config>(\n  config: config,\n  parameters: modifyBlacklist.Parameters<config>,\n): Promise<Actions.policy.modifyBlacklist.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.modifyBlacklist(client, parameters as never)\n}\n\nexport declare namespace modifyBlacklist {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.modifyBlacklist.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.policy.modifyBlacklist.ReturnValue\n\n  export type ErrorType = Actions.policy.modifyBlacklist.ErrorType\n}\n\n/**\n * Modifies a policy blacklist.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.policy.modifyBlacklistSync(config, {\n *   policyId: 2n,\n *   address: '0x...',\n *   restricted: true,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function modifyBlacklistSync<config extends Config>(\n  config: config,\n  parameters: modifyBlacklistSync.Parameters<config>,\n): Promise<Actions.policy.modifyBlacklistSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.policy.modifyBlacklistSync(client, parameters as never)\n}\n\nexport declare namespace modifyBlacklistSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.policy.modifyBlacklistSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.policy.modifyBlacklistSync.ReturnValue\n\n  export type ErrorType = Actions.policy.modifyBlacklistSync.ErrorType\n}\n\n/**\n * Gets policy data.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const data = await Actions.policy.getData(config, {\n *   policyId: 2n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The policy data.\n */\nexport function getData<config extends Config>(\n  config: config,\n  parameters: getData.Parameters<config>,\n): Promise<getData.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.policy.getData(client, rest)\n}\n\nexport namespace getData {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.policy.getData.Parameters\n\n  export type ReturnValue = Actions.policy.getData.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getData', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getData(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getData.ReturnValue,\n    > = getData.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getData.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getData.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getData.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Checks if a user is authorized by a policy.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const authorized = await Actions.policy.isAuthorized(config, {\n *   policyId: 2n,\n *   user: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Whether the user is authorized.\n */\nexport function isAuthorized<config extends Config>(\n  config: config,\n  parameters: isAuthorized.Parameters<config>,\n): Promise<isAuthorized.ReturnValue> {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.policy.isAuthorized(client, rest)\n}\n\nexport namespace isAuthorized {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.policy.isAuthorized.Parameters\n\n  export type ReturnValue = Actions.policy.isAuthorized.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['isAuthorized', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await isAuthorized(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = isAuthorized.ReturnValue,\n    > = isAuthorized.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = isAuthorized.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        isAuthorized.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        isAuthorized.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Watches for policy creation events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.policy.watchCreate(config, {\n *   onPolicyCreated: (args, log) => {\n *     console.log('Policy created:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchCreate<config extends Config>(\n  config: config,\n  parameters: watchCreate.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.policy.watchCreate(client, rest)\n}\n\nexport declare namespace watchCreate {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.policy.watchCreate.Parameters\n}\n\n/**\n * Watches for policy admin update events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.policy.watchAdminUpdated(config, {\n *   onAdminUpdated: (args, log) => {\n *     console.log('Policy admin updated:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchAdminUpdated<config extends Config>(\n  config: config,\n  parameters: watchAdminUpdated.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.policy.watchAdminUpdated(client, rest)\n}\n\nexport declare namespace watchAdminUpdated {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.policy.watchAdminUpdated.Parameters\n}\n\n/**\n * Watches for whitelist update events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.policy.watchWhitelistUpdated(config, {\n *   onWhitelistUpdated: (args, log) => {\n *     console.log('Whitelist updated:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchWhitelistUpdated<config extends Config>(\n  config: config,\n  parameters: watchWhitelistUpdated.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.policy.watchWhitelistUpdated(client, rest)\n}\n\nexport declare namespace watchWhitelistUpdated {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.policy.watchWhitelistUpdated.Parameters\n}\n\n/**\n * Watches for blacklist update events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.policy.watchBlacklistUpdated(config, {\n *   onBlacklistUpdated: (args, log) => {\n *     console.log('Blacklist updated:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBlacklistUpdated<config extends Config>(\n  config: config,\n  parameters: watchBlacklistUpdated.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.policy.watchBlacklistUpdated(client, rest)\n}\n\nexport declare namespace watchBlacklistUpdated {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.policy.watchBlacklistUpdated.Parameters\n}\n", "import type * as Query from '@tanstack/query-core'\nimport { type Config, getConnectorClient } from '@wagmi/core'\nimport type { ChainIdParameter, ConnectorParameter } from '@wagmi/core/internal'\nimport type { Account } from 'viem'\nimport { Actions } from 'viem/tempo'\nimport type { RequiredBy, UnionOmit } from '../../internal/types.js'\n\n/**\n * Claims accumulated rewards for a recipient.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.reward.claim(config, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function claim<config extends Config>(\n  config: config,\n  parameters: claim.Parameters<config>,\n): Promise<Actions.reward.claim.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.reward.claim(client, parameters as never)\n}\n\nexport declare namespace claim {\n  export type Parameters<config extends Config = Config> =\n    ChainIdParameter<config> &\n      ConnectorParameter &\n      UnionOmit<\n        Actions.reward.claim.Parameters<config['chains'][number], Account>,\n        'chain'\n      >\n\n  export type ReturnValue = Actions.reward.claim.ReturnValue\n\n  export type ErrorType = Actions.reward.claim.ErrorType\n}\n\n/**\n * Claims accumulated rewards for a recipient and waits for confirmation.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.reward.claimSync(config, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt.\n */\nexport async function claimSync<config extends Config>(\n  config: config,\n  parameters: claimSync.Parameters<config>,\n): Promise<Actions.reward.claimSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.reward.claimSync(client, parameters as never)\n}\n\nexport declare namespace claimSync {\n  export type Parameters<config extends Config = Config> =\n    ChainIdParameter<config> &\n      ConnectorParameter &\n      UnionOmit<\n        Actions.reward.claimSync.Parameters<config['chains'][number], Account>,\n        'chain'\n      >\n\n  export type ReturnValue = Actions.reward.claimSync.ReturnValue\n\n  export type ErrorType = Actions.reward.claimSync.ErrorType\n}\n\n/**\n * Gets the total reward per second rate for all active streams.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const rate = await Actions.reward.getTotalPerSecond(config, {\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The total reward per second (scaled by 1e18).\n */\nexport function getTotalPerSecond<config extends Config>(\n  config: config,\n  parameters: getTotalPerSecond.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.reward.getTotalPerSecond(client, rest)\n}\n\nexport namespace getTotalPerSecond {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.reward.getTotalPerSecond.Parameters\n\n  export type ReturnValue = Actions.reward.getTotalPerSecond.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getTotalPerSecond', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getTotalPerSecond(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getTotalPerSecond.ReturnValue,\n    > = getTotalPerSecond.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getTotalPerSecond.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getTotalPerSecond.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getTotalPerSecond.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets the reward information for a specific account.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const info = await Actions.reward.getUserRewardInfo(config, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The user's reward information (recipient, rewardPerToken, rewardBalance).\n */\nexport function getUserRewardInfo<config extends Config>(\n  config: config,\n  parameters: getUserRewardInfo.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.reward.getUserRewardInfo(client, rest)\n}\n\nexport namespace getUserRewardInfo {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.reward.getUserRewardInfo.Parameters\n\n  export type ReturnValue = Actions.reward.getUserRewardInfo.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getUserRewardInfo', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getUserRewardInfo(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getUserRewardInfo.ReturnValue,\n    > = getUserRewardInfo.Parameters<config> & {\n      query?:\n        | Omit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getUserRewardInfo.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getUserRewardInfo.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getUserRewardInfo.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Sets or changes the reward recipient for a token holder.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.reward.setRecipient(config, {\n *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function setRecipient<config extends Config>(\n  config: config,\n  parameters: setRecipient.Parameters<config>,\n): Promise<Actions.reward.setRecipient.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.reward.setRecipient(client, parameters as never)\n}\n\nexport declare namespace setRecipient {\n  export type Parameters<config extends Config = Config> =\n    ChainIdParameter<config> &\n      ConnectorParameter &\n      UnionOmit<\n        Actions.reward.setRecipient.Parameters<\n          config['chains'][number],\n          Account\n        >,\n        'chain'\n      >\n\n  export type ReturnValue = Actions.reward.setRecipient.ReturnValue\n\n  export type ErrorType = Actions.reward.setRecipient.ErrorType\n}\n\n/**\n * Sets or changes the reward recipient for a token holder and waits for confirmation.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.reward.setRecipientSync(config, {\n *   recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setRecipientSync<config extends Config>(\n  config: config,\n  parameters: setRecipientSync.Parameters<config>,\n): Promise<Actions.reward.setRecipientSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.reward.setRecipientSync(client, parameters as never)\n}\n\nexport declare namespace setRecipientSync {\n  export type Parameters<config extends Config = Config> =\n    ChainIdParameter<config> &\n      ConnectorParameter &\n      UnionOmit<\n        Actions.reward.setRecipientSync.Parameters<\n          config['chains'][number],\n          Account\n        >,\n        'chain'\n      >\n\n  export type ReturnValue = Actions.reward.setRecipientSync.ReturnValue\n\n  export type ErrorType = Actions.reward.setRecipientSync.ErrorType\n}\n\n/**\n * Starts a new reward stream that distributes tokens to opted-in holders.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.reward.start(config, {\n *   amount: 100000000000000000000n,\n *   seconds: 86400,\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction hash.\n */\nexport async function start<config extends Config>(\n  config: config,\n  parameters: start.Parameters<config>,\n): Promise<Actions.reward.start.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.reward.start(client, parameters as never)\n}\n\nexport declare namespace start {\n  export type Parameters<config extends Config = Config> =\n    ChainIdParameter<config> &\n      ConnectorParameter &\n      UnionOmit<\n        Actions.reward.start.Parameters<config['chains'][number], Account>,\n        'chain'\n      >\n\n  export type ReturnValue = Actions.reward.start.ReturnValue\n\n  export type ErrorType = Actions.reward.start.ErrorType\n}\n\n/**\n * Starts a new reward stream that distributes tokens to opted-in holders and waits for confirmation.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.reward.startSync(config, {\n *   amount: 100000000000000000000n,\n *   seconds: 86400,\n *   token: '0x20c0000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function startSync<config extends Config>(\n  config: config,\n  parameters: startSync.Parameters<config>,\n): Promise<Actions.reward.startSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.reward.startSync(client, parameters as never)\n}\n\nexport declare namespace startSync {\n  export type Parameters<config extends Config = Config> =\n    ChainIdParameter<config> &\n      ConnectorParameter &\n      UnionOmit<\n        Actions.reward.startSync.Parameters<config['chains'][number], Account>,\n        'chain'\n      >\n\n  export type ReturnValue = Actions.reward.startSync.ReturnValue\n\n  export type ErrorType = Actions.reward.startSync.ErrorType\n}\n\n/**\n * Watches for reward scheduled events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.reward.watchRewardScheduled(config, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   onRewardScheduled: (args, log) => {\n *     console.log('Reward scheduled:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRewardScheduled<config extends Config>(\n  config: config,\n  parameters: watchRewardScheduled.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.reward.watchRewardScheduled(client, rest)\n}\n\nexport declare namespace watchRewardScheduled {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.reward.watchRewardScheduled.Parameters\n}\n\n/**\n * Watches for reward recipient set events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.reward.watchRewardRecipientSet(config, {\n *   token: '0x20c0000000000000000000000000000000000001',\n *   onRewardRecipientSet: (args, log) => {\n *     console.log('Reward recipient set:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRewardRecipientSet<config extends Config>(\n  config: config,\n  parameters: watchRewardRecipientSet.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.reward.watchRewardRecipientSet(client, rest)\n}\n\nexport declare namespace watchRewardRecipientSet {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.reward.watchRewardRecipientSet.Parameters\n}\n", "import type * as Query from '@tanstack/query-core'\nimport { type Config, getConnectorClient } from '@wagmi/core'\nimport type { ChainIdParameter, ConnectorParameter } from '@wagmi/core/internal'\nimport type { Account } from 'viem'\nimport { Actions } from 'viem/tempo'\nimport type { RequiredBy, UnionOmit } from '../../internal/types.js'\n\n/**\n * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.approve(config, {\n *   spender: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function approve<config extends Config>(\n  config: config,\n  parameters: approve.Parameters<config>,\n): Promise<Actions.token.approve.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.approve(client, parameters as never)\n}\n\nexport declare namespace approve {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.approve.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.approve.ReturnValue\n\n  export type ErrorType = Actions.token.approve.ErrorType\n}\n\n/**\n * Approves a spender to transfer TIP20 tokens on behalf of the caller.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.approveSync(config, {\n *   spender: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function approveSync<config extends Config>(\n  config: config,\n  parameters: approveSync.Parameters<config>,\n): Promise<Actions.token.approveSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.approveSync(client, parameters as never)\n}\n\nexport declare namespace approveSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.approveSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.approveSync.ReturnValue\n\n  export type ErrorType = Actions.token.approveSync.ErrorType\n}\n\n/**\n * Burns TIP20 tokens from the caller's balance.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.burn(config, {\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function burn<config extends Config>(\n  config: config,\n  parameters: burn.Parameters<config>,\n): Promise<Actions.token.burn.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.burn(client, parameters as never)\n}\n\nexport declare namespace burn {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.burn.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.burn.ReturnValue\n\n  export type ErrorType = Actions.token.burn.ErrorType\n}\n\n/**\n * Burns TIP20 tokens from a blocked address.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.burnBlocked(config, {\n *   from: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function burnBlocked<config extends Config>(\n  config: config,\n  parameters: burnBlocked.Parameters<config>,\n): Promise<Actions.token.burnBlocked.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return await Actions.token.burnBlocked(client, parameters as never)\n}\n\nexport declare namespace burnBlocked {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.burnBlocked.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.burnBlocked.ReturnValue\n\n  export type ErrorType = Actions.token.burnBlocked.ErrorType\n}\n\n/**\n * Burns TIP20 tokens from a blocked address.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.burnBlockedSync(config, {\n *   from: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnBlockedSync<config extends Config>(\n  config: config,\n  parameters: burnBlockedSync.Parameters<config>,\n): Promise<Actions.token.burnBlockedSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.burnBlockedSync(client, parameters as never)\n}\n\nexport declare namespace burnBlockedSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.burnBlockedSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.burnBlockedSync.ReturnValue\n\n  export type ErrorType = Actions.token.burnBlockedSync.ErrorType\n}\n\n/**\n * Burns TIP20 tokens from the caller's balance.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.burnSync(config, {\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function burnSync<config extends Config>(\n  config: config,\n  parameters: burnSync.Parameters<config>,\n): Promise<Actions.token.burnSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.burnSync(client, parameters as never)\n}\n\nexport declare namespace burnSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.burnSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.burnSync.ReturnValue\n\n  export type ErrorType = Actions.token.burnSync.ErrorType\n}\n\n/**\n * Changes the transfer policy ID for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.changeTransferPolicy(config, {\n *   token: '0x...',\n *   policyId: 1n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function changeTransferPolicy<config extends Config>(\n  config: config,\n  parameters: changeTransferPolicy.Parameters<config>,\n): Promise<Actions.token.changeTransferPolicy.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.changeTransferPolicy(client, parameters as never)\n}\n\nexport declare namespace changeTransferPolicy {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.changeTransferPolicy.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.changeTransferPolicy.ReturnValue\n\n  export type ErrorType = Actions.token.changeTransferPolicy.ErrorType\n}\n\n/**\n * Changes the transfer policy ID for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.changeTransferPolicySync(config, {\n *   token: '0x...',\n *   policyId: 1n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function changeTransferPolicySync<config extends Config>(\n  config: config,\n  parameters: changeTransferPolicySync.Parameters<config>,\n): Promise<Actions.token.changeTransferPolicySync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.changeTransferPolicySync(client, parameters as never)\n}\n\nexport declare namespace changeTransferPolicySync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.changeTransferPolicySync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.changeTransferPolicySync.ReturnValue\n\n  export type ErrorType = Actions.token.changeTransferPolicySync.ErrorType\n}\n\n/**\n * Creates a new TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.create(config, {\n *   name: 'My Token',\n *   symbol: 'MTK',\n *   currency: 'USD',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function create<config extends Config>(\n  config: config,\n  parameters: create.Parameters<config>,\n): Promise<Actions.token.create.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.create(client, parameters as never)\n}\n\nexport declare namespace create {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.create.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.create.ReturnValue\n\n  export type ErrorType = Actions.token.create.ErrorType\n}\n\n/**\n * Creates a new TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.createSync(config, {\n *   name: 'My Token',\n *   symbol: 'MTK',\n *   currency: 'USD',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function createSync<config extends Config>(\n  config: config,\n  parameters: createSync.Parameters<config>,\n): Promise<Actions.token.createSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.createSync(client, parameters as never)\n}\n\nexport declare namespace createSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.createSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.createSync.ReturnValue\n\n  export type ErrorType = Actions.token.createSync.ErrorType\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.updateQuoteToken(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function updateQuoteToken<config extends Config>(\n  config: config,\n  parameters: updateQuoteToken.Parameters<config>,\n): Promise<Actions.token.updateQuoteToken.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.updateQuoteToken(client, parameters as never)\n}\n\nexport declare namespace updateQuoteToken {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.updateQuoteToken.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.updateQuoteToken.ReturnValue\n\n  export type ErrorType = Actions.token.updateQuoteToken.ErrorType\n}\n\n/**\n * Updates the quote token for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.updateQuoteTokenSync(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function updateQuoteTokenSync<config extends Config>(\n  config: config,\n  parameters: updateQuoteTokenSync.Parameters<config>,\n): Promise<Actions.token.updateQuoteTokenSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.updateQuoteTokenSync(client, parameters as never)\n}\n\nexport declare namespace updateQuoteTokenSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.updateQuoteTokenSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.updateQuoteTokenSync.ReturnValue\n\n  export type ErrorType = Actions.token.updateQuoteTokenSync.ErrorType\n}\n\n/**\n * Gets TIP20 token allowance.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const allowance = await Actions.token.getAllowance(config, {\n *   account: '0x...',\n *   spender: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The token allowance.\n */\nexport function getAllowance<config extends Config>(\n  config: config,\n  parameters: getAllowance.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.getAllowance(client, rest)\n}\n\nexport namespace getAllowance {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.getAllowance.Parameters\n\n  export type ReturnValue = Actions.token.getAllowance.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getAllowance', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getAllowance(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getAllowance.ReturnValue,\n    > = getAllowance.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getAllowance.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getAllowance.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getAllowance.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets TIP20 token balance for an address.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const balance = await Actions.token.getBalance(config, {\n *   account: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The token balance.\n */\nexport function getBalance<config extends Config>(\n  config: config,\n  parameters: getBalance.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.getBalance(client, rest as never)\n}\n\nexport namespace getBalance {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.getBalance.Parameters\n\n  export type ReturnValue = Actions.token.getBalance.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getBalance', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return (await getBalance(config, parameters)) ?? null\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getBalance.ReturnValue,\n    > = getBalance.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getBalance.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getBalance.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getBalance.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets TIP20 token metadata.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const metadata = await Actions.token.getMetadata(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The token metadata.\n */\nexport function getMetadata<config extends Config>(\n  config: config,\n  parameters: getMetadata.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.getMetadata(client, rest)\n}\n\nexport namespace getMetadata {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.getMetadata.Parameters\n\n  export type ReturnValue = Actions.token.getMetadata.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getMetadata', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getMetadata(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getMetadata.ReturnValue,\n    > = getMetadata.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getMetadata.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getMetadata.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getMetadata.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Gets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const adminRole = await Actions.token.getRoleAdmin(config, {\n *   role: 'issuer',\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The admin role hash.\n */\nexport function getRoleAdmin<config extends Config>(\n  config: config,\n  parameters: getRoleAdmin.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.getRoleAdmin(client, rest)\n}\n\nexport namespace getRoleAdmin {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.getRoleAdmin.Parameters\n\n  export type ReturnValue = Actions.token.getRoleAdmin.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['getRoleAdmin', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await getRoleAdmin(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = getRoleAdmin.ReturnValue,\n    > = getRoleAdmin.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = getRoleAdmin.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        getRoleAdmin.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        getRoleAdmin.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Grants a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.grantRoles(config, {\n *   token: '0x...',\n *   to: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function grantRoles<config extends Config>(\n  config: config,\n  parameters: grantRoles.Parameters<config>,\n): Promise<Actions.token.grantRoles.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.grantRoles(client, parameters as never)\n}\n\nexport declare namespace grantRoles {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.grantRoles.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.grantRoles.ReturnValue\n\n  export type ErrorType = Actions.token.grantRoles.ErrorType\n}\n\n/**\n * Grants a role for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.grantRolesSync(config, {\n *   token: '0x...',\n *   to: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function grantRolesSync<config extends Config>(\n  config: config,\n  parameters: grantRolesSync.Parameters<config>,\n): Promise<Actions.token.grantRolesSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.grantRolesSync(client, parameters as never)\n}\n\nexport declare namespace grantRolesSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.grantRolesSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.grantRolesSync.ReturnValue\n\n  export type ErrorType = Actions.token.grantRolesSync.ErrorType\n}\n\n/**\n * Checks if an account has a specific role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hasRole = await Actions.token.hasRole(config, {\n *   account: '0x...',\n *   role: 'issuer',\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Whether the account has the role.\n */\nexport function hasRole<config extends Config>(\n  config: config,\n  parameters: hasRole.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.hasRole(client, rest)\n}\n\nexport namespace hasRole {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.hasRole.Parameters\n\n  export type ReturnValue = Actions.token.hasRole.ReturnValue\n\n  export function queryKey<config extends Config>(\n    parameters: Parameters<config>,\n  ) {\n    return ['hasRole', parameters] as const\n  }\n\n  export type QueryKey<config extends Config> = ReturnType<\n    typeof queryKey<config>\n  >\n\n  export function queryOptions<config extends Config, selectData = ReturnValue>(\n    config: Config,\n    parameters: queryOptions.Parameters<config, selectData>,\n  ): queryOptions.ReturnValue<config, selectData> {\n    const { query, ...rest } = parameters\n    return {\n      ...query,\n      queryKey: queryKey(rest),\n      async queryFn({ queryKey }) {\n        const [, parameters] = queryKey\n        return await hasRole(config, parameters)\n      },\n    }\n  }\n\n  export declare namespace queryOptions {\n    export type Parameters<\n      config extends Config,\n      selectData = hasRole.ReturnValue,\n    > = hasRole.Parameters<config> & {\n      query?:\n        | UnionOmit<ReturnValue<config, selectData>, 'queryKey' | 'queryFn'>\n        | undefined\n    }\n\n    export type ReturnValue<\n      config extends Config,\n      selectData = hasRole.ReturnValue,\n    > = RequiredBy<\n      Query.QueryOptions<\n        hasRole.ReturnValue,\n        Query.DefaultError,\n        selectData,\n        hasRole.QueryKey<config>\n      >,\n      'queryKey' | 'queryFn'\n    >\n  }\n}\n\n/**\n * Mints TIP20 tokens to an address.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.mint(config, {\n *   to: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function mint<config extends Config>(\n  config: config,\n  parameters: mint.Parameters<config>,\n): Promise<Actions.token.mint.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.mint(client, parameters as never)\n}\n\nexport declare namespace mint {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.mint.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.mint.ReturnValue\n\n  export type ErrorType = Actions.token.mint.ErrorType\n}\n\n/**\n * Mints TIP20 tokens to an address.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.mintSync(config, {\n *   to: '0x...',\n *   amount: 100n,\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function mintSync<config extends Config>(\n  config: config,\n  parameters: mintSync.Parameters<config>,\n): Promise<Actions.token.mintSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.mintSync(client, parameters as never)\n}\n\nexport declare namespace mintSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.mintSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.mintSync.ReturnValue\n\n  export type ErrorType = Actions.token.mintSync.ErrorType\n}\n\n/**\n * Pauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.pause(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function pause<config extends Config>(\n  config: config,\n  parameters: pause.Parameters<config>,\n): Promise<Actions.token.pause.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.pause(client, parameters as never)\n}\n\nexport declare namespace pause {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.pause.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.pause.ReturnValue\n\n  export type ErrorType = Actions.token.pause.ErrorType\n}\n\n/**\n * Pauses a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.pauseSync(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function pauseSync<config extends Config>(\n  config: config,\n  parameters: pauseSync.Parameters<config>,\n): Promise<Actions.token.pauseSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.pauseSync(client, parameters as never)\n}\n\nexport declare namespace pauseSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.pauseSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.pauseSync.ReturnValue\n\n  export type ErrorType = Actions.token.pauseSync.ErrorType\n}\n\n/**\n * Renounces a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.renounceRoles(config, {\n *   token: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function renounceRoles<config extends Config>(\n  config: config,\n  parameters: renounceRoles.Parameters<config>,\n): Promise<Actions.token.renounceRoles.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.renounceRoles(client, parameters as never)\n}\n\nexport declare namespace renounceRoles {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.renounceRoles.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.renounceRoles.ReturnValue\n\n  export type ErrorType = Actions.token.renounceRoles.ErrorType\n}\n\n/**\n * Renounces a role for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.renounceRolesSync(config, {\n *   token: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function renounceRolesSync<config extends Config>(\n  config: config,\n  parameters: renounceRolesSync.Parameters<config>,\n): Promise<Actions.token.renounceRolesSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.renounceRolesSync(client, parameters as never)\n}\n\nexport declare namespace renounceRolesSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.renounceRolesSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.renounceRolesSync.ReturnValue\n\n  export type ErrorType = Actions.token.renounceRolesSync.ErrorType\n}\n\n/**\n * Revokes a role for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.revokeRoles(config, {\n *   token: '0x...',\n *   from: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function revokeRoles<config extends Config>(\n  config: config,\n  parameters: revokeRoles.Parameters<config>,\n): Promise<Actions.token.revokeRoles.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.revokeRoles(client, parameters as never)\n}\n\nexport declare namespace revokeRoles {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.revokeRoles.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.revokeRoles.ReturnValue\n\n  export type ErrorType = Actions.token.revokeRoles.ErrorType\n}\n\n/**\n * Revokes a role for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.revokeRolesSync(config, {\n *   token: '0x...',\n *   from: '0x...',\n *   roles: ['issuer'],\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function revokeRolesSync<config extends Config>(\n  config: config,\n  parameters: revokeRolesSync.Parameters<config>,\n): Promise<Actions.token.revokeRolesSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.revokeRolesSync(client, parameters as never)\n}\n\nexport declare namespace revokeRolesSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.revokeRolesSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.revokeRolesSync.ReturnValue\n\n  export type ErrorType = Actions.token.revokeRolesSync.ErrorType\n}\n\n/**\n * Sets the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.setRoleAdmin(config, {\n *   token: '0x...',\n *   role: 'issuer',\n *   adminRole: 'pause',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function setRoleAdmin<config extends Config>(\n  config: config,\n  parameters: setRoleAdmin.Parameters<config>,\n): Promise<Actions.token.setRoleAdmin.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.setRoleAdmin(client, parameters as never)\n}\n\nexport declare namespace setRoleAdmin {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.setRoleAdmin.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.setRoleAdmin.ReturnValue\n\n  export type ErrorType = Actions.token.setRoleAdmin.ErrorType\n}\n\n/**\n * Sets the admin role for a specific role in a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.setRoleAdminSync(config, {\n *   token: '0x...',\n *   role: 'issuer',\n *   adminRole: 'pause',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setRoleAdminSync<config extends Config>(\n  config: config,\n  parameters: setRoleAdminSync.Parameters<config>,\n): Promise<Actions.token.setRoleAdminSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.setRoleAdminSync(client, parameters as never)\n}\n\nexport declare namespace setRoleAdminSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.setRoleAdminSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.setRoleAdminSync.ReturnValue\n\n  export type ErrorType = Actions.token.setRoleAdminSync.ErrorType\n}\n\n/**\n * Sets the supply cap for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.setSupplyCap(config, {\n *   token: '0x...',\n *   supplyCap: 1000000n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function setSupplyCap<config extends Config>(\n  config: config,\n  parameters: setSupplyCap.Parameters<config>,\n): Promise<Actions.token.setSupplyCap.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.setSupplyCap(client, parameters as never)\n}\n\nexport declare namespace setSupplyCap {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.setSupplyCap.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.setSupplyCap.ReturnValue\n\n  export type ErrorType = Actions.token.setSupplyCap.ErrorType\n}\n\n/**\n * Sets the supply cap for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.setSupplyCapSync(config, {\n *   token: '0x...',\n *   supplyCap: 1000000n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function setSupplyCapSync<config extends Config>(\n  config: config,\n  parameters: setSupplyCapSync.Parameters<config>,\n): Promise<Actions.token.setSupplyCapSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.setSupplyCapSync(client, parameters as never)\n}\n\nexport declare namespace setSupplyCapSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.setSupplyCapSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.setSupplyCapSync.ReturnValue\n\n  export type ErrorType = Actions.token.setSupplyCapSync.ErrorType\n}\n\n/**\n * Transfers TIP20 tokens to another address.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.transfer(config, {\n *   to: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function transfer<config extends Config>(\n  config: config,\n  parameters: transfer.Parameters<config>,\n): Promise<Actions.token.transfer.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.transfer(client, parameters as never)\n}\n\nexport declare namespace transfer {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.transfer.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.transfer.ReturnValue\n\n  export type ErrorType = Actions.token.transfer.ErrorType\n}\n\n/**\n * Transfers TIP20 tokens to another address.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.transferSync(config, {\n *   to: '0x...',\n *   amount: 100n,\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function transferSync<config extends Config>(\n  config: config,\n  parameters: transferSync.Parameters<config>,\n): Promise<Actions.token.transferSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.transferSync(client, parameters as never)\n}\n\nexport declare namespace transferSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.transferSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.transferSync.ReturnValue\n\n  export type ErrorType = Actions.token.transferSync.ErrorType\n}\n\n/**\n * Unpauses a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.unpause(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function unpause<config extends Config>(\n  config: config,\n  parameters: unpause.Parameters<config>,\n): Promise<Actions.token.unpause.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.unpause(client, parameters as never)\n}\n\nexport declare namespace unpause {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.unpause.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.unpause.ReturnValue\n\n  export type ErrorType = Actions.token.unpause.ErrorType\n}\n\n/**\n * Unpauses a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.unpauseSync(config, {\n *   token: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function unpauseSync<config extends Config>(\n  config: config,\n  parameters: unpauseSync.Parameters<config>,\n): Promise<Actions.token.unpauseSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.unpauseSync(client, parameters as never)\n}\n\nexport declare namespace unpauseSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.unpauseSync.Parameters<config['chains'][number], Account>,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.unpauseSync.ReturnValue\n\n  export type ErrorType = Actions.token.unpauseSync.ErrorType\n}\n\n/**\n * Prepares the quote token update for a TIP20 token.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const hash = await Actions.token.prepareUpdateQuoteToken(config, {\n *   token: '0x...',\n *   quoteToken: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns Transaction hash.\n */\nexport async function prepareUpdateQuoteToken<config extends Config>(\n  config: config,\n  parameters: prepareUpdateQuoteToken.Parameters<config>,\n): Promise<Actions.token.prepareUpdateQuoteToken.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.prepareUpdateQuoteToken(client, parameters as never)\n}\n\nexport declare namespace prepareUpdateQuoteToken {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.prepareUpdateQuoteToken.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue = Actions.token.prepareUpdateQuoteToken.ReturnValue\n\n  export type ErrorType = Actions.token.prepareUpdateQuoteToken.ErrorType\n}\n\n/**\n * Prepares the quote token update for a TIP20 token.\n *\n * Note: This is a synchronous action that waits for the transaction to\n * be included on a block before returning a response.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const result = await Actions.token.prepareUpdateQuoteTokenSync(config, {\n *   token: '0x...',\n *   quoteToken: '0x...',\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns The transaction receipt and event data.\n */\nexport async function prepareUpdateQuoteTokenSync<config extends Config>(\n  config: config,\n  parameters: prepareUpdateQuoteTokenSync.Parameters<config>,\n): Promise<Actions.token.prepareUpdateQuoteTokenSync.ReturnValue> {\n  const { account, chainId, connector } = parameters\n\n  const client = await getConnectorClient(config, {\n    account,\n    assertChainId: false,\n    chainId,\n    connector,\n  })\n\n  return Actions.token.prepareUpdateQuoteTokenSync(client, parameters as never)\n}\n\nexport declare namespace prepareUpdateQuoteTokenSync {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    ConnectorParameter &\n    UnionOmit<\n      Actions.token.prepareUpdateQuoteTokenSync.Parameters<\n        config['chains'][number],\n        Account\n      >,\n      'chain'\n    >\n\n  export type ReturnValue =\n    Actions.token.prepareUpdateQuoteTokenSync.ReturnValue\n\n  export type ErrorType = Actions.token.prepareUpdateQuoteTokenSync.ErrorType\n}\n\n/**\n * Watches for TIP20 token role admin updates.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchAdminRole(config, {\n *   onRoleAdminUpdated: (args, log) => {\n *     console.log('Role admin updated:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchAdminRole<config extends Config>(\n  config: config,\n  parameters: watchAdminRole.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchAdminRole(client, rest)\n}\n\nexport declare namespace watchAdminRole {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchAdminRole.Parameters\n}\n\n/**\n * Watches for TIP20 token approval events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchApprove(config, {\n *   onApproval: (args, log) => {\n *     console.log('Approval:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchApprove<config extends Config>(\n  config: config,\n  parameters: watchApprove.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchApprove(client, rest)\n}\n\nexport declare namespace watchApprove {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchApprove.Parameters\n}\n\n/**\n * Watches for TIP20 token burn events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchBurn(config, {\n *   onBurn: (args, log) => {\n *     console.log('Burn:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchBurn<config extends Config>(\n  config: config,\n  parameters: watchBurn.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchBurn(client, rest)\n}\n\nexport declare namespace watchBurn {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchBurn.Parameters\n}\n\n/**\n * Watches for new TIP20 tokens created.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchCreate(config, {\n *   onTokenCreated: (args, log) => {\n *     console.log('Token created:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchCreate<config extends Config>(\n  config: config,\n  parameters: watchCreate.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchCreate(client, rest)\n}\n\nexport declare namespace watchCreate {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchCreate.Parameters\n}\n\n/**\n * Watches for TIP20 token mint events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchMint(config, {\n *   onMint: (args, log) => {\n *     console.log('Mint:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchMint<config extends Config>(\n  config: config,\n  parameters: watchMint.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchMint(client, rest)\n}\n\nexport declare namespace watchMint {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchMint.Parameters\n\n  export type ReturnValue = Actions.token.watchMint.ReturnValue\n}\n\n/**\n * Watches for TIP20 token role membership updates.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchRole(config, {\n *   onRoleUpdated: (args, log) => {\n *     console.log('Role updated:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchRole<config extends Config>(\n  config: config,\n  parameters: watchRole.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchRole(client, rest)\n}\n\nexport declare namespace watchRole {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchRole.Parameters\n}\n\n/**\n * Watches for TIP20 token transfer events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchTransfer(config, {\n *   onTransfer: (args, log) => {\n *     console.log('Transfer:', args)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchTransfer<config extends Config>(\n  config: config,\n  parameters: watchTransfer.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchTransfer(client, rest)\n}\n\nexport declare namespace watchTransfer {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchTransfer.Parameters\n}\n\n/**\n * Watches for TIP20 token quote token update events.\n *\n * @example\n * ```ts\n * import { createConfig, http } from '@wagmi/core'\n * import { tempo } from 'viem/chains'\n * import { Actions } from 'tempo.ts/wagmi'\n *\n * const config = createConfig({\n *   chains: [tempoTestnet],\n *   transports: {\n *     [tempo.id]: http(),\n *   },\n * })\n *\n * const unwatch = Actions.token.watchUpdateQuoteToken(config, {\n *   onUpdateQuoteToken: (args, log) => {\n *     if (args.completed)\n *       console.log('quote token update completed:', args.newQuoteToken)\n *     else\n *       console.log('quote token update proposed:', args.newQuoteToken)\n *   },\n * })\n * ```\n *\n * @param config - Config.\n * @param parameters - Parameters.\n * @returns A function to unsubscribe from the event.\n */\nexport function watchUpdateQuoteToken<config extends Config>(\n  config: config,\n  parameters: watchUpdateQuoteToken.Parameters<config>,\n) {\n  const { chainId, ...rest } = parameters\n  const client = config.getClient({ chainId })\n  return Actions.token.watchUpdateQuoteToken(client, rest)\n}\n\nexport declare namespace watchUpdateQuoteToken {\n  export type Parameters<config extends Config> = ChainIdParameter<config> &\n    Actions.token.watchUpdateQuoteToken.Parameters\n}\n", "function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    let dbp;\n    const getDB = () => {\n        if (dbp)\n            return dbp;\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        dbp = promisifyRequest(request);\n        dbp.then((db) => {\n            // It seems like Safari sometimes likes to just close the connection.\n            // It's supposed to fire this event when that happens. Let's hope it does!\n            db.onclose = () => (dbp = undefined);\n        }, () => { });\n        return dbp;\n    };\n    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic  if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { mod } from '@noble/curves/abstract/modular';\nimport { secp256k1 as secp } from '@noble/curves/secp256k1';\nimport { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/legacy';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport {\n  abytes,\n  bytesToHex,\n  concatBytes,\n  createView,\n  hexToBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils';\nimport { createBase58check } from '@scure/base';\n\nconst Point = secp.ProjectivePoint;\nconst base58check = createBase58check(sha256);\n\nfunction bytesToNumber(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  const h = bytes.length === 0 ? '0' : bytesToHex(bytes);\n  return BigInt('0x' + h);\n}\n\nfunction numberToBytes(num: bigint): Uint8Array {\n  if (typeof num !== 'bigint') throw new Error('bigint expected');\n  return hexToBytes(num.toString(16).padStart(64, '0'));\n}\n\nconst MASTER_SECRET = utf8ToBytes('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS: Versions = { private: 0x0488ade4, public: 0x0488b21e };\nexport const HARDENED_OFFSET: number = 0x80000000;\n\nexport interface Versions {\n  private: number;\n  public: number;\n}\n\nconst hash160 = (data: Uint8Array) => ripemd160(sha256(data));\nconst fromU32 = (data: Uint8Array) => createView(data).getUint32(0, false);\nconst toU32 = (n: number) => {\n  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n    throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n  }\n  const buf = new Uint8Array(4);\n  createView(buf).setUint32(0, n, false);\n  return buf;\n};\n\ninterface HDKeyOpt {\n  versions?: Versions;\n  depth?: number;\n  index?: number;\n  parentFingerprint?: number;\n  chainCode?: Uint8Array;\n  publicKey?: Uint8Array;\n  privateKey?: Uint8Array | bigint;\n}\n\nexport class HDKey {\n  get fingerprint(): number {\n    if (!this.pubHash) {\n      throw new Error('No publicKey set!');\n    }\n    return fromU32(this.pubHash);\n  }\n  get identifier(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get pubKeyHash(): Uint8Array | undefined {\n    return this.pubHash;\n  }\n  get privateKey(): Uint8Array | null {\n    return this.privKeyBytes || null;\n  }\n  get publicKey(): Uint8Array | null {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey(): string {\n    const priv = this.privateKey;\n    if (!priv) {\n      throw new Error('No private key');\n    }\n    return base58check.encode(\n      this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv))\n    );\n  }\n  get publicExtendedKey(): string {\n    if (!this.pubKey) {\n      throw new Error('No public key');\n    }\n    return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n\n  public static fromMasterSeed(seed: Uint8Array, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    abytes(seed);\n    if (8 * seed.length < 128 || 8 * seed.length > 512) {\n      throw new Error(\n        'HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n          seed.length\n      );\n    }\n    const I = hmac(sha512, MASTER_SECRET, seed);\n    return new HDKey({\n      versions,\n      chainCode: I.slice(32),\n      privateKey: I.slice(0, 32),\n    });\n  }\n\n  public static fromExtendedKey(base58key: string, versions: Versions = BITCOIN_VERSIONS): HDKey {\n    // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    const keyBuffer: Uint8Array = base58check.decode(base58key);\n    const keyView = createView(keyBuffer);\n    const version = keyView.getUint32(0, false);\n    const opt = {\n      versions,\n      depth: keyBuffer[4],\n      parentFingerprint: keyView.getUint32(5, false),\n      index: keyView.getUint32(9, false),\n      chainCode: keyBuffer.slice(13, 45),\n    };\n    const key = keyBuffer.slice(45);\n    const isPriv = key[0] === 0;\n    if (version !== versions[isPriv ? 'private' : 'public']) {\n      throw new Error('Version mismatch');\n    }\n    if (isPriv) {\n      return new HDKey({ ...opt, privateKey: key.slice(1) });\n    } else {\n      return new HDKey({ ...opt, publicKey: key });\n    }\n  }\n\n  public static fromJSON(json: { xpriv: string }): HDKey {\n    return HDKey.fromExtendedKey(json.xpriv);\n  }\n  public readonly versions: Versions;\n  public readonly depth: number = 0;\n  public readonly index: number = 0;\n  public readonly chainCode: Uint8Array | null = null;\n  public readonly parentFingerprint: number = 0;\n  private privKey?: bigint;\n  private privKeyBytes?: Uint8Array;\n  private pubKey?: Uint8Array;\n  private pubHash: Uint8Array | undefined;\n\n  constructor(opt: HDKeyOpt) {\n    if (!opt || typeof opt !== 'object') {\n      throw new Error('HDKey.constructor must not be called directly');\n    }\n    this.versions = opt.versions || BITCOIN_VERSIONS;\n    this.depth = opt.depth || 0;\n    this.chainCode = opt.chainCode || null;\n    this.index = opt.index || 0;\n    this.parentFingerprint = opt.parentFingerprint || 0;\n    if (!this.depth) {\n      if (this.parentFingerprint || this.index) {\n        throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n      }\n    }\n    if (opt.publicKey && opt.privateKey) {\n      throw new Error('HDKey: publicKey and privateKey at same time.');\n    }\n    if (opt.privateKey) {\n      if (!secp.utils.isValidPrivateKey(opt.privateKey)) {\n        throw new Error('Invalid private key');\n      }\n      this.privKey =\n        typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n      this.privKeyBytes = numberToBytes(this.privKey);\n      this.pubKey = secp.getPublicKey(opt.privateKey, true);\n    } else if (opt.publicKey) {\n      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n    } else {\n      throw new Error('HDKey: no public or private key provided');\n    }\n    this.pubHash = hash160(this.pubKey);\n  }\n\n  public derive(path: string): HDKey {\n    if (!/^[mM]'?/.test(path)) {\n      throw new Error('Path must start with \"m\" or \"M\"');\n    }\n    if (/^[mM]'?$/.test(path)) {\n      return this;\n    }\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    // tslint:disable-next-line\n    let child: HDKey = this;\n    for (const c of parts) {\n      const m = /^(\\d+)('?)$/.exec(c);\n      const m1 = m && m[1];\n      if (!m || m.length !== 3 || typeof m1 !== 'string')\n        throw new Error('invalid child index: ' + c);\n      let idx = +m1;\n      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n        throw new Error('Invalid index');\n      }\n      // hardened key\n      if (m[2] === \"'\") {\n        idx += HARDENED_OFFSET;\n      }\n      child = child.deriveChild(idx);\n    }\n    return child;\n  }\n\n  public deriveChild(index: number): HDKey {\n    if (!this.pubKey || !this.chainCode) {\n      throw new Error('No publicKey or chainCode set');\n    }\n    let data = toU32(index);\n    if (index >= HARDENED_OFFSET) {\n      // Hardened\n      const priv = this.privateKey;\n      if (!priv) {\n        throw new Error('Could not derive hardened child key');\n      }\n      // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n      data = concatBytes(new Uint8Array([0]), priv, data);\n    } else {\n      // Normal child: serP(point(kpar)) || ser32(index)\n      data = concatBytes(this.pubKey, data);\n    }\n    const I = hmac(sha512, this.chainCode, data);\n    const childTweak = bytesToNumber(I.slice(0, 32));\n    const chainCode = I.slice(32);\n    if (!secp.utils.isValidPrivateKey(childTweak)) {\n      throw new Error('Tweak bigger than curve order');\n    }\n    const opt: HDKeyOpt = {\n      versions: this.versions,\n      chainCode,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index,\n    };\n    try {\n      // Private parent key -> private child key\n      if (this.privateKey) {\n        const added = mod(this.privKey! + childTweak, secp.CURVE.n);\n        if (!secp.utils.isValidPrivateKey(added)) {\n          throw new Error('The tweak was out of range or the resulted private key is invalid');\n        }\n        opt.privateKey = added;\n      } else {\n        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n        // Cryptographically impossible: hmac-sha512 preimage would need to be found\n        if (added.equals(Point.ZERO)) {\n          throw new Error('The tweak was equal to negative P, which made the result key invalid');\n        }\n        opt.publicKey = added.toRawBytes(true);\n      }\n      return new HDKey(opt);\n    } catch (err) {\n      return this.deriveChild(index + 1);\n    }\n  }\n\n  public sign(hash: Uint8Array): Uint8Array {\n    if (!this.privateKey) {\n      throw new Error('No privateKey set!');\n    }\n    abytes(hash, 32);\n    return secp.sign(hash, this.privKey!).toCompactRawBytes();\n  }\n\n  public verify(hash: Uint8Array, signature: Uint8Array): boolean {\n    abytes(hash, 32);\n    abytes(signature, 64);\n    if (!this.publicKey) {\n      throw new Error('No publicKey set!');\n    }\n    let sig;\n    try {\n      sig = secp.Signature.fromCompact(signature);\n    } catch (error) {\n      return false;\n    }\n    return secp.verify(sig, hash, this.publicKey);\n  }\n\n  public wipePrivateData(): this {\n    this.privKey = undefined;\n    if (this.privKeyBytes) {\n      this.privKeyBytes.fill(0);\n      this.privKeyBytes = undefined;\n    }\n    return this;\n  }\n  public toJSON(): { xpriv: string; xpub: string } {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey,\n    };\n  }\n\n  private serialize(version: number, key: Uint8Array) {\n    if (!this.chainCode) {\n      throw new Error('No chainCode set');\n    }\n    abytes(key, 33);\n    // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n    return concatBytes(\n      toU32(version),\n      new Uint8Array([this.depth]),\n      toU32(this.parentFingerprint),\n      toU32(this.index),\n      this.chainCode,\n      key\n    );\n  }\n}\n", "import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'\n\nexport type GeneratePrivateKeyErrorType = ToHexErrorType | ErrorType\n\n/**\n * @description Generates a random private key.\n *\n * @returns A randomly generated private key.\n */\nexport function generatePrivateKey(): Hex {\n  return toHex(secp256k1.utils.randomPrivateKey())\n}\n", "// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).\n\nimport type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<accountSource extends AccountSource> =\n  | (accountSource extends Address ? JsonRpcAccount : never)\n  | (accountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<accountSource extends AccountSource>(\n  source: accountSource,\n): GetAccountReturnType<accountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source, { strict: false }))\n      throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<accountSource>\n  }\n\n  if (!isAddress(source.address, { strict: false }))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    nonceManager: source.nonceManager,\n    sign: source.sign,\n    signAuthorization: source.signAuthorization,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<accountSource>\n}\n", "// TODO(v3): Convert to sync.\n\nimport { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport {\n  type HexToBytesErrorType,\n  hexToBytes,\n} from '../../utils/encoding/toBytes.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignParameters<to extends To = 'object'> = {\n  hash: Hex\n  privateKey: Hex\n  to?: to | To | undefined\n}\n\nexport type SignReturnType<to extends To = 'object'> =\n  | (to extends 'object' ? Signature : never)\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type SignErrorType =\n  | HexToBytesErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\nlet extraEntropy: Hex | boolean = false\n\n/**\n * Sets extra entropy for signing functions.\n */\nexport function setSignEntropy(entropy: true | Hex) {\n  if (!entropy) throw new Error('must be a `true` or a hex value.')\n  extraEntropy = entropy\n}\n\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign<to extends To = 'object'>({\n  hash,\n  privateKey,\n  to = 'object',\n}: SignParameters<to>): Promise<SignReturnType<to>> {\n  const { r, s, recovery } = secp256k1.sign(\n    hash.slice(2),\n    privateKey.slice(2),\n    {\n      lowS: true,\n      extraEntropy: isHex(extraEntropy, { strict: false })\n        ? hexToBytes(extraEntropy)\n        : extraEntropy,\n    },\n  )\n  const signature = {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery,\n  }\n  return (() => {\n    if (to === 'bytes' || to === 'hex')\n      return serializeSignature({ ...signature, to })\n    return signature\n  })() as SignReturnType<to>\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AuthorizationRequest,\n  SignedAuthorization,\n} from '../../types/authorization.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type HashAuthorizationErrorType,\n  hashAuthorization,\n} from '../../utils/authorization/hashAuthorization.js'\nimport {\n  type SignErrorType,\n  type SignParameters,\n  type SignReturnType,\n  sign,\n} from './sign.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignAuthorizationParameters<to extends To = 'object'> =\n  AuthorizationRequest & {\n    /** The private key to sign with. */\n    privateKey: Hex\n    to?: SignParameters<to>['to'] | undefined\n  }\n\nexport type SignAuthorizationReturnType<to extends To = 'object'> = Prettify<\n  to extends 'object' ? SignedAuthorization : SignReturnType<to>\n>\n\nexport type SignAuthorizationErrorType =\n  | SignErrorType\n  | HashAuthorizationErrorType\n  | ErrorType\n\n/**\n * Signs an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n */\nexport async function signAuthorization<to extends To = 'object'>(\n  parameters: SignAuthorizationParameters<to>,\n): Promise<SignAuthorizationReturnType<to>> {\n  const { chainId, nonce, privateKey, to = 'object' } = parameters\n  const address = parameters.contractAddress ?? parameters.address\n  const signature = await sign({\n    hash: hashAuthorization({ address, chainId, nonce }),\n    privateKey,\n    to,\n  })\n  if (to === 'object')\n    return {\n      address,\n      chainId,\n      nonce,\n      ...(signature as Signature),\n    } as any\n  return signature as any\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport {\n  type HashMessageErrorType,\n  hashMessage,\n} from '../../utils/signature/hashMessage.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignMessageParameters = {\n  /** The message to sign. */\n  message: SignableMessage\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignMessageReturnType = Hex\n\nexport type SignMessageErrorType =\n  | SignErrorType\n  | HashMessageErrorType\n  | ErrorType\n\n/**\n * @description Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):\n * `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * @returns The signature.\n */\nexport async function signMessage({\n  message,\n  privateKey,\n}: SignMessageParameters): Promise<SignMessageReturnType> {\n  return await sign({ hash: hashMessage(message), privateKey, to: 'hex' })\n}\n", "import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerialized,\n} from '../../types/transaction.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\nimport type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'\nimport {\n  type SerializeTransactionFn,\n  serializeTransaction,\n} from '../../utils/transaction/serializeTransaction.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTransactionParameters<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n> = {\n  privateKey: Hex\n  transaction: transaction\n  serializer?: serializer | undefined\n}\n\nexport type SignTransactionReturnType<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n> = TransactionSerialized<GetTransactionType<transaction>>\n\nexport type SignTransactionErrorType =\n  | Keccak256ErrorType\n  | SignErrorType\n  | ErrorType\n\nexport async function signTransaction<\n  serializer extends\n    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,\n  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],\n>(\n  parameters: SignTransactionParameters<serializer, transaction>,\n): Promise<SignTransactionReturnType<serializer, transaction>> {\n  const {\n    privateKey,\n    transaction,\n    serializer = serializeTransaction,\n  } = parameters\n\n  const signableTransaction = (() => {\n    // For EIP-4844 Transactions, we want to sign the transaction payload body (tx_payload_body) without the sidecars (ie. without the network wrapper).\n    // See: https://github.com/ethereum/EIPs/blob/e00f4daa66bd56e2dbd5f1d36d09fd613811a48b/EIPS/eip-4844.md#networking\n    if (transaction.type === 'eip4844')\n      return {\n        ...transaction,\n        sidecars: false,\n      }\n    return transaction\n  })()\n\n  const signature = await sign({\n    hash: keccak256(await serializer(signableTransaction)),\n    privateKey,\n  })\n  return (await serializer(\n    transaction,\n    signature,\n  )) as SignTransactionReturnType<serializer, transaction>\n}\n", "import type { TypedData } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type HashTypedDataErrorType,\n  hashTypedData,\n} from '../../utils/signature/hashTypedData.js'\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType> & {\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType =\n  | HashTypedDataErrorType\n  | SignErrorType\n  | ErrorType\n\n/**\n * @description Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712):\n * `sign(keccak256(\"\\x19\\x01\"  domainSeparator  hashStruct(message)))`.\n *\n * @returns The signature.\n */\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: SignTypedDataParameters<typedData, primaryType>,\n): Promise<SignTypedDataReturnType> {\n  const { privateKey, ...typedData } =\n    parameters as unknown as SignTypedDataParameters\n  return await sign({\n    hash: hashTypedData(typedData),\n    privateKey,\n    to: 'hex',\n  })\n}\n", "import { secp256k1 } from '@noble/curves/secp256k1'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'\nimport type { NonceManager } from '../utils/nonceManager.js'\nimport { type ToAccountErrorType, toAccount } from './toAccount.js'\nimport type { PrivateKeyAccount } from './types.js'\nimport {\n  type PublicKeyToAddressErrorType,\n  publicKeyToAddress,\n} from './utils/publicKeyToAddress.js'\nimport { type SignErrorType, sign } from './utils/sign.js'\nimport { signAuthorization } from './utils/signAuthorization.js'\nimport { type SignMessageErrorType, signMessage } from './utils/signMessage.js'\nimport {\n  type SignTransactionErrorType,\n  signTransaction,\n} from './utils/signTransaction.js'\nimport {\n  type SignTypedDataErrorType,\n  signTypedData,\n} from './utils/signTypedData.js'\n\nexport type PrivateKeyToAccountOptions = {\n  nonceManager?: NonceManager | undefined\n}\n\nexport type PrivateKeyToAccountErrorType =\n  | ToAccountErrorType\n  | ToHexErrorType\n  | PublicKeyToAddressErrorType\n  | SignErrorType\n  | SignMessageErrorType\n  | SignTransactionErrorType\n  | SignTypedDataErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a private key.\n *\n * @returns A Private Key Account.\n */\nexport function privateKeyToAccount(\n  privateKey: Hex,\n  options: PrivateKeyToAccountOptions = {},\n): PrivateKeyAccount {\n  const { nonceManager } = options\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false))\n  const address = publicKeyToAddress(publicKey)\n\n  const account = toAccount({\n    address,\n    nonceManager,\n    async sign({ hash }) {\n      return sign({ hash, privateKey, to: 'hex' })\n    },\n    async signAuthorization(authorization) {\n      return signAuthorization({ ...authorization, privateKey })\n    },\n    async signMessage({ message }) {\n      return signMessage({ message, privateKey })\n    },\n    async signTransaction(transaction, { serializer } = {}) {\n      return signTransaction({ privateKey, transaction, serializer })\n    },\n    async signTypedData(typedData) {\n      return signTypedData({ ...typedData, privateKey } as any)\n    },\n  })\n\n  return {\n    ...account,\n    publicKey,\n    source: 'privateKey',\n  } as PrivateKeyAccount\n}\n", "export const wordlist = `abdikace\nabeceda\nadresa\nagrese\nakce\naktovka\nalej\nalkohol\namputace\nananas\nandulka\nanekdota\nanketa\nantika\nanulovat\narcha\narogance\nasfalt\nasistent\naspirace\nastma\nastronom\natlas\natletika\natol\nautobus\nazyl\nbabka\nbachor\nbacil\nbaculka\nbadatel\nbageta\nbagr\nbahno\nbakterie\nbalada\nbaletka\nbalkon\nbalonek\nbalvan\nbalza\nbambus\nbankomat\nbarbar\nbaret\nbarman\nbaroko\nbarva\nbaterka\nbatoh\nbavlna\nbazalka\nbazilika\nbazuka\nbedna\nberan\nbeseda\nbestie\nbeton\nbezinka\nbezmoc\nbeztak\nbicykl\nbidlo\nbiftek\nbikiny\nbilance\nbiograf\nbiolog\nbitva\nbizon\nblahobyt\nblatouch\nblecha\nbledule\nblesk\nblikat\nblizna\nblokovat\nbloudit\nblud\nbobek\nbobr\nbodlina\nbodnout\nbohatost\nbojkot\nbojovat\nbokorys\nbolest\nborec\nborovice\nbota\nboubel\nbouchat\nbouda\nboule\nbourat\nboxer\nbradavka\nbrambora\nbranka\nbratr\nbrepta\nbriketa\nbrko\nbrloh\nbronz\nbroskev\nbrunetka\nbrusinka\nbrzda\nbrzy\nbublina\nbubnovat\nbuchta\nbuditel\nbudka\nbudova\nbufet\nbujarost\nbukvice\nbuldok\nbulva\nbunda\nbunkr\nburza\nbutik\nbuvol\nbuzola\nbydlet\nbylina\nbytovka\nbzukot\ncapart\ncarevna\ncedr\ncedule\ncejch\ncejn\ncela\nceler\ncelkem\ncelnice\ncenina\ncennost\ncenovka\ncentrum\ncenzor\ncestopis\ncetka\nchalupa\nchapadlo\ncharita\nchata\nchechtat\nchemie\nchichot\nchirurg\nchlad\nchleba\nchlubit\nchmel\nchmura\nchobot\nchochol\nchodba\ncholera\nchomout\nchopit\nchoroba\nchov\nchrapot\nchrlit\nchrt\nchrup\nchtivost\nchudina\nchutnat\nchvat\nchvilka\nchvost\nchyba\nchystat\nchytit\ncibule\ncigareta\ncihelna\ncihla\ncinkot\ncirkus\ncisterna\ncitace\ncitrus\ncizinec\ncizost\nclona\ncokoliv\ncouvat\nctitel\nctnost\ncudnost\ncuketa\ncukr\ncupot\ncvaknout\ncval\ncvik\ncvrkot\ncyklista\ndaleko\ndareba\ndatel\ndatum\ndcera\ndebata\ndechovka\ndecibel\ndeficit\ndeflace\ndekl\ndekret\ndemokrat\ndeprese\nderby\ndeska\ndetektiv\ndikobraz\ndiktovat\ndioda\ndiplom\ndisk\ndisplej\ndivadlo\ndivoch\ndlaha\ndlouho\ndluhopis\ndnes\ndobro\ndobytek\ndocent\ndochutit\ndodnes\ndohled\ndohoda\ndohra\ndojem\ndojnice\ndoklad\ndokola\ndoktor\ndokument\ndolar\ndoleva\ndolina\ndoma\ndominant\ndomluvit\ndomov\ndonutit\ndopad\ndopis\ndoplnit\ndoposud\ndoprovod\ndopustit\ndorazit\ndorost\ndort\ndosah\ndoslov\ndostatek\ndosud\ndosyta\ndotaz\ndotek\ndotknout\ndoufat\ndoutnat\ndovozce\ndozadu\ndoznat\ndozorce\ndrahota\ndrak\ndramatik\ndravec\ndraze\ndrdol\ndrobnost\ndrogerie\ndrozd\ndrsnost\ndrtit\ndrzost\nduben\nduchovno\ndudek\nduha\nduhovka\ndusit\ndusno\ndutost\ndvojice\ndvorec\ndynamit\nekolog\nekonomie\nelektron\nelipsa\nemail\nemise\nemoce\nempatie\nepizoda\nepocha\nepopej\nepos\nesej\nesence\neskorta\neskymo\netiketa\neuforie\nevoluce\nexekuce\nexkurze\nexpedice\nexploze\nexport\nextrakt\nfacka\nfajfka\nfakulta\nfanatik\nfantazie\nfarmacie\nfavorit\nfazole\nfederace\nfejeton\nfenka\nfialka\nfigurant\nfilozof\nfiltr\nfinance\nfinta\nfixace\nfjord\nflanel\nflirt\nflotila\nfond\nfosfor\nfotbal\nfotka\nfoton\nfrakce\nfreska\nfronta\nfukar\nfunkce\nfyzika\ngaleje\ngarant\ngenetika\ngeolog\ngilotina\nglazura\nglejt\ngolem\ngolfista\ngotika\ngraf\ngramofon\ngranule\ngrep\ngril\ngrog\ngroteska\nguma\nhadice\nhadr\nhala\nhalenka\nhanba\nhanopis\nharfa\nharpuna\nhavran\nhebkost\nhejkal\nhejno\nhejtman\nhektar\nhelma\nhematom\nherec\nherna\nheslo\nhezky\nhistorik\nhladovka\nhlasivky\nhlava\nhledat\nhlen\nhlodavec\nhloh\nhloupost\nhltat\nhlubina\nhluchota\nhmat\nhmota\nhmyz\nhnis\nhnojivo\nhnout\nhoblina\nhoboj\nhoch\nhodiny\nhodlat\nhodnota\nhodovat\nhojnost\nhokej\nholinka\nholka\nholub\nhomole\nhonitba\nhonorace\nhoral\nhorda\nhorizont\nhorko\nhorlivec\nhormon\nhornina\nhoroskop\nhorstvo\nhospoda\nhostina\nhotovost\nhouba\nhouf\nhoupat\nhouska\nhovor\nhradba\nhranice\nhravost\nhrazda\nhrbolek\nhrdina\nhrdlo\nhrdost\nhrnek\nhrobka\nhromada\nhrot\nhrouda\nhrozen\nhrstka\nhrubost\nhryzat\nhubenost\nhubnout\nhudba\nhukot\nhumr\nhusita\nhustota\nhvozd\nhybnost\nhydrant\nhygiena\nhymna\nhysterik\nidylka\nihned\nikona\niluze\nimunita\ninfekce\ninflace\ninkaso\ninovace\ninspekce\ninternet\ninvalida\ninvestor\ninzerce\nironie\njablko\njachta\njahoda\njakmile\njakost\njalovec\njantar\njarmark\njaro\njasan\njasno\njatka\njavor\njazyk\njedinec\njedle\njednatel\njehlan\njekot\njelen\njelito\njemnost\njenom\njepice\njeseter\njevit\njezdec\njezero\njinak\njindy\njinoch\njiskra\njistota\njitrnice\njizva\njmenovat\njogurt\njurta\nkabaret\nkabel\nkabinet\nkachna\nkadet\nkadidlo\nkahan\nkajak\nkajuta\nkakao\nkaktus\nkalamita\nkalhoty\nkalibr\nkalnost\nkamera\nkamkoliv\nkamna\nkanibal\nkanoe\nkantor\nkapalina\nkapela\nkapitola\nkapka\nkaple\nkapota\nkapr\nkapusta\nkapybara\nkaramel\nkarotka\nkarton\nkasa\nkatalog\nkatedra\nkauce\nkauza\nkavalec\nkazajka\nkazeta\nkazivost\nkdekoliv\nkdesi\nkedluben\nkemp\nkeramika\nkino\nklacek\nkladivo\nklam\nklapot\nklasika\nklaun\nklec\nklenba\nklepat\nklesnout\nklid\nklima\nklisna\nklobouk\nklokan\nklopa\nkloub\nklubovna\nklusat\nkluzkost\nkmen\nkmitat\nkmotr\nkniha\nknot\nkoalice\nkoberec\nkobka\nkobliha\nkobyla\nkocour\nkohout\nkojenec\nkokos\nkoktejl\nkolaps\nkoleda\nkolize\nkolo\nkomando\nkometa\nkomik\nkomnata\nkomora\nkompas\nkomunita\nkonat\nkoncept\nkondice\nkonec\nkonfese\nkongres\nkonina\nkonkurs\nkontakt\nkonzerva\nkopanec\nkopie\nkopnout\nkoprovka\nkorbel\nkorektor\nkormidlo\nkoroptev\nkorpus\nkoruna\nkoryto\nkorzet\nkosatec\nkostka\nkotel\nkotleta\nkotoul\nkoukat\nkoupelna\nkousek\nkouzlo\nkovboj\nkoza\nkozoroh\nkrabice\nkrach\nkrajina\nkralovat\nkrasopis\nkravata\nkredit\nkrejcar\nkresba\nkreveta\nkriket\nkritik\nkrize\nkrkavec\nkrmelec\nkrmivo\nkrocan\nkrok\nkronika\nkropit\nkroupa\nkrovka\nkrtek\nkruhadlo\nkrupice\nkrutost\nkrvinka\nkrychle\nkrypta\nkrystal\nkryt\nkudlanka\nkufr\nkujnost\nkukla\nkulajda\nkulich\nkulka\nkulomet\nkultura\nkuna\nkupodivu\nkurt\nkurzor\nkutil\nkvalita\nkvasinka\nkvestor\nkynolog\nkyselina\nkytara\nkytice\nkytka\nkytovec\nkyvadlo\nlabrador\nlachtan\nladnost\nlaik\nlakomec\nlamela\nlampa\nlanovka\nlasice\nlaso\nlastura\nlatinka\nlavina\nlebka\nleckdy\nleden\nlednice\nledovka\nledvina\nlegenda\nlegie\nlegrace\nlehce\nlehkost\nlehnout\nlektvar\nlenochod\nlentilka\nlepenka\nlepidlo\nletadlo\nletec\nletmo\nletokruh\nlevhart\nlevitace\nlevobok\nlibra\nlichotka\nlidojed\nlidskost\nlihovina\nlijavec\nlilek\nlimetka\nlinie\nlinka\nlinoleum\nlistopad\nlitina\nlitovat\nlobista\nlodivod\nlogika\nlogoped\nlokalita\nloket\nlomcovat\nlopata\nlopuch\nlord\nlosos\nlotr\nloudal\nlouh\nlouka\nlouskat\nlovec\nlstivost\nlucerna\nlucifer\nlump\nlusk\nlustrace\nlvice\nlyra\nlyrika\nlysina\nmadam\nmadlo\nmagistr\nmahagon\nmajetek\nmajitel\nmajorita\nmakak\nmakovice\nmakrela\nmalba\nmalina\nmalovat\nmalvice\nmaminka\nmandle\nmanko\nmarnost\nmasakr\nmaskot\nmasopust\nmatice\nmatrika\nmaturita\nmazanec\nmazivo\nmazlit\nmazurka\nmdloba\nmechanik\nmeditace\nmedovina\nmelasa\nmeloun\nmentolka\nmetla\nmetoda\nmetr\nmezera\nmigrace\nmihnout\nmihule\nmikina\nmikrofon\nmilenec\nmilimetr\nmilost\nmimika\nmincovna\nminibar\nminomet\nminulost\nmiska\nmistr\nmixovat\nmladost\nmlha\nmlhovina\nmlok\nmlsat\nmluvit\nmnich\nmnohem\nmobil\nmocnost\nmodelka\nmodlitba\nmohyla\nmokro\nmolekula\nmomentka\nmonarcha\nmonokl\nmonstrum\nmontovat\nmonzun\nmosaz\nmoskyt\nmost\nmotivace\nmotorka\nmotyka\nmoucha\nmoudrost\nmozaika\nmozek\nmozol\nmramor\nmravenec\nmrkev\nmrtvola\nmrzet\nmrzutost\nmstitel\nmudrc\nmuflon\nmulat\nmumie\nmunice\nmuset\nmutace\nmuzeum\nmuzikant\nmyslivec\nmzda\nnabourat\nnachytat\nnadace\nnadbytek\nnadhoz\nnadobro\nnadpis\nnahlas\nnahnat\nnahodile\nnahradit\nnaivita\nnajednou\nnajisto\nnajmout\nnaklonit\nnakonec\nnakrmit\nnalevo\nnamazat\nnamluvit\nnanometr\nnaoko\nnaopak\nnaostro\nnapadat\nnapevno\nnaplnit\nnapnout\nnaposled\nnaprosto\nnarodit\nnaruby\nnarychlo\nnasadit\nnasekat\nnaslepo\nnastat\nnatolik\nnavenek\nnavrch\nnavzdory\nnazvat\nnebe\nnechat\nnecky\nnedaleko\nnedbat\nneduh\nnegace\nnehet\nnehoda\nnejen\nnejprve\nneklid\nnelibost\nnemilost\nnemoc\nneochota\nneonka\nnepokoj\nnerost\nnerv\nnesmysl\nnesoulad\nnetvor\nneuron\nnevina\nnezvykle\nnicota\nnijak\nnikam\nnikdy\nnikl\nnikterak\nnitro\nnocleh\nnohavice\nnominace\nnora\nnorek\nnositel\nnosnost\nnouze\nnoviny\nnovota\nnozdra\nnuda\nnudle\nnuget\nnutit\nnutnost\nnutrie\nnymfa\nobal\nobarvit\nobava\nobdiv\nobec\nobehnat\nobejmout\nobezita\nobhajoba\nobilnice\nobjasnit\nobjekt\nobklopit\noblast\noblek\nobliba\nobloha\nobluda\nobnos\nobohatit\nobojek\nobout\nobrazec\nobrna\nobruba\nobrys\nobsah\nobsluha\nobstarat\nobuv\nobvaz\nobvinit\nobvod\nobvykle\nobyvatel\nobzor\nocas\nocel\nocenit\nochladit\nochota\nochrana\nocitnout\nodboj\nodbyt\nodchod\nodcizit\nodebrat\nodeslat\nodevzdat\nodezva\nodhadce\nodhodit\nodjet\nodjinud\nodkaz\nodkoupit\nodliv\nodluka\nodmlka\nodolnost\nodpad\nodpis\nodplout\nodpor\nodpustit\nodpykat\nodrazka\nodsoudit\nodstup\nodsun\nodtok\nodtud\nodvaha\nodveta\nodvolat\nodvracet\nodznak\nofina\nofsajd\nohlas\nohnisko\nohrada\nohrozit\nohryzek\nokap\nokenice\noklika\nokno\nokouzlit\nokovy\nokrasa\nokres\nokrsek\nokruh\nokupant\nokurka\nokusit\nolejnina\nolizovat\nomak\nomeleta\nomezit\nomladina\nomlouvat\nomluva\nomyl\nonehdy\nopakovat\nopasek\noperace\nopice\nopilost\nopisovat\nopora\nopozice\nopravdu\noproti\norbital\norchestr\norgie\norlice\norloj\nortel\nosada\noschnout\nosika\nosivo\noslava\noslepit\noslnit\noslovit\nosnova\nosoba\nosolit\nospalec\nosten\nostraha\nostuda\nostych\nosvojit\noteplit\notisk\notop\notrhat\notrlost\notrok\notruby\notvor\novanout\novar\noves\novlivnit\novoce\noxid\nozdoba\npachatel\npacient\npadouch\npahorek\npakt\npalanda\npalec\npalivo\npaluba\npamflet\npamlsek\npanenka\npanika\npanna\npanovat\npanstvo\npantofle\npaprika\nparketa\nparodie\nparta\nparuka\nparyba\npaseka\npasivita\npastelka\npatent\npatrona\npavouk\npazneht\npazourek\npecka\npedagog\npejsek\npeklo\npeloton\npenalta\npendrek\npenze\nperiskop\npero\npestrost\npetarda\npetice\npetrolej\npevnina\npexeso\npianista\npiha\npijavice\npikle\npiknik\npilina\npilnost\npilulka\npinzeta\npipeta\npisatel\npistole\npitevna\npivnice\npivovar\nplacenta\nplakat\nplamen\nplaneta\nplastika\nplatit\nplavidlo\nplaz\nplech\nplemeno\nplenta\nples\npletivo\nplevel\nplivat\nplnit\nplno\nplocha\nplodina\nplomba\nplout\npluk\nplyn\npobavit\npobyt\npochod\npocit\npoctivec\npodat\npodcenit\npodepsat\npodhled\npodivit\npodklad\npodmanit\npodnik\npodoba\npodpora\npodraz\npodstata\npodvod\npodzim\npoezie\npohanka\npohnutka\npohovor\npohroma\npohyb\npointa\npojistka\npojmout\npokazit\npokles\npokoj\npokrok\npokuta\npokyn\npoledne\npolibek\npolknout\npoloha\npolynom\npomalu\npominout\npomlka\npomoc\npomsta\npomyslet\nponechat\nponorka\nponurost\npopadat\npopel\npopisek\npoplach\npoprosit\npopsat\npopud\nporadce\nporce\nporod\nporucha\nporyv\nposadit\nposed\nposila\nposkok\nposlanec\nposoudit\npospolu\npostava\nposudek\nposyp\npotah\npotkan\npotlesk\npotomek\npotrava\npotupa\npotvora\npoukaz\npouto\npouzdro\npovaha\npovidla\npovlak\npovoz\npovrch\npovstat\npovyk\npovzdech\npozdrav\npozemek\npoznatek\npozor\npozvat\npracovat\nprahory\npraktika\nprales\npraotec\npraporek\nprase\npravda\nprincip\nprkno\nprobudit\nprocento\nprodej\nprofese\nprohra\nprojekt\nprolomit\npromile\npronikat\npropad\nprorok\nprosba\nproton\nproutek\nprovaz\nprskavka\nprsten\nprudkost\nprut\nprvek\nprvohory\npsanec\npsovod\npstruh\nptactvo\npuberta\npuch\npudl\npukavec\npuklina\npukrle\npult\npumpa\npunc\npupen\npusa\npusinka\npustina\nputovat\nputyka\npyramida\npysk\npytel\nracek\nrachot\nradiace\nradnice\nradon\nraft\nragby\nraketa\nrakovina\nrameno\nrampouch\nrande\nrarach\nrarita\nrasovna\nrastr\nratolest\nrazance\nrazidlo\nreagovat\nreakce\nrecept\nredaktor\nreferent\nreflex\nrejnok\nreklama\nrekord\nrekrut\nrektor\nreputace\nrevize\nrevma\nrevolver\nrezerva\nriskovat\nriziko\nrobotika\nrodokmen\nrohovka\nrokle\nrokoko\nromaneto\nropovod\nropucha\nrorejs\nrosol\nrostlina\nrotmistr\nrotoped\nrotunda\nroubenka\nroucho\nroup\nroura\nrovina\nrovnice\nrozbor\nrozchod\nrozdat\nrozeznat\nrozhodce\nrozinka\nrozjezd\nrozkaz\nrozloha\nrozmar\nrozpad\nrozruch\nrozsah\nroztok\nrozum\nrozvod\nrubrika\nruchadlo\nrukavice\nrukopis\nryba\nrybolov\nrychlost\nrydlo\nrypadlo\nrytina\nryzost\nsadista\nsahat\nsako\nsamec\nsamizdat\nsamota\nsanitka\nsardinka\nsasanka\nsatelit\nsazba\nsazenice\nsbor\nschovat\nsebranka\nsecese\nsedadlo\nsediment\nsedlo\nsehnat\nsejmout\nsekera\nsekta\nsekunda\nsekvoje\nsemeno\nseno\nservis\nsesadit\nseshora\nseskok\nseslat\nsestra\nsesuv\nsesypat\nsetba\nsetina\nsetkat\nsetnout\nsetrvat\nsever\nseznam\nshoda\nshrnout\nsifon\nsilnice\nsirka\nsirotek\nsirup\nsituace\nskafandr\nskalisko\nskanzen\nskaut\nskeptik\nskica\nskladba\nsklenice\nsklo\nskluz\nskoba\nskokan\nskoro\nskripta\nskrz\nskupina\nskvost\nskvrna\nslabika\nsladidlo\nslanina\nslast\nslavnost\nsledovat\nslepec\nsleva\nslezina\nslib\nslina\nsliznice\nslon\nsloupek\nslovo\nsluch\nsluha\nslunce\nslupka\nslza\nsmaragd\nsmetana\nsmilstvo\nsmlouva\nsmog\nsmrad\nsmrk\nsmrtka\nsmutek\nsmysl\nsnad\nsnaha\nsnob\nsobota\nsocha\nsodovka\nsokol\nsopka\nsotva\nsouboj\nsoucit\nsoudce\nsouhlas\nsoulad\nsoumrak\nsouprava\nsoused\nsoutok\nsouviset\nspalovna\nspasitel\nspis\nsplav\nspodek\nspojenec\nspolu\nsponzor\nspornost\nspousta\nsprcha\nspustit\nsranda\nsraz\nsrdce\nsrna\nsrnec\nsrovnat\nsrpen\nsrst\nsrub\nstanice\nstarosta\nstatika\nstavba\nstehno\nstezka\nstodola\nstolek\nstopa\nstorno\nstoupat\nstrach\nstres\nstrhnout\nstrom\nstruna\nstudna\nstupnice\nstvol\nstyk\nsubjekt\nsubtropy\nsuchar\nsudost\nsukno\nsundat\nsunout\nsurikata\nsurovina\nsvah\nsvalstvo\nsvetr\nsvatba\nsvazek\nsvisle\nsvitek\nsvoboda\nsvodidlo\nsvorka\nsvrab\nsykavka\nsykot\nsynek\nsynovec\nsypat\nsypkost\nsyrovost\nsysel\nsytost\ntabletka\ntabule\ntahoun\ntajemno\ntajfun\ntajga\ntajit\ntajnost\ntaktika\ntamhle\ntampon\ntancovat\ntanec\ntanker\ntapeta\ntavenina\ntazatel\ntechnika\ntehdy\ntekutina\ntelefon\ntemnota\ntendence\ntenista\ntenor\nteplota\ntepna\nteprve\nterapie\ntermoska\ntextil\nticho\ntiskopis\ntitulek\ntkadlec\ntkanina\ntlapka\ntleskat\ntlukot\ntlupa\ntmel\ntoaleta\ntopinka\ntopol\ntorzo\ntouha\ntoulec\ntradice\ntraktor\ntramp\ntrasa\ntraverza\ntrefit\ntrest\ntrezor\ntrhavina\ntrhlina\ntrochu\ntrojice\ntroska\ntrouba\ntrpce\ntrpitel\ntrpkost\ntrubec\ntruchlit\ntruhlice\ntrus\ntrvat\ntudy\ntuhnout\ntuhost\ntundra\nturista\nturnaj\ntuzemsko\ntvaroh\ntvorba\ntvrdost\ntvrz\ntygr\ntykev\nubohost\nuboze\nubrat\nubrousek\nubrus\nubytovna\nucho\nuctivost\nudivit\nuhradit\nujednat\nujistit\nujmout\nukazatel\nuklidnit\nuklonit\nukotvit\nukrojit\nulice\nulita\nulovit\numyvadlo\nunavit\nuniforma\nuniknout\nupadnout\nuplatnit\nuplynout\nupoutat\nupravit\nuran\nurazit\nusednout\nusilovat\nusmrtit\nusnadnit\nusnout\nusoudit\nustlat\nustrnout\nutahovat\nutkat\nutlumit\nutonout\nutopenec\nutrousit\nuvalit\nuvolnit\nuvozovka\nuzdravit\nuzel\nuzenina\nuzlina\nuznat\nvagon\nvalcha\nvaloun\nvana\nvandal\nvanilka\nvaran\nvarhany\nvarovat\nvcelku\nvchod\nvdova\nvedro\nvegetace\nvejce\nvelbloud\nveletrh\nvelitel\nvelmoc\nvelryba\nvenkov\nveranda\nverze\nveselka\nveskrze\nvesnice\nvespodu\nvesta\nveterina\nveverka\nvibrace\nvichr\nvideohra\nvidina\nvidle\nvila\nvinice\nviset\nvitalita\nvize\nvizitka\nvjezd\nvklad\nvkus\nvlajka\nvlak\nvlasec\nvlevo\nvlhkost\nvliv\nvlnovka\nvloupat\nvnucovat\nvnuk\nvoda\nvodivost\nvodoznak\nvodstvo\nvojensky\nvojna\nvojsko\nvolant\nvolba\nvolit\nvolno\nvoskovka\nvozidlo\nvozovna\nvpravo\nvrabec\nvracet\nvrah\nvrata\nvrba\nvrcholek\nvrhat\nvrstva\nvrtule\nvsadit\nvstoupit\nvstup\nvtip\nvybavit\nvybrat\nvychovat\nvydat\nvydra\nvyfotit\nvyhledat\nvyhnout\nvyhodit\nvyhradit\nvyhubit\nvyjasnit\nvyjet\nvyjmout\nvyklopit\nvykonat\nvylekat\nvymazat\nvymezit\nvymizet\nvymyslet\nvynechat\nvynikat\nvynutit\nvypadat\nvyplatit\nvypravit\nvypustit\nvyrazit\nvyrovnat\nvyrvat\nvyslovit\nvysoko\nvystavit\nvysunout\nvysypat\nvytasit\nvytesat\nvytratit\nvyvinout\nvyvolat\nvyvrhel\nvyzdobit\nvyznat\nvzadu\nvzbudit\nvzchopit\nvzdor\nvzduch\nvzdychat\nvzestup\nvzhledem\nvzkaz\nvzlykat\nvznik\nvzorek\nvzpoura\nvztah\nvztek\nxylofon\nzabrat\nzabydlet\nzachovat\nzadarmo\nzadusit\nzafoukat\nzahltit\nzahodit\nzahrada\nzahynout\nzajatec\nzajet\nzajistit\nzaklepat\nzakoupit\nzalepit\nzamezit\nzamotat\nzamyslet\nzanechat\nzanikat\nzaplatit\nzapojit\nzapsat\nzarazit\nzastavit\nzasunout\nzatajit\nzatemnit\nzatknout\nzaujmout\nzavalit\nzavelet\nzavinit\nzavolat\nzavrtat\nzazvonit\nzbavit\nzbrusu\nzbudovat\nzbytek\nzdaleka\nzdarma\nzdatnost\nzdivo\nzdobit\nzdroj\nzdvih\nzdymadlo\nzelenina\nzeman\nzemina\nzeptat\nzezadu\nzezdola\nzhatit\nzhltnout\nzhluboka\nzhotovit\nzhruba\nzima\nzimnice\nzjemnit\nzklamat\nzkoumat\nzkratka\nzkumavka\nzlato\nzlehka\nzloba\nzlom\nzlost\nzlozvyk\nzmapovat\nzmar\nzmatek\nzmije\nzmizet\nzmocnit\nzmodrat\nzmrzlina\nzmutovat\nznak\nznalost\nznamenat\nznovu\nzobrazit\nzotavit\nzoubek\nzoufale\nzplodit\nzpomalit\nzprava\nzprostit\nzprudka\nzprvu\nzrada\nzranit\nzrcadlo\nzrnitost\nzrno\nzrovna\nzrychlit\nzrzavost\nzticha\nztratit\nzubovina\nzubr\nzvednout\nzvenku\nzvesela\nzvon\nzvrat\nzvukovod\nzvyk`.split('\\n');\n", "export const wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n", "export const wordlist = `abaisser\nabandon\nabdiquer\nabeille\nabolir\naborder\naboutir\naboyer\nabrasif\nabreuver\nabriter\nabroger\nabrupt\nabsence\nabsolu\nabsurde\nabusif\nabyssal\nacademie\nacajou\nacarien\naccabler\naccepter\nacclamer\naccolade\naccroche\naccuser\nacerbe\nachat\nacheter\naciduler\nacier\nacompte\nacquerir\nacronyme\nacteur\nactif\nactuel\nadepte\nadequat\nadhesif\nadjectif\nadjuger\nadmettre\nadmirer\nadopter\nadorer\nadoucir\nadresse\nadroit\nadulte\nadverbe\naerer\naeronef\naffaire\naffecter\naffiche\naffreux\naffubler\nagacer\nagencer\nagile\nagiter\nagrafer\nagreable\nagrume\naider\naiguille\nailier\naimable\naisance\najouter\najuster\nalarmer\nalchimie\nalerte\nalgebre\nalgue\naliener\naliment\nalleger\nalliage\nallouer\nallumer\nalourdir\nalpaga\naltesse\nalveole\namateur\nambigu\nambre\namenager\namertume\namidon\namiral\namorcer\namour\namovible\namphibie\nampleur\namusant\nanalyse\nanaphore\nanarchie\nanatomie\nancien\naneantir\nangle\nangoisse\nanguleux\nanimal\nannexer\nannonce\nannuel\nanodin\nanomalie\nanonyme\nanormal\nantenne\nantidote\nanxieux\napaiser\naperitif\naplanir\napologie\nappareil\nappeler\napporter\nappuyer\naquarium\naqueduc\narbitre\narbuste\nardeur\nardoise\nargent\narlequin\narmature\narmement\narmoire\narmure\narpenter\narracher\narriver\narroser\narsenic\narteriel\narticle\naspect\nasphalte\naspirer\nassaut\nasservir\nassiette\nassocier\nassurer\nasticot\nastre\nastuce\natelier\natome\natrium\natroce\nattaque\nattentif\nattirer\nattraper\naubaine\nauberge\naudace\naudible\naugurer\naurore\nautomne\nautruche\navaler\navancer\navarice\navenir\naverse\naveugle\naviateur\navide\navion\naviser\navoine\navouer\navril\naxial\naxiome\nbadge\nbafouer\nbagage\nbaguette\nbaignade\nbalancer\nbalcon\nbaleine\nbalisage\nbambin\nbancaire\nbandage\nbanlieue\nbanniere\nbanquier\nbarbier\nbaril\nbaron\nbarque\nbarrage\nbassin\nbastion\nbataille\nbateau\nbatterie\nbaudrier\nbavarder\nbelette\nbelier\nbelote\nbenefice\nberceau\nberger\nberline\nbermuda\nbesace\nbesogne\nbetail\nbeurre\nbiberon\nbicycle\nbidule\nbijou\nbilan\nbilingue\nbillard\nbinaire\nbiologie\nbiopsie\nbiotype\nbiscuit\nbison\nbistouri\nbitume\nbizarre\nblafard\nblague\nblanchir\nblessant\nblinder\nblond\nbloquer\nblouson\nbobard\nbobine\nboire\nboiser\nbolide\nbonbon\nbondir\nbonheur\nbonifier\nbonus\nbordure\nborne\nbotte\nboucle\nboueux\nbougie\nboulon\nbouquin\nbourse\nboussole\nboutique\nboxeur\nbranche\nbrasier\nbrave\nbrebis\nbreche\nbreuvage\nbricoler\nbrigade\nbrillant\nbrioche\nbrique\nbrochure\nbroder\nbronzer\nbrousse\nbroyeur\nbrume\nbrusque\nbrutal\nbruyant\nbuffle\nbuisson\nbulletin\nbureau\nburin\nbustier\nbutiner\nbutoir\nbuvable\nbuvette\ncabanon\ncabine\ncachette\ncadeau\ncadre\ncafeine\ncaillou\ncaisson\ncalculer\ncalepin\ncalibre\ncalmer\ncalomnie\ncalvaire\ncamarade\ncamera\ncamion\ncampagne\ncanal\ncaneton\ncanon\ncantine\ncanular\ncapable\ncaporal\ncaprice\ncapsule\ncapter\ncapuche\ncarabine\ncarbone\ncaresser\ncaribou\ncarnage\ncarotte\ncarreau\ncarton\ncascade\ncasier\ncasque\ncassure\ncauser\ncaution\ncavalier\ncaverne\ncaviar\ncedille\nceinture\nceleste\ncellule\ncendrier\ncensurer\ncentral\ncercle\ncerebral\ncerise\ncerner\ncerveau\ncesser\nchagrin\nchaise\nchaleur\nchambre\nchance\nchapitre\ncharbon\nchasseur\nchaton\nchausson\nchavirer\nchemise\nchenille\nchequier\nchercher\ncheval\nchien\nchiffre\nchignon\nchimere\nchiot\nchlorure\nchocolat\nchoisir\nchose\nchouette\nchrome\nchute\ncigare\ncigogne\ncimenter\ncinema\ncintrer\ncirculer\ncirer\ncirque\nciterne\ncitoyen\ncitron\ncivil\nclairon\nclameur\nclaquer\nclasse\nclavier\nclient\ncligner\nclimat\nclivage\ncloche\nclonage\ncloporte\ncobalt\ncobra\ncocasse\ncocotier\ncoder\ncodifier\ncoffre\ncogner\ncohesion\ncoiffer\ncoincer\ncolere\ncolibri\ncolline\ncolmater\ncolonel\ncombat\ncomedie\ncommande\ncompact\nconcert\nconduire\nconfier\ncongeler\nconnoter\nconsonne\ncontact\nconvexe\ncopain\ncopie\ncorail\ncorbeau\ncordage\ncorniche\ncorpus\ncorrect\ncortege\ncosmique\ncostume\ncoton\ncoude\ncoupure\ncourage\ncouteau\ncouvrir\ncoyote\ncrabe\ncrainte\ncravate\ncrayon\ncreature\ncrediter\ncremeux\ncreuser\ncrevette\ncribler\ncrier\ncristal\ncritere\ncroire\ncroquer\ncrotale\ncrucial\ncruel\ncrypter\ncubique\ncueillir\ncuillere\ncuisine\ncuivre\nculminer\ncultiver\ncumuler\ncupide\ncuratif\ncurseur\ncyanure\ncycle\ncylindre\ncynique\ndaigner\ndamier\ndanger\ndanseur\ndauphin\ndebattre\ndebiter\ndeborder\ndebrider\ndebutant\ndecaler\ndecembre\ndechirer\ndecider\ndeclarer\ndecorer\ndecrire\ndecupler\ndedale\ndeductif\ndeesse\ndefensif\ndefiler\ndefrayer\ndegager\ndegivrer\ndeglutir\ndegrafer\ndejeuner\ndelice\ndeloger\ndemander\ndemeurer\ndemolir\ndenicher\ndenouer\ndentelle\ndenuder\ndepart\ndepenser\ndephaser\ndeplacer\ndeposer\nderanger\nderober\ndesastre\ndescente\ndesert\ndesigner\ndesobeir\ndessiner\ndestrier\ndetacher\ndetester\ndetourer\ndetresse\ndevancer\ndevenir\ndeviner\ndevoir\ndiable\ndialogue\ndiamant\ndicter\ndifferer\ndigerer\ndigital\ndigne\ndiluer\ndimanche\ndiminuer\ndioxyde\ndirectif\ndiriger\ndiscuter\ndisposer\ndissiper\ndistance\ndivertir\ndiviser\ndocile\ndocteur\ndogme\ndoigt\ndomaine\ndomicile\ndompter\ndonateur\ndonjon\ndonner\ndopamine\ndortoir\ndorure\ndosage\ndoseur\ndossier\ndotation\ndouanier\ndouble\ndouceur\ndouter\ndoyen\ndragon\ndraper\ndresser\ndribbler\ndroiture\nduperie\nduplexe\ndurable\ndurcir\ndynastie\neblouir\necarter\necharpe\nechelle\neclairer\neclipse\neclore\necluse\necole\neconomie\necorce\necouter\necraser\necremer\necrivain\necrou\necume\necureuil\nedifier\neduquer\neffacer\neffectif\neffigie\neffort\neffrayer\neffusion\negaliser\negarer\nejecter\nelaborer\nelargir\nelectron\nelegant\nelephant\neleve\neligible\nelitisme\neloge\nelucider\neluder\nemballer\nembellir\nembryon\nemeraude\nemission\nemmener\nemotion\nemouvoir\nempereur\nemployer\nemporter\nemprise\nemulsion\nencadrer\nenchere\nenclave\nencoche\nendiguer\nendosser\nendroit\nenduire\nenergie\nenfance\nenfermer\nenfouir\nengager\nengin\nenglober\nenigme\nenjamber\nenjeu\nenlever\nennemi\nennuyeux\nenrichir\nenrobage\nenseigne\nentasser\nentendre\nentier\nentourer\nentraver\nenumerer\nenvahir\nenviable\nenvoyer\nenzyme\neolien\nepaissir\nepargne\nepatant\nepaule\nepicerie\nepidemie\nepier\nepilogue\nepine\nepisode\nepitaphe\nepoque\nepreuve\neprouver\nepuisant\nequerre\nequipe\neriger\nerosion\nerreur\neruption\nescalier\nespadon\nespece\nespiegle\nespoir\nesprit\nesquiver\nessayer\nessence\nessieu\nessorer\nestime\nestomac\nestrade\netagere\netaler\netanche\netatique\neteindre\netendoir\neternel\nethanol\nethique\nethnie\netirer\netoffer\netoile\netonnant\netourdir\netrange\netroit\netude\neuphorie\nevaluer\nevasion\neventail\nevidence\neviter\nevolutif\nevoquer\nexact\nexagerer\nexaucer\nexceller\nexcitant\nexclusif\nexcuse\nexecuter\nexemple\nexercer\nexhaler\nexhorter\nexigence\nexiler\nexister\nexotique\nexpedier\nexplorer\nexposer\nexprimer\nexquis\nextensif\nextraire\nexulter\nfable\nfabuleux\nfacette\nfacile\nfacture\nfaiblir\nfalaise\nfameux\nfamille\nfarceur\nfarfelu\nfarine\nfarouche\nfasciner\nfatal\nfatigue\nfaucon\nfautif\nfaveur\nfavori\nfebrile\nfeconder\nfederer\nfelin\nfemme\nfemur\nfendoir\nfeodal\nfermer\nferoce\nferveur\nfestival\nfeuille\nfeutre\nfevrier\nfiasco\nficeler\nfictif\nfidele\nfigure\nfilature\nfiletage\nfiliere\nfilleul\nfilmer\nfilou\nfiltrer\nfinancer\nfinir\nfiole\nfirme\nfissure\nfixer\nflairer\nflamme\nflasque\nflatteur\nfleau\nfleche\nfleur\nflexion\nflocon\nflore\nfluctuer\nfluide\nfluvial\nfolie\nfonderie\nfongible\nfontaine\nforcer\nforgeron\nformuler\nfortune\nfossile\nfoudre\nfougere\nfouiller\nfoulure\nfourmi\nfragile\nfraise\nfranchir\nfrapper\nfrayeur\nfregate\nfreiner\nfrelon\nfremir\nfrenesie\nfrere\nfriable\nfriction\nfrisson\nfrivole\nfroid\nfromage\nfrontal\nfrotter\nfruit\nfugitif\nfuite\nfureur\nfurieux\nfurtif\nfusion\nfutur\ngagner\ngalaxie\ngalerie\ngambader\ngarantir\ngardien\ngarnir\ngarrigue\ngazelle\ngazon\ngeant\ngelatine\ngelule\ngendarme\ngeneral\ngenie\ngenou\ngentil\ngeologie\ngeometre\ngeranium\ngerme\ngestuel\ngeyser\ngibier\ngicler\ngirafe\ngivre\nglace\nglaive\nglisser\nglobe\ngloire\nglorieux\ngolfeur\ngomme\ngonfler\ngorge\ngorille\ngoudron\ngouffre\ngoulot\ngoupille\ngourmand\ngoutte\ngraduel\ngraffiti\ngraine\ngrand\ngrappin\ngratuit\ngravir\ngrenat\ngriffure\ngriller\ngrimper\ngrogner\ngronder\ngrotte\ngroupe\ngruger\ngrutier\ngruyere\nguepard\nguerrier\nguide\nguimauve\nguitare\ngustatif\ngymnaste\ngyrostat\nhabitude\nhachoir\nhalte\nhameau\nhangar\nhanneton\nharicot\nharmonie\nharpon\nhasard\nhelium\nhematome\nherbe\nherisson\nhermine\nheron\nhesiter\nheureux\nhiberner\nhibou\nhilarant\nhistoire\nhiver\nhomard\nhommage\nhomogene\nhonneur\nhonorer\nhonteux\nhorde\nhorizon\nhorloge\nhormone\nhorrible\nhouleux\nhousse\nhublot\nhuileux\nhumain\nhumble\nhumide\nhumour\nhurler\nhydromel\nhygiene\nhymne\nhypnose\nidylle\nignorer\niguane\nillicite\nillusion\nimage\nimbiber\nimiter\nimmense\nimmobile\nimmuable\nimpact\nimperial\nimplorer\nimposer\nimprimer\nimputer\nincarner\nincendie\nincident\nincliner\nincolore\nindexer\nindice\ninductif\ninedit\nineptie\ninexact\ninfini\ninfliger\ninformer\ninfusion\ningerer\ninhaler\ninhiber\ninjecter\ninjure\ninnocent\ninoculer\ninonder\ninscrire\ninsecte\ninsigne\ninsolite\ninspirer\ninstinct\ninsulter\nintact\nintense\nintime\nintrigue\nintuitif\ninutile\ninvasion\ninventer\ninviter\ninvoquer\nironique\nirradier\nirreel\nirriter\nisoler\nivoire\nivresse\njaguar\njaillir\njambe\njanvier\njardin\njauger\njaune\njavelot\njetable\njeton\njeudi\njeunesse\njoindre\njoncher\njongler\njoueur\njouissif\njournal\njovial\njoyau\njoyeux\njubiler\njugement\njunior\njupon\njuriste\njustice\njuteux\njuvenile\nkayak\nkimono\nkiosque\nlabel\nlabial\nlabourer\nlacerer\nlactose\nlagune\nlaine\nlaisser\nlaitier\nlambeau\nlamelle\nlampe\nlanceur\nlangage\nlanterne\nlapin\nlargeur\nlarme\nlaurier\nlavabo\nlavoir\nlecture\nlegal\nleger\nlegume\nlessive\nlettre\nlevier\nlexique\nlezard\nliasse\nliberer\nlibre\nlicence\nlicorne\nliege\nlievre\nligature\nligoter\nligue\nlimer\nlimite\nlimonade\nlimpide\nlineaire\nlingot\nlionceau\nliquide\nlisiere\nlister\nlithium\nlitige\nlittoral\nlivreur\nlogique\nlointain\nloisir\nlombric\nloterie\nlouer\nlourd\nloutre\nlouve\nloyal\nlubie\nlucide\nlucratif\nlueur\nlugubre\nluisant\nlumiere\nlunaire\nlundi\nluron\nlutter\nluxueux\nmachine\nmagasin\nmagenta\nmagique\nmaigre\nmaillon\nmaintien\nmairie\nmaison\nmajorer\nmalaxer\nmalefice\nmalheur\nmalice\nmallette\nmammouth\nmandater\nmaniable\nmanquant\nmanteau\nmanuel\nmarathon\nmarbre\nmarchand\nmardi\nmaritime\nmarqueur\nmarron\nmarteler\nmascotte\nmassif\nmateriel\nmatiere\nmatraque\nmaudire\nmaussade\nmauve\nmaximal\nmechant\nmeconnu\nmedaille\nmedecin\nmediter\nmeduse\nmeilleur\nmelange\nmelodie\nmembre\nmemoire\nmenacer\nmener\nmenhir\nmensonge\nmentor\nmercredi\nmerite\nmerle\nmessager\nmesure\nmetal\nmeteore\nmethode\nmetier\nmeuble\nmiauler\nmicrobe\nmiette\nmignon\nmigrer\nmilieu\nmillion\nmimique\nmince\nmineral\nminimal\nminorer\nminute\nmiracle\nmiroiter\nmissile\nmixte\nmobile\nmoderne\nmoelleux\nmondial\nmoniteur\nmonnaie\nmonotone\nmonstre\nmontagne\nmonument\nmoqueur\nmorceau\nmorsure\nmortier\nmoteur\nmotif\nmouche\nmoufle\nmoulin\nmousson\nmouton\nmouvant\nmultiple\nmunition\nmuraille\nmurene\nmurmure\nmuscle\nmuseum\nmusicien\nmutation\nmuter\nmutuel\nmyriade\nmyrtille\nmystere\nmythique\nnageur\nnappe\nnarquois\nnarrer\nnatation\nnation\nnature\nnaufrage\nnautique\nnavire\nnebuleux\nnectar\nnefaste\nnegation\nnegliger\nnegocier\nneige\nnerveux\nnettoyer\nneurone\nneutron\nneveu\nniche\nnickel\nnitrate\nniveau\nnoble\nnocif\nnocturne\nnoirceur\nnoisette\nnomade\nnombreux\nnommer\nnormatif\nnotable\nnotifier\nnotoire\nnourrir\nnouveau\nnovateur\nnovembre\nnovice\nnuage\nnuancer\nnuire\nnuisible\nnumero\nnuptial\nnuque\nnutritif\nobeir\nobjectif\nobliger\nobscur\nobserver\nobstacle\nobtenir\nobturer\noccasion\noccuper\nocean\noctobre\noctroyer\noctupler\noculaire\nodeur\nodorant\noffenser\nofficier\noffrir\nogive\noiseau\noisillon\nolfactif\nolivier\nombrage\nomettre\nonctueux\nonduler\nonereux\nonirique\nopale\nopaque\noperer\nopinion\nopportun\nopprimer\nopter\noptique\norageux\norange\norbite\nordonner\noreille\norgane\norgueil\norifice\nornement\norque\nortie\nosciller\nosmose\nossature\notarie\nouragan\nourson\noutil\noutrager\nouvrage\novation\noxyde\noxygene\nozone\npaisible\npalace\npalmares\npalourde\npalper\npanache\npanda\npangolin\npaniquer\npanneau\npanorama\npantalon\npapaye\npapier\npapoter\npapyrus\nparadoxe\nparcelle\nparesse\nparfumer\nparler\nparole\nparrain\nparsemer\npartager\nparure\nparvenir\npassion\npasteque\npaternel\npatience\npatron\npavillon\npavoiser\npayer\npaysage\npeigne\npeintre\npelage\npelican\npelle\npelouse\npeluche\npendule\npenetrer\npenible\npensif\npenurie\npepite\npeplum\nperdrix\nperforer\nperiode\npermuter\nperplexe\npersil\nperte\npeser\npetale\npetit\npetrir\npeuple\npharaon\nphobie\nphoque\nphoton\nphrase\nphysique\npiano\npictural\npiece\npierre\npieuvre\npilote\npinceau\npipette\npiquer\npirogue\npiscine\npiston\npivoter\npixel\npizza\nplacard\nplafond\nplaisir\nplaner\nplaque\nplastron\nplateau\npleurer\nplexus\npliage\nplomb\nplonger\npluie\nplumage\npochette\npoesie\npoete\npointe\npoirier\npoisson\npoivre\npolaire\npolicier\npollen\npolygone\npommade\npompier\nponctuel\nponderer\nponey\nportique\nposition\nposseder\nposture\npotager\npoteau\npotion\npouce\npoulain\npoumon\npourpre\npoussin\npouvoir\nprairie\npratique\nprecieux\npredire\nprefixe\nprelude\nprenom\npresence\npretexte\nprevoir\nprimitif\nprince\nprison\npriver\nprobleme\nproceder\nprodige\nprofond\nprogres\nproie\nprojeter\nprologue\npromener\npropre\nprospere\nproteger\nprouesse\nproverbe\nprudence\npruneau\npsychose\npublic\npuceron\npuiser\npulpe\npulsar\npunaise\npunitif\npupitre\npurifier\npuzzle\npyramide\nquasar\nquerelle\nquestion\nquietude\nquitter\nquotient\nracine\nraconter\nradieux\nragondin\nraideur\nraisin\nralentir\nrallonge\nramasser\nrapide\nrasage\nratisser\nravager\nravin\nrayonner\nreactif\nreagir\nrealiser\nreanimer\nrecevoir\nreciter\nreclamer\nrecolter\nrecruter\nreculer\nrecycler\nrediger\nredouter\nrefaire\nreflexe\nreformer\nrefrain\nrefuge\nregalien\nregion\nreglage\nregulier\nreiterer\nrejeter\nrejouer\nrelatif\nrelever\nrelief\nremarque\nremede\nremise\nremonter\nremplir\nremuer\nrenard\nrenfort\nrenifler\nrenoncer\nrentrer\nrenvoi\nreplier\nreporter\nreprise\nreptile\nrequin\nreserve\nresineux\nresoudre\nrespect\nrester\nresultat\nretablir\nretenir\nreticule\nretomber\nretracer\nreunion\nreussir\nrevanche\nrevivre\nrevolte\nrevulsif\nrichesse\nrideau\nrieur\nrigide\nrigoler\nrincer\nriposter\nrisible\nrisque\nrituel\nrival\nriviere\nrocheux\nromance\nrompre\nronce\nrondin\nroseau\nrosier\nrotatif\nrotor\nrotule\nrouge\nrouille\nrouleau\nroutine\nroyaume\nruban\nrubis\nruche\nruelle\nrugueux\nruiner\nruisseau\nruser\nrustique\nrythme\nsabler\nsaboter\nsabre\nsacoche\nsafari\nsagesse\nsaisir\nsalade\nsalive\nsalon\nsaluer\nsamedi\nsanction\nsanglier\nsarcasme\nsardine\nsaturer\nsaugrenu\nsaumon\nsauter\nsauvage\nsavant\nsavonner\nscalpel\nscandale\nscelerat\nscenario\nsceptre\nschema\nscience\nscinder\nscore\nscrutin\nsculpter\nseance\nsecable\nsecher\nsecouer\nsecreter\nsedatif\nseduire\nseigneur\nsejour\nselectif\nsemaine\nsembler\nsemence\nseminal\nsenateur\nsensible\nsentence\nseparer\nsequence\nserein\nsergent\nserieux\nserrure\nserum\nservice\nsesame\nsevir\nsevrage\nsextuple\nsideral\nsiecle\nsieger\nsiffler\nsigle\nsignal\nsilence\nsilicium\nsimple\nsincere\nsinistre\nsiphon\nsirop\nsismique\nsituer\nskier\nsocial\nsocle\nsodium\nsoigneux\nsoldat\nsoleil\nsolitude\nsoluble\nsombre\nsommeil\nsomnoler\nsonde\nsongeur\nsonnette\nsonore\nsorcier\nsortir\nsosie\nsottise\nsoucieux\nsoudure\nsouffle\nsoulever\nsoupape\nsource\nsoutirer\nsouvenir\nspacieux\nspatial\nspecial\nsphere\nspiral\nstable\nstation\nsternum\nstimulus\nstipuler\nstrict\nstudieux\nstupeur\nstyliste\nsublime\nsubstrat\nsubtil\nsubvenir\nsucces\nsucre\nsuffixe\nsuggerer\nsuiveur\nsulfate\nsuperbe\nsupplier\nsurface\nsuricate\nsurmener\nsurprise\nsursaut\nsurvie\nsuspect\nsyllabe\nsymbole\nsymetrie\nsynapse\nsyntaxe\nsysteme\ntabac\ntablier\ntactile\ntailler\ntalent\ntalisman\ntalonner\ntambour\ntamiser\ntangible\ntapis\ntaquiner\ntarder\ntarif\ntartine\ntasse\ntatami\ntatouage\ntaupe\ntaureau\ntaxer\ntemoin\ntemporel\ntenaille\ntendre\nteneur\ntenir\ntension\nterminer\nterne\nterrible\ntetine\ntexte\ntheme\ntheorie\ntherapie\nthorax\ntibia\ntiede\ntimide\ntirelire\ntiroir\ntissu\ntitane\ntitre\ntituber\ntoboggan\ntolerant\ntomate\ntonique\ntonneau\ntoponyme\ntorche\ntordre\ntornade\ntorpille\ntorrent\ntorse\ntortue\ntotem\ntoucher\ntournage\ntousser\ntoxine\ntraction\ntrafic\ntragique\ntrahir\ntrain\ntrancher\ntravail\ntrefle\ntremper\ntresor\ntreuil\ntriage\ntribunal\ntricoter\ntrilogie\ntriomphe\ntripler\ntriturer\ntrivial\ntrombone\ntronc\ntropical\ntroupeau\ntuile\ntulipe\ntumulte\ntunnel\nturbine\ntuteur\ntutoyer\ntuyau\ntympan\ntyphon\ntypique\ntyran\nubuesque\nultime\nultrason\nunanime\nunifier\nunion\nunique\nunitaire\nunivers\nuranium\nurbain\nurticant\nusage\nusine\nusuel\nusure\nutile\nutopie\nvacarme\nvaccin\nvagabond\nvague\nvaillant\nvaincre\nvaisseau\nvalable\nvalise\nvallon\nvalve\nvampire\nvanille\nvapeur\nvarier\nvaseux\nvassal\nvaste\nvecteur\nvedette\nvegetal\nvehicule\nveinard\nveloce\nvendredi\nvenerer\nvenger\nvenimeux\nventouse\nverdure\nverin\nvernir\nverrou\nverser\nvertu\nveston\nveteran\nvetuste\nvexant\nvexer\nviaduc\nviande\nvictoire\nvidange\nvideo\nvignette\nvigueur\nvilain\nvillage\nvinaigre\nviolon\nvipere\nvirement\nvirtuose\nvirus\nvisage\nviseur\nvision\nvisqueux\nvisuel\nvital\nvitesse\nviticole\nvitrine\nvivace\nvivipare\nvocation\nvoguer\nvoile\nvoisin\nvoiture\nvolaille\nvolcan\nvoltiger\nvolume\nvorace\nvortex\nvoter\nvouloir\nvoyage\nvoyelle\nwagon\nxenon\nyacht\nzebre\nzenith\nzeste\nzoologie`.split('\\n');\n", "export const wordlist = `abaco\nabbaglio\nabbinato\nabete\nabisso\nabolire\nabrasivo\nabrogato\naccadere\naccenno\naccusato\nacetone\nachille\nacido\nacqua\nacre\nacrilico\nacrobata\nacuto\nadagio\naddebito\naddome\nadeguato\naderire\nadipe\nadottare\nadulare\naffabile\naffetto\naffisso\naffranto\naforisma\nafoso\nafricano\nagave\nagente\nagevole\naggancio\nagire\nagitare\nagonismo\nagricolo\nagrumeto\naguzzo\nalabarda\nalato\nalbatro\nalberato\nalbo\nalbume\nalce\nalcolico\nalettone\nalfa\nalgebra\naliante\nalibi\nalimento\nallagato\nallegro\nallievo\nallodola\nallusivo\nalmeno\nalogeno\nalpaca\nalpestre\naltalena\nalterno\nalticcio\naltrove\nalunno\nalveolo\nalzare\namalgama\namanita\namarena\nambito\nambrato\nameba\namerica\nametista\namico\nammasso\nammenda\nammirare\nammonito\namore\nampio\nampliare\namuleto\nanacardo\nanagrafe\nanalista\nanarchia\nanatra\nanca\nancella\nancora\nandare\nandrea\nanello\nangelo\nangolare\nangusto\nanima\nannegare\nannidato\nanno\nannuncio\nanonimo\nanticipo\nanzi\napatico\napertura\napode\napparire\nappetito\nappoggio\napprodo\nappunto\naprile\narabica\narachide\naragosta\naraldica\narancio\naratura\narazzo\narbitro\narchivio\nardito\narenile\nargento\nargine\narguto\naria\narmonia\narnese\narredato\narringa\narrosto\narsenico\narso\nartefice\narzillo\nasciutto\nascolto\nasepsi\nasettico\nasfalto\nasino\nasola\naspirato\naspro\nassaggio\nasse\nassoluto\nassurdo\nasta\nastenuto\nastice\nastratto\natavico\nateismo\natomico\natono\nattesa\nattivare\nattorno\nattrito\nattuale\nausilio\naustria\nautista\nautonomo\nautunno\navanzato\navere\navvenire\navviso\navvolgere\nazione\nazoto\nazzimo\nazzurro\nbabele\nbaccano\nbacino\nbaco\nbadessa\nbadilata\nbagnato\nbaita\nbalcone\nbaldo\nbalena\nballata\nbalzano\nbambino\nbandire\nbaraonda\nbarbaro\nbarca\nbaritono\nbarlume\nbarocco\nbasilico\nbasso\nbatosta\nbattuto\nbaule\nbava\nbavosa\nbecco\nbeffa\nbelgio\nbelva\nbenda\nbenevole\nbenigno\nbenzina\nbere\nberlina\nbeta\nbibita\nbici\nbidone\nbifido\nbiga\nbilancia\nbimbo\nbinocolo\nbiologo\nbipede\nbipolare\nbirbante\nbirra\nbiscotto\nbisesto\nbisnonno\nbisonte\nbisturi\nbizzarro\nblando\nblatta\nbollito\nbonifico\nbordo\nbosco\nbotanico\nbottino\nbozzolo\nbraccio\nbradipo\nbrama\nbranca\nbravura\nbretella\nbrevetto\nbrezza\nbriglia\nbrillante\nbrindare\nbroccolo\nbrodo\nbronzina\nbrullo\nbruno\nbubbone\nbuca\nbudino\nbuffone\nbuio\nbulbo\nbuono\nburlone\nburrasca\nbussola\nbusta\ncadetto\ncaduco\ncalamaro\ncalcolo\ncalesse\ncalibro\ncalmo\ncaloria\ncambusa\ncamerata\ncamicia\ncammino\ncamola\ncampale\ncanapa\ncandela\ncane\ncanino\ncanotto\ncantina\ncapace\ncapello\ncapitolo\ncapogiro\ncappero\ncapra\ncapsula\ncarapace\ncarcassa\ncardo\ncarisma\ncarovana\ncarretto\ncartolina\ncasaccio\ncascata\ncaserma\ncaso\ncassone\ncastello\ncasuale\ncatasta\ncatena\ncatrame\ncauto\ncavillo\ncedibile\ncedrata\ncefalo\ncelebre\ncellulare\ncena\ncenone\ncentesimo\nceramica\ncercare\ncerto\ncerume\ncervello\ncesoia\ncespo\nceto\nchela\nchiaro\nchicca\nchiedere\nchimera\nchina\nchirurgo\nchitarra\nciao\nciclismo\ncifrare\ncigno\ncilindro\nciottolo\ncirca\ncirrosi\ncitrico\ncittadino\nciuffo\ncivetta\ncivile\nclassico\nclinica\ncloro\ncocco\ncodardo\ncodice\ncoerente\ncognome\ncollare\ncolmato\ncolore\ncolposo\ncoltivato\ncolza\ncoma\ncometa\ncommando\ncomodo\ncomputer\ncomune\nconciso\ncondurre\nconferma\ncongelare\nconiuge\nconnesso\nconoscere\nconsumo\ncontinuo\nconvegno\ncoperto\ncopione\ncoppia\ncopricapo\ncorazza\ncordata\ncoricato\ncornice\ncorolla\ncorpo\ncorredo\ncorsia\ncortese\ncosmico\ncostante\ncottura\ncovato\ncratere\ncravatta\ncreato\ncredere\ncremoso\ncrescita\ncreta\ncriceto\ncrinale\ncrisi\ncritico\ncroce\ncronaca\ncrostata\ncruciale\ncrusca\ncucire\ncuculo\ncugino\ncullato\ncupola\ncuratore\ncursore\ncurvo\ncuscino\ncustode\ndado\ndaino\ndalmata\ndamerino\ndaniela\ndannoso\ndanzare\ndatato\ndavanti\ndavvero\ndebutto\ndecennio\ndeciso\ndeclino\ndecollo\ndecreto\ndedicato\ndefinito\ndeforme\ndegno\ndelegare\ndelfino\ndelirio\ndelta\ndemenza\ndenotato\ndentro\ndeposito\nderapata\nderivare\nderoga\ndescritto\ndeserto\ndesiderio\ndesumere\ndetersivo\ndevoto\ndiametro\ndicembre\ndiedro\ndifeso\ndiffuso\ndigerire\ndigitale\ndiluvio\ndinamico\ndinnanzi\ndipinto\ndiploma\ndipolo\ndiradare\ndire\ndirotto\ndirupo\ndisagio\ndiscreto\ndisfare\ndisgelo\ndisposto\ndistanza\ndisumano\ndito\ndivano\ndivelto\ndividere\ndivorato\ndoblone\ndocente\ndoganale\ndogma\ndolce\ndomato\ndomenica\ndominare\ndondolo\ndono\ndormire\ndote\ndottore\ndovuto\ndozzina\ndrago\ndruido\ndubbio\ndubitare\nducale\nduna\nduomo\nduplice\nduraturo\nebano\neccesso\necco\neclissi\neconomia\nedera\nedicola\nedile\neditoria\neducare\negemonia\negli\negoismo\negregio\nelaborato\nelargire\nelegante\nelencato\neletto\nelevare\nelfico\nelica\nelmo\nelsa\neluso\nemanato\nemblema\nemesso\nemiro\nemotivo\nemozione\nempirico\nemulo\nendemico\nenduro\nenergia\nenfasi\nenoteca\nentrare\nenzima\nepatite\nepilogo\nepisodio\nepocale\neppure\nequatore\nerario\nerba\nerboso\nerede\neremita\nerigere\nermetico\neroe\nerosivo\nerrante\nesagono\nesame\nesanime\nesaudire\nesca\nesempio\nesercito\nesibito\nesigente\nesistere\nesito\nesofago\nesortato\nesoso\nespanso\nespresso\nessenza\nesso\nesteso\nestimare\nestonia\nestroso\nesultare\netilico\netnico\netrusco\netto\neuclideo\neuropa\nevaso\nevidenza\nevitato\nevoluto\nevviva\nfabbrica\nfaccenda\nfachiro\nfalco\nfamiglia\nfanale\nfanfara\nfango\nfantasma\nfare\nfarfalla\nfarinoso\nfarmaco\nfascia\nfastoso\nfasullo\nfaticare\nfato\nfavoloso\nfebbre\nfecola\nfede\nfegato\nfelpa\nfeltro\nfemmina\nfendere\nfenomeno\nfermento\nferro\nfertile\nfessura\nfestivo\nfetta\nfeudo\nfiaba\nfiducia\nfifa\nfigurato\nfilo\nfinanza\nfinestra\nfinire\nfiore\nfiscale\nfisico\nfiume\nflacone\nflamenco\nflebo\nflemma\nflorido\nfluente\nfluoro\nfobico\nfocaccia\nfocoso\nfoderato\nfoglio\nfolata\nfolclore\nfolgore\nfondente\nfonetico\nfonia\nfontana\nforbito\nforchetta\nforesta\nformica\nfornaio\nforo\nfortezza\nforzare\nfosfato\nfosso\nfracasso\nfrana\nfrassino\nfratello\nfreccetta\nfrenata\nfresco\nfrigo\nfrollino\nfronde\nfrugale\nfrutta\nfucilata\nfucsia\nfuggente\nfulmine\nfulvo\nfumante\nfumetto\nfumoso\nfune\nfunzione\nfuoco\nfurbo\nfurgone\nfurore\nfuso\nfutile\ngabbiano\ngaffe\ngalateo\ngallina\ngaloppo\ngambero\ngamma\ngaranzia\ngarbo\ngarofano\ngarzone\ngasdotto\ngasolio\ngastrico\ngatto\ngaudio\ngazebo\ngazzella\ngeco\ngelatina\ngelso\ngemello\ngemmato\ngene\ngenitore\ngennaio\ngenotipo\ngergo\nghepardo\nghiaccio\nghisa\ngiallo\ngilda\nginepro\ngiocare\ngioiello\ngiorno\ngiove\ngirato\ngirone\ngittata\ngiudizio\ngiurato\ngiusto\nglobulo\nglutine\ngnomo\ngobba\ngolf\ngomito\ngommone\ngonfio\ngonna\ngoverno\ngracile\ngrado\ngrafico\ngrammo\ngrande\ngrattare\ngravoso\ngrazia\ngreca\ngregge\ngrifone\ngrigio\ngrinza\ngrotta\ngruppo\nguadagno\nguaio\nguanto\nguardare\ngufo\nguidare\nibernato\nicona\nidentico\nidillio\nidolo\nidra\nidrico\nidrogeno\nigiene\nignaro\nignorato\nilare\nilleso\nillogico\nilludere\nimballo\nimbevuto\nimbocco\nimbuto\nimmane\nimmerso\nimmolato\nimpacco\nimpeto\nimpiego\nimporto\nimpronta\ninalare\ninarcare\ninattivo\nincanto\nincendio\ninchino\nincisivo\nincluso\nincontro\nincrocio\nincubo\nindagine\nindia\nindole\ninedito\ninfatti\ninfilare\ninflitto\ningaggio\ningegno\ninglese\ningordo\ningrosso\ninnesco\ninodore\ninoltrare\ninondato\ninsano\ninsetto\ninsieme\ninsonnia\ninsulina\nintasato\nintero\nintonaco\nintuito\ninumidire\ninvalido\ninvece\ninvito\niperbole\nipnotico\nipotesi\nippica\niride\nirlanda\nironico\nirrigato\nirrorare\nisolato\nisotopo\nisterico\nistituto\nistrice\nitalia\niterare\nlabbro\nlabirinto\nlacca\nlacerato\nlacrima\nlacuna\nladdove\nlago\nlampo\nlancetta\nlanterna\nlardoso\nlarga\nlaringe\nlastra\nlatenza\nlatino\nlattuga\nlavagna\nlavoro\nlegale\nleggero\nlembo\nlentezza\nlenza\nleone\nlepre\nlesivo\nlessato\nlesto\nletterale\nleva\nlevigato\nlibero\nlido\nlievito\nlilla\nlimatura\nlimitare\nlimpido\nlineare\nlingua\nliquido\nlira\nlirica\nlisca\nlite\nlitigio\nlivrea\nlocanda\nlode\nlogica\nlombare\nlondra\nlongevo\nloquace\nlorenzo\nloto\nlotteria\nluce\nlucidato\nlumaca\nluminoso\nlungo\nlupo\nluppolo\nlusinga\nlusso\nlutto\nmacabro\nmacchina\nmacero\nmacinato\nmadama\nmagico\nmaglia\nmagnete\nmagro\nmaiolica\nmalafede\nmalgrado\nmalinteso\nmalsano\nmalto\nmalumore\nmana\nmancia\nmandorla\nmangiare\nmanifesto\nmannaro\nmanovra\nmansarda\nmantide\nmanubrio\nmappa\nmaratona\nmarcire\nmaretta\nmarmo\nmarsupio\nmaschera\nmassaia\nmastino\nmaterasso\nmatricola\nmattone\nmaturo\nmazurca\nmeandro\nmeccanico\nmecenate\nmedesimo\nmeditare\nmega\nmelassa\nmelis\nmelodia\nmeninge\nmeno\nmensola\nmercurio\nmerenda\nmerlo\nmeschino\nmese\nmessere\nmestolo\nmetallo\nmetodo\nmettere\nmiagolare\nmica\nmicelio\nmichele\nmicrobo\nmidollo\nmiele\nmigliore\nmilano\nmilite\nmimosa\nminerale\nmini\nminore\nmirino\nmirtillo\nmiscela\nmissiva\nmisto\nmisurare\nmitezza\nmitigare\nmitra\nmittente\nmnemonico\nmodello\nmodifica\nmodulo\nmogano\nmogio\nmole\nmolosso\nmonastero\nmonco\nmondina\nmonetario\nmonile\nmonotono\nmonsone\nmontato\nmonviso\nmora\nmordere\nmorsicato\nmostro\nmotivato\nmotosega\nmotto\nmovenza\nmovimento\nmozzo\nmucca\nmucosa\nmuffa\nmughetto\nmugnaio\nmulatto\nmulinello\nmultiplo\nmummia\nmunto\nmuovere\nmurale\nmusa\nmuscolo\nmusica\nmutevole\nmuto\nnababbo\nnafta\nnanometro\nnarciso\nnarice\nnarrato\nnascere\nnastrare\nnaturale\nnautica\nnaviglio\nnebulosa\nnecrosi\nnegativo\nnegozio\nnemmeno\nneofita\nneretto\nnervo\nnessuno\nnettuno\nneutrale\nneve\nnevrotico\nnicchia\nninfa\nnitido\nnobile\nnocivo\nnodo\nnome\nnomina\nnordico\nnormale\nnorvegese\nnostrano\nnotare\nnotizia\nnotturno\nnovella\nnucleo\nnulla\nnumero\nnuovo\nnutrire\nnuvola\nnuziale\noasi\nobbedire\nobbligo\nobelisco\noblio\nobolo\nobsoleto\noccasione\nocchio\noccidente\noccorrere\noccultare\nocra\noculato\nodierno\nodorare\nofferta\noffrire\noffuscato\noggetto\noggi\nognuno\nolandese\nolfatto\noliato\noliva\nologramma\noltre\nomaggio\nombelico\nombra\nomega\nomissione\nondoso\nonere\nonice\nonnivoro\nonorevole\nonta\noperato\nopinione\nopposto\noracolo\norafo\nordine\norecchino\norefice\norfano\norganico\norigine\norizzonte\norma\normeggio\nornativo\norologio\norrendo\norribile\nortensia\nortica\norzata\norzo\nosare\noscurare\nosmosi\nospedale\nospite\nossa\nossidare\nostacolo\noste\notite\notre\nottagono\nottimo\nottobre\novale\novest\novino\noviparo\novocito\novunque\novviare\nozio\npacchetto\npace\npacifico\npadella\npadrone\npaese\npaga\npagina\npalazzina\npalesare\npallido\npalo\npalude\npandoro\npannello\npaolo\npaonazzo\npaprica\nparabola\nparcella\nparere\npargolo\npari\nparlato\nparola\npartire\nparvenza\nparziale\npassivo\npasticca\npatacca\npatologia\npattume\npavone\npeccato\npedalare\npedonale\npeggio\npeloso\npenare\npendice\npenisola\npennuto\npenombra\npensare\npentola\npepe\npepita\nperbene\npercorso\nperdonato\nperforare\npergamena\nperiodo\npermesso\nperno\nperplesso\npersuaso\npertugio\npervaso\npesatore\npesista\npeso\npestifero\npetalo\npettine\npetulante\npezzo\npiacere\npianta\npiattino\npiccino\npicozza\npiega\npietra\npiffero\npigiama\npigolio\npigro\npila\npilifero\npillola\npilota\npimpante\npineta\npinna\npinolo\npioggia\npiombo\npiramide\npiretico\npirite\npirolisi\npitone\npizzico\nplacebo\nplanare\nplasma\nplatano\nplenario\npochezza\npoderoso\npodismo\npoesia\npoggiare\npolenta\npoligono\npollice\npolmonite\npolpetta\npolso\npoltrona\npolvere\npomice\npomodoro\nponte\npopoloso\nporfido\nporoso\nporpora\nporre\nportata\nposa\npositivo\npossesso\npostulato\npotassio\npotere\npranzo\nprassi\npratica\nprecluso\npredica\nprefisso\npregiato\nprelievo\npremere\nprenotare\npreparato\npresenza\npretesto\nprevalso\nprima\nprincipe\nprivato\nproblema\nprocura\nprodurre\nprofumo\nprogetto\nprolunga\npromessa\npronome\nproposta\nproroga\nproteso\nprova\nprudente\nprugna\nprurito\npsiche\npubblico\npudica\npugilato\npugno\npulce\npulito\npulsante\npuntare\npupazzo\npupilla\npuro\nquadro\nqualcosa\nquasi\nquerela\nquota\nraccolto\nraddoppio\nradicale\nradunato\nraffica\nragazzo\nragione\nragno\nramarro\nramingo\nramo\nrandagio\nrantolare\nrapato\nrapina\nrappreso\nrasatura\nraschiato\nrasente\nrassegna\nrastrello\nrata\nravveduto\nreale\nrecepire\nrecinto\nrecluta\nrecondito\nrecupero\nreddito\nredimere\nregalato\nregistro\nregola\nregresso\nrelazione\nremare\nremoto\nrenna\nreplica\nreprimere\nreputare\nresa\nresidente\nresponso\nrestauro\nrete\nretina\nretorica\nrettifica\nrevocato\nriassunto\nribadire\nribelle\nribrezzo\nricarica\nricco\nricevere\nriciclato\nricordo\nricreduto\nridicolo\nridurre\nrifasare\nriflesso\nriforma\nrifugio\nrigare\nrigettato\nrighello\nrilassato\nrilevato\nrimanere\nrimbalzo\nrimedio\nrimorchio\nrinascita\nrincaro\nrinforzo\nrinnovo\nrinomato\nrinsavito\nrintocco\nrinuncia\nrinvenire\nriparato\nripetuto\nripieno\nriportare\nripresa\nripulire\nrisata\nrischio\nriserva\nrisibile\nriso\nrispetto\nristoro\nrisultato\nrisvolto\nritardo\nritegno\nritmico\nritrovo\nriunione\nriva\nriverso\nrivincita\nrivolto\nrizoma\nroba\nrobotico\nrobusto\nroccia\nroco\nrodaggio\nrodere\nroditore\nrogito\nrollio\nromantico\nrompere\nronzio\nrosolare\nrospo\nrotante\nrotondo\nrotula\nrovescio\nrubizzo\nrubrica\nruga\nrullino\nrumine\nrumoroso\nruolo\nrupe\nrussare\nrustico\nsabato\nsabbiare\nsabotato\nsagoma\nsalasso\nsaldatura\nsalgemma\nsalivare\nsalmone\nsalone\nsaltare\nsaluto\nsalvo\nsapere\nsapido\nsaporito\nsaraceno\nsarcasmo\nsarto\nsassoso\nsatellite\nsatira\nsatollo\nsaturno\nsavana\nsavio\nsaziato\nsbadiglio\nsbalzo\nsbancato\nsbarra\nsbattere\nsbavare\nsbendare\nsbirciare\nsbloccato\nsbocciato\nsbrinare\nsbruffone\nsbuffare\nscabroso\nscadenza\nscala\nscambiare\nscandalo\nscapola\nscarso\nscatenare\nscavato\nscelto\nscenico\nscettro\nscheda\nschiena\nsciarpa\nscienza\nscindere\nscippo\nsciroppo\nscivolo\nsclerare\nscodella\nscolpito\nscomparto\nsconforto\nscoprire\nscorta\nscossone\nscozzese\nscriba\nscrollare\nscrutinio\nscuderia\nscultore\nscuola\nscuro\nscusare\nsdebitare\nsdoganare\nseccatura\nsecondo\nsedano\nseggiola\nsegnalato\nsegregato\nseguito\nselciato\nselettivo\nsella\nselvaggio\nsemaforo\nsembrare\nseme\nseminato\nsempre\nsenso\nsentire\nsepolto\nsequenza\nserata\nserbato\nsereno\nserio\nserpente\nserraglio\nservire\nsestina\nsetola\nsettimana\nsfacelo\nsfaldare\nsfamato\nsfarzoso\nsfaticato\nsfera\nsfida\nsfilato\nsfinge\nsfocato\nsfoderare\nsfogo\nsfoltire\nsforzato\nsfratto\nsfruttato\nsfuggito\nsfumare\nsfuso\nsgabello\nsgarbato\nsgonfiare\nsgorbio\nsgrassato\nsguardo\nsibilo\nsiccome\nsierra\nsigla\nsignore\nsilenzio\nsillaba\nsimbolo\nsimpatico\nsimulato\nsinfonia\nsingolo\nsinistro\nsino\nsintesi\nsinusoide\nsipario\nsisma\nsistole\nsituato\nslitta\nslogatura\nsloveno\nsmarrito\nsmemorato\nsmentito\nsmeraldo\nsmilzo\nsmontare\nsmottato\nsmussato\nsnellire\nsnervato\nsnodo\nsobbalzo\nsobrio\nsoccorso\nsociale\nsodale\nsoffitto\nsogno\nsoldato\nsolenne\nsolido\nsollazzo\nsolo\nsolubile\nsolvente\nsomatico\nsomma\nsonda\nsonetto\nsonnifero\nsopire\nsoppeso\nsopra\nsorgere\nsorpasso\nsorriso\nsorso\nsorteggio\nsorvolato\nsospiro\nsosta\nsottile\nspada\nspalla\nspargere\nspatola\nspavento\nspazzola\nspecie\nspedire\nspegnere\nspelatura\nsperanza\nspessore\nspettrale\nspezzato\nspia\nspigoloso\nspillato\nspinoso\nspirale\nsplendido\nsportivo\nsposo\nspranga\nsprecare\nspronato\nspruzzo\nspuntino\nsquillo\nsradicare\nsrotolato\nstabile\nstacco\nstaffa\nstagnare\nstampato\nstantio\nstarnuto\nstasera\nstatuto\nstelo\nsteppa\nsterzo\nstiletto\nstima\nstirpe\nstivale\nstizzoso\nstonato\nstorico\nstrappo\nstregato\nstridulo\nstrozzare\nstrutto\nstuccare\nstufo\nstupendo\nsubentro\nsuccoso\nsudore\nsuggerito\nsugo\nsultano\nsuonare\nsuperbo\nsupporto\nsurgelato\nsurrogato\nsussurro\nsutura\nsvagare\nsvedese\nsveglio\nsvelare\nsvenuto\nsvezia\nsviluppo\nsvista\nsvizzera\nsvolta\nsvuotare\ntabacco\ntabulato\ntacciare\ntaciturno\ntale\ntalismano\ntampone\ntannino\ntara\ntardivo\ntargato\ntariffa\ntarpare\ntartaruga\ntasto\ntattico\ntaverna\ntavolata\ntazza\nteca\ntecnico\ntelefono\ntemerario\ntempo\ntemuto\ntendone\ntenero\ntensione\ntentacolo\nteorema\nterme\nterrazzo\nterzetto\ntesi\ntesserato\ntestato\ntetro\ntettoia\ntifare\ntigella\ntimbro\ntinto\ntipico\ntipografo\ntiraggio\ntiro\ntitanio\ntitolo\ntitubante\ntizio\ntizzone\ntoccare\ntollerare\ntolto\ntombola\ntomo\ntonfo\ntonsilla\ntopazio\ntopologia\ntoppa\ntorba\ntornare\ntorrone\ntortora\ntoscano\ntossire\ntostatura\ntotano\ntrabocco\ntrachea\ntrafila\ntragedia\ntralcio\ntramonto\ntransito\ntrapano\ntrarre\ntrasloco\ntrattato\ntrave\ntreccia\ntremolio\ntrespolo\ntributo\ntricheco\ntrifoglio\ntrillo\ntrincea\ntrio\ntristezza\ntriturato\ntrivella\ntromba\ntrono\ntroppo\ntrottola\ntrovare\ntruccato\ntubatura\ntuffato\ntulipano\ntumulto\ntunisia\nturbare\nturchino\ntuta\ntutela\nubicato\nuccello\nuccisore\nudire\nuditivo\nuffa\nufficio\nuguale\nulisse\nultimato\numano\numile\numorismo\nuncinetto\nungere\nungherese\nunicorno\nunificato\nunisono\nunitario\nunte\nuovo\nupupa\nuragano\nurgenza\nurlo\nusanza\nusato\nuscito\nusignolo\nusuraio\nutensile\nutilizzo\nutopia\nvacante\nvaccinato\nvagabondo\nvagliato\nvalanga\nvalgo\nvalico\nvalletta\nvaloroso\nvalutare\nvalvola\nvampata\nvangare\nvanitoso\nvano\nvantaggio\nvanvera\nvapore\nvarano\nvarcato\nvariante\nvasca\nvedetta\nvedova\nveduto\nvegetale\nveicolo\nvelcro\nvelina\nvelluto\nveloce\nvenato\nvendemmia\nvento\nverace\nverbale\nvergogna\nverifica\nvero\nverruca\nverticale\nvescica\nvessillo\nvestale\nveterano\nvetrina\nvetusto\nviandante\nvibrante\nvicenda\nvichingo\nvicinanza\nvidimare\nvigilia\nvigneto\nvigore\nvile\nvillano\nvimini\nvincitore\nviola\nvipera\nvirgola\nvirologo\nvirulento\nviscoso\nvisione\nvispo\nvissuto\nvisura\nvita\nvitello\nvittima\nvivanda\nvivido\nviziare\nvoce\nvoga\nvolatile\nvolere\nvolpe\nvoragine\nvulcano\nzampogna\nzanna\nzappato\nzattera\nzavorra\nzefiro\nzelante\nzelo\nzenzero\nzerbino\nzibetto\nzinco\nzircone\nzitto\nzolla\nzotico\nzucchero\nzufolo\nzulu\nzuppa`.split('\\n');\n", "export const wordlist = `\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`.split('\\n');\n", "export const wordlist = `\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`.split('\\n');\n", "export const wordlist = `abacate\nabaixo\nabalar\nabater\nabduzir\nabelha\naberto\nabismo\nabotoar\nabranger\nabreviar\nabrigar\nabrupto\nabsinto\nabsoluto\nabsurdo\nabutre\nacabado\nacalmar\nacampar\nacanhar\nacaso\naceitar\nacelerar\nacenar\nacervo\nacessar\nacetona\nachatar\nacidez\nacima\nacionado\nacirrar\naclamar\naclive\nacolhida\nacomodar\nacoplar\nacordar\nacumular\nacusador\nadaptar\nadega\nadentro\nadepto\nadequar\naderente\nadesivo\nadeus\nadiante\naditivo\nadjetivo\nadjunto\nadmirar\nadorar\nadquirir\nadubo\nadverso\nadvogado\naeronave\nafastar\naferir\nafetivo\nafinador\nafivelar\naflito\nafluente\nafrontar\nagachar\nagarrar\nagasalho\nagenciar\nagilizar\nagiota\nagitado\nagora\nagradar\nagreste\nagrupar\naguardar\nagulha\najoelhar\najudar\najustar\nalameda\nalarme\nalastrar\nalavanca\nalbergue\nalbino\nalcatra\naldeia\nalecrim\nalegria\nalertar\nalface\nalfinete\nalgum\nalheio\naliar\nalicate\nalienar\nalinhar\naliviar\nalmofada\nalocar\nalpiste\nalterar\naltitude\nalucinar\nalugar\naluno\nalusivo\nalvo\namaciar\namador\namarelo\namassar\nambas\nambiente\nameixa\namenizar\namido\namistoso\namizade\namolador\namontoar\namoroso\namostra\namparar\nampliar\nampola\nanagrama\nanalisar\nanarquia\nanatomia\nandaime\nanel\nanexo\nangular\nanimar\nanjo\nanomalia\nanotado\nansioso\nanterior\nanuidade\nanunciar\nanzol\napagador\napalpar\napanhado\napego\napelido\napertada\napesar\napetite\napito\naplauso\naplicada\napoio\napontar\naposta\naprendiz\naprovar\naquecer\narame\naranha\narara\narcada\nardente\nareia\narejar\narenito\naresta\nargiloso\nargola\narma\narquivo\narraial\narrebate\narriscar\narroba\narrumar\narsenal\narterial\nartigo\narvoredo\nasfaltar\nasilado\naspirar\nassador\nassinar\nassoalho\nassunto\nastral\natacado\natadura\natalho\natarefar\natear\natender\naterro\nateu\natingir\natirador\nativo\natoleiro\natracar\natrevido\natriz\natual\natum\nauditor\naumentar\naura\naurora\nautismo\nautoria\nautuar\navaliar\navante\navaria\navental\navesso\naviador\navisar\navulso\naxila\nazarar\nazedo\nazeite\nazulejo\nbabar\nbabosa\nbacalhau\nbacharel\nbacia\nbagagem\nbaiano\nbailar\nbaioneta\nbairro\nbaixista\nbajular\nbaleia\nbaliza\nbalsa\nbanal\nbandeira\nbanho\nbanir\nbanquete\nbarato\nbarbado\nbaronesa\nbarraca\nbarulho\nbaseado\nbastante\nbatata\nbatedor\nbatida\nbatom\nbatucar\nbaunilha\nbeber\nbeijo\nbeirada\nbeisebol\nbeldade\nbeleza\nbelga\nbeliscar\nbendito\nbengala\nbenzer\nberimbau\nberlinda\nberro\nbesouro\nbexiga\nbezerro\nbico\nbicudo\nbienal\nbifocal\nbifurcar\nbigorna\nbilhete\nbimestre\nbimotor\nbiologia\nbiombo\nbiosfera\nbipolar\nbirrento\nbiscoito\nbisneto\nbispo\nbissexto\nbitola\nbizarro\nblindado\nbloco\nbloquear\nboato\nbobagem\nbocado\nbocejo\nbochecha\nboicotar\nbolada\nboletim\nbolha\nbolo\nbombeiro\nbonde\nboneco\nbonita\nborbulha\nborda\nboreal\nborracha\nbovino\nboxeador\nbranco\nbrasa\nbraveza\nbreu\nbriga\nbrilho\nbrincar\nbroa\nbrochura\nbronzear\nbroto\nbruxo\nbucha\nbudismo\nbufar\nbule\nburaco\nbusca\nbusto\nbuzina\ncabana\ncabelo\ncabide\ncabo\ncabrito\ncacau\ncacetada\ncachorro\ncacique\ncadastro\ncadeado\ncafezal\ncaiaque\ncaipira\ncaixote\ncajado\ncaju\ncalafrio\ncalcular\ncaldeira\ncalibrar\ncalmante\ncalota\ncamada\ncambista\ncamisa\ncamomila\ncampanha\ncamuflar\ncanavial\ncancelar\ncaneta\ncanguru\ncanhoto\ncanivete\ncanoa\ncansado\ncantar\ncanudo\ncapacho\ncapela\ncapinar\ncapotar\ncapricho\ncaptador\ncapuz\ncaracol\ncarbono\ncardeal\ncareca\ncarimbar\ncarneiro\ncarpete\ncarreira\ncartaz\ncarvalho\ncasaco\ncasca\ncasebre\ncastelo\ncasulo\ncatarata\ncativar\ncaule\ncausador\ncautelar\ncavalo\ncaverna\ncebola\ncedilha\ncegonha\ncelebrar\ncelular\ncenoura\ncenso\ncenteio\ncercar\ncerrado\ncerteiro\ncerveja\ncetim\ncevada\nchacota\nchaleira\nchamado\nchapada\ncharme\nchatice\nchave\nchefe\nchegada\ncheiro\ncheque\nchicote\nchifre\nchinelo\nchocalho\nchover\nchumbo\nchutar\nchuva\ncicatriz\nciclone\ncidade\ncidreira\nciente\ncigana\ncimento\ncinto\ncinza\nciranda\ncircuito\ncirurgia\ncitar\nclareza\nclero\nclicar\nclone\nclube\ncoado\ncoagir\ncobaia\ncobertor\ncobrar\ncocada\ncoelho\ncoentro\ncoeso\ncogumelo\ncoibir\ncoifa\ncoiote\ncolar\ncoleira\ncolher\ncolidir\ncolmeia\ncolono\ncoluna\ncomando\ncombinar\ncomentar\ncomitiva\ncomover\ncomplexo\ncomum\nconcha\ncondor\nconectar\nconfuso\ncongelar\nconhecer\nconjugar\nconsumir\ncontrato\nconvite\ncooperar\ncopeiro\ncopiador\ncopo\ncoquetel\ncoragem\ncordial\ncorneta\ncoronha\ncorporal\ncorreio\ncortejo\ncoruja\ncorvo\ncosseno\ncostela\ncotonete\ncouro\ncouve\ncovil\ncozinha\ncratera\ncravo\ncreche\ncredor\ncreme\ncrer\ncrespo\ncriada\ncriminal\ncrioulo\ncrise\ncriticar\ncrosta\ncrua\ncruzeiro\ncubano\ncueca\ncuidado\ncujo\nculatra\nculminar\nculpar\ncultura\ncumprir\ncunhado\ncupido\ncurativo\ncurral\ncursar\ncurto\ncuspir\ncustear\ncutelo\ndamasco\ndatar\ndebater\ndebitar\ndeboche\ndebulhar\ndecalque\ndecimal\ndeclive\ndecote\ndecretar\ndedal\ndedicado\ndeduzir\ndefesa\ndefumar\ndegelo\ndegrau\ndegustar\ndeitado\ndeixar\ndelator\ndelegado\ndelinear\ndelonga\ndemanda\ndemitir\ndemolido\ndentista\ndepenado\ndepilar\ndepois\ndepressa\ndepurar\nderiva\nderramar\ndesafio\ndesbotar\ndescanso\ndesenho\ndesfiado\ndesgaste\ndesigual\ndeslize\ndesmamar\ndesova\ndespesa\ndestaque\ndesviar\ndetalhar\ndetentor\ndetonar\ndetrito\ndeusa\ndever\ndevido\ndevotado\ndezena\ndiagrama\ndialeto\ndidata\ndifuso\ndigitar\ndilatado\ndiluente\ndiminuir\ndinastia\ndinheiro\ndiocese\ndireto\ndiscreta\ndisfarce\ndisparo\ndisquete\ndissipar\ndistante\nditador\ndiurno\ndiverso\ndivisor\ndivulgar\ndizer\ndobrador\ndolorido\ndomador\ndominado\ndonativo\ndonzela\ndormente\ndorsal\ndosagem\ndourado\ndoutor\ndrenagem\ndrible\ndrogaria\nduelar\nduende\ndueto\nduplo\nduquesa\ndurante\nduvidoso\neclodir\necoar\necologia\nedificar\nedital\neducado\nefeito\nefetivar\nejetar\nelaborar\neleger\neleitor\nelenco\nelevador\neliminar\nelogiar\nembargo\nembolado\nembrulho\nembutido\nemenda\nemergir\nemissor\nempatia\nempenho\nempinado\nempolgar\nemprego\nempurrar\nemulador\nencaixe\nencenado\nenchente\nencontro\nendeusar\nendossar\nenfaixar\nenfeite\nenfim\nengajado\nengenho\nenglobar\nengomado\nengraxar\nenguia\nenjoar\nenlatar\nenquanto\nenraizar\nenrolado\nenrugar\nensaio\nenseada\nensino\nensopado\nentanto\nenteado\nentidade\nentortar\nentrada\nentulho\nenvergar\nenviado\nenvolver\nenxame\nenxerto\nenxofre\nenxuto\nepiderme\nequipar\nereto\nerguido\nerrata\nerva\nervilha\nesbanjar\nesbelto\nescama\nescola\nescrita\nescuta\nesfinge\nesfolar\nesfregar\nesfumado\nesgrima\nesmalte\nespanto\nespelho\nespiga\nesponja\nespreita\nespumar\nesquerda\nestaca\nesteira\nesticar\nestofado\nestrela\nestudo\nesvaziar\netanol\netiqueta\neuforia\neuropeu\nevacuar\nevaporar\nevasivo\neventual\nevidente\nevoluir\nexagero\nexalar\nexaminar\nexato\nexausto\nexcesso\nexcitar\nexclamar\nexecutar\nexemplo\nexibir\nexigente\nexonerar\nexpandir\nexpelir\nexpirar\nexplanar\nexposto\nexpresso\nexpulsar\nexterno\nextinto\nextrato\nfabricar\nfabuloso\nfaceta\nfacial\nfada\nfadiga\nfaixa\nfalar\nfalta\nfamiliar\nfandango\nfanfarra\nfantoche\nfardado\nfarelo\nfarinha\nfarofa\nfarpa\nfartura\nfatia\nfator\nfavorita\nfaxina\nfazenda\nfechado\nfeijoada\nfeirante\nfelino\nfeminino\nfenda\nfeno\nfera\nferiado\nferrugem\nferver\nfestejar\nfetal\nfeudal\nfiapo\nfibrose\nficar\nficheiro\nfigurado\nfileira\nfilho\nfilme\nfiltrar\nfirmeza\nfisgada\nfissura\nfita\nfivela\nfixador\nfixo\nflacidez\nflamingo\nflanela\nflechada\nflora\nflutuar\nfluxo\nfocal\nfocinho\nfofocar\nfogo\nfoguete\nfoice\nfolgado\nfolheto\nforjar\nformiga\nforno\nforte\nfosco\nfossa\nfragata\nfralda\nfrango\nfrasco\nfraterno\nfreira\nfrente\nfretar\nfrieza\nfriso\nfritura\nfronha\nfrustrar\nfruteira\nfugir\nfulano\nfuligem\nfundar\nfungo\nfunil\nfurador\nfurioso\nfutebol\ngabarito\ngabinete\ngado\ngaiato\ngaiola\ngaivota\ngalega\ngalho\ngalinha\ngalocha\nganhar\ngaragem\ngarfo\ngargalo\ngarimpo\ngaroupa\ngarrafa\ngasoduto\ngasto\ngata\ngatilho\ngaveta\ngazela\ngelado\ngeleia\ngelo\ngemada\ngemer\ngemido\ngeneroso\ngengiva\ngenial\ngenoma\ngenro\ngeologia\ngerador\ngerminar\ngesso\ngestor\nginasta\ngincana\ngingado\ngirafa\ngirino\nglacial\nglicose\nglobal\nglorioso\ngoela\ngoiaba\ngolfe\ngolpear\ngordura\ngorjeta\ngorro\ngostoso\ngoteira\ngovernar\ngracejo\ngradual\ngrafite\ngralha\ngrampo\ngranada\ngratuito\ngraveto\ngraxa\ngrego\ngrelhar\ngreve\ngrilo\ngrisalho\ngritaria\ngrosso\ngrotesco\ngrudado\ngrunhido\ngruta\nguache\nguarani\nguaxinim\nguerrear\nguiar\nguincho\nguisado\ngula\nguloso\nguru\nhabitar\nharmonia\nhaste\nhaver\nhectare\nherdar\nheresia\nhesitar\nhiato\nhibernar\nhidratar\nhiena\nhino\nhipismo\nhipnose\nhipoteca\nhoje\nholofote\nhomem\nhonesto\nhonrado\nhormonal\nhospedar\nhumorado\niate\nideia\nidoso\nignorado\nigreja\niguana\nileso\nilha\niludido\niluminar\nilustrar\nimagem\nimediato\nimenso\nimersivo\niminente\nimitador\nimortal\nimpacto\nimpedir\nimplante\nimpor\nimprensa\nimpune\nimunizar\ninalador\ninapto\ninativo\nincenso\ninchar\nincidir\nincluir\nincolor\nindeciso\nindireto\nindutor\nineficaz\ninerente\ninfantil\ninfestar\ninfinito\ninflamar\ninformal\ninfrator\ningerir\ninibido\ninicial\ninimigo\ninjetar\ninocente\ninodoro\ninovador\ninox\ninquieto\ninscrito\ninseto\ninsistir\ninspetor\ninstalar\ninsulto\nintacto\nintegral\nintimar\nintocado\nintriga\ninvasor\ninverno\ninvicto\ninvocar\niogurte\niraniano\nironizar\nirreal\nirritado\nisca\nisento\nisolado\nisqueiro\nitaliano\njaneiro\njangada\njanta\njararaca\njardim\njarro\njasmim\njato\njavali\njazida\njejum\njoaninha\njoelhada\njogador\njoia\njornal\njorrar\njovem\njuba\njudeu\njudoca\njuiz\njulgador\njulho\njurado\njurista\njuro\njusta\nlabareda\nlaboral\nlacre\nlactante\nladrilho\nlagarta\nlagoa\nlaje\nlamber\nlamentar\nlaminar\nlampejo\nlanche\nlapidar\nlapso\nlaranja\nlareira\nlargura\nlasanha\nlastro\nlateral\nlatido\nlavanda\nlavoura\nlavrador\nlaxante\nlazer\nlealdade\nlebre\nlegado\nlegendar\nlegista\nleigo\nleiloar\nleitura\nlembrete\nleme\nlenhador\nlentilha\nleoa\nlesma\nleste\nletivo\nletreiro\nlevar\nleveza\nlevitar\nliberal\nlibido\nliderar\nligar\nligeiro\nlimitar\nlimoeiro\nlimpador\nlinda\nlinear\nlinhagem\nliquidez\nlistagem\nlisura\nlitoral\nlivro\nlixa\nlixeira\nlocador\nlocutor\nlojista\nlombo\nlona\nlonge\nlontra\nlorde\nlotado\nloteria\nloucura\nlousa\nlouvar\nluar\nlucidez\nlucro\nluneta\nlustre\nlutador\nluva\nmacaco\nmacete\nmachado\nmacio\nmadeira\nmadrinha\nmagnata\nmagreza\nmaior\nmais\nmalandro\nmalha\nmalote\nmaluco\nmamilo\nmamoeiro\nmamute\nmanada\nmancha\nmandato\nmanequim\nmanhoso\nmanivela\nmanobrar\nmansa\nmanter\nmanusear\nmapeado\nmaquinar\nmarcador\nmaresia\nmarfim\nmargem\nmarinho\nmarmita\nmaroto\nmarquise\nmarreco\nmartelo\nmarujo\nmascote\nmasmorra\nmassagem\nmastigar\nmatagal\nmaterno\nmatinal\nmatutar\nmaxilar\nmedalha\nmedida\nmedusa\nmegafone\nmeiga\nmelancia\nmelhor\nmembro\nmemorial\nmenino\nmenos\nmensagem\nmental\nmerecer\nmergulho\nmesada\nmesclar\nmesmo\nmesquita\nmestre\nmetade\nmeteoro\nmetragem\nmexer\nmexicano\nmicro\nmigalha\nmigrar\nmilagre\nmilenar\nmilhar\nmimado\nminerar\nminhoca\nministro\nminoria\nmiolo\nmirante\nmirtilo\nmisturar\nmocidade\nmoderno\nmodular\nmoeda\nmoer\nmoinho\nmoita\nmoldura\nmoleza\nmolho\nmolinete\nmolusco\nmontanha\nmoqueca\nmorango\nmorcego\nmordomo\nmorena\nmosaico\nmosquete\nmostarda\nmotel\nmotim\nmoto\nmotriz\nmuda\nmuito\nmulata\nmulher\nmultar\nmundial\nmunido\nmuralha\nmurcho\nmuscular\nmuseu\nmusical\nnacional\nnadador\nnaja\nnamoro\nnarina\nnarrado\nnascer\nnativa\nnatureza\nnavalha\nnavegar\nnavio\nneblina\nnebuloso\nnegativa\nnegociar\nnegrito\nnervoso\nneta\nneural\nnevasca\nnevoeiro\nninar\nninho\nnitidez\nnivelar\nnobreza\nnoite\nnoiva\nnomear\nnominal\nnordeste\nnortear\nnotar\nnoticiar\nnoturno\nnovelo\nnovilho\nnovo\nnublado\nnudez\nnumeral\nnupcial\nnutrir\nnuvem\nobcecado\nobedecer\nobjetivo\nobrigado\nobscuro\nobstetra\nobter\nobturar\nocidente\nocioso\nocorrer\noculista\nocupado\nofegante\nofensiva\noferenda\noficina\nofuscado\nogiva\nolaria\noleoso\nolhar\noliveira\nombro\nomelete\nomisso\nomitir\nondulado\noneroso\nontem\nopcional\noperador\noponente\noportuno\noposto\norar\norbitar\nordem\nordinal\norfanato\norgasmo\norgulho\noriental\norigem\noriundo\norla\nortodoxo\norvalho\noscilar\nossada\nosso\nostentar\notimismo\nousadia\noutono\noutubro\nouvido\novelha\novular\noxidar\noxigenar\npacato\npaciente\npacote\npactuar\npadaria\npadrinho\npagar\npagode\npainel\npairar\npaisagem\npalavra\npalestra\npalheta\npalito\npalmada\npalpitar\npancada\npanela\npanfleto\npanqueca\npantanal\npapagaio\npapelada\npapiro\nparafina\nparcial\npardal\nparede\npartida\npasmo\npassado\npastel\npatamar\npatente\npatinar\npatrono\npaulada\npausar\npeculiar\npedalar\npedestre\npediatra\npedra\npegada\npeitoral\npeixe\npele\npelicano\npenca\npendurar\npeneira\npenhasco\npensador\npente\nperceber\nperfeito\npergunta\nperito\npermitir\nperna\nperplexo\npersiana\npertence\nperuca\npescado\npesquisa\npessoa\npetiscar\npiada\npicado\npiedade\npigmento\npilastra\npilhado\npilotar\npimenta\npincel\npinguim\npinha\npinote\npintar\npioneiro\npipoca\npiquete\npiranha\npires\npirueta\npiscar\npistola\npitanga\npivete\nplanta\nplaqueta\nplatina\nplebeu\nplumagem\npluvial\npneu\npoda\npoeira\npoetisa\npolegada\npoliciar\npoluente\npolvilho\npomar\npomba\nponderar\npontaria\npopuloso\nporta\npossuir\npostal\npote\npoupar\npouso\npovoar\npraia\nprancha\nprato\npraxe\nprece\npredador\nprefeito\npremiar\nprensar\npreparar\npresilha\npretexto\nprevenir\nprezar\nprimata\nprincesa\nprisma\nprivado\nprocesso\nproduto\nprofeta\nproibido\nprojeto\nprometer\npropagar\nprosa\nprotetor\nprovador\npublicar\npudim\npular\npulmonar\npulseira\npunhal\npunir\npupilo\npureza\npuxador\nquadra\nquantia\nquarto\nquase\nquebrar\nqueda\nqueijo\nquente\nquerido\nquimono\nquina\nquiosque\nrabanada\nrabisco\nrachar\nracionar\nradial\nraiar\nrainha\nraio\nraiva\nrajada\nralado\nramal\nranger\nranhura\nrapadura\nrapel\nrapidez\nraposa\nraquete\nraridade\nrasante\nrascunho\nrasgar\nraspador\nrasteira\nrasurar\nratazana\nratoeira\nrealeza\nreanimar\nreaver\nrebaixar\nrebelde\nrebolar\nrecado\nrecente\nrecheio\nrecibo\nrecordar\nrecrutar\nrecuar\nrede\nredimir\nredonda\nreduzida\nreenvio\nrefinar\nrefletir\nrefogar\nrefresco\nrefugiar\nregalia\nregime\nregra\nreinado\nreitor\nrejeitar\nrelativo\nremador\nremendo\nremorso\nrenovado\nreparo\nrepelir\nrepleto\nrepolho\nrepresa\nrepudiar\nrequerer\nresenha\nresfriar\nresgatar\nresidir\nresolver\nrespeito\nressaca\nrestante\nresumir\nretalho\nreter\nretirar\nretomada\nretratar\nrevelar\nrevisor\nrevolta\nriacho\nrica\nrigidez\nrigoroso\nrimar\nringue\nrisada\nrisco\nrisonho\nrobalo\nrochedo\nrodada\nrodeio\nrodovia\nroedor\nroleta\nromano\nroncar\nrosado\nroseira\nrosto\nrota\nroteiro\nrotina\nrotular\nrouco\nroupa\nroxo\nrubro\nrugido\nrugoso\nruivo\nrumo\nrupestre\nrusso\nsabor\nsaciar\nsacola\nsacudir\nsadio\nsafira\nsaga\nsagrada\nsaibro\nsalada\nsaleiro\nsalgado\nsaliva\nsalpicar\nsalsicha\nsaltar\nsalvador\nsambar\nsamurai\nsanar\nsanfona\nsangue\nsanidade\nsapato\nsarda\nsargento\nsarjeta\nsaturar\nsaudade\nsaxofone\nsazonal\nsecar\nsecular\nseda\nsedento\nsediado\nsedoso\nsedutor\nsegmento\nsegredo\nsegundo\nseiva\nseleto\nselvagem\nsemanal\nsemente\nsenador\nsenhor\nsensual\nsentado\nseparado\nsereia\nseringa\nserra\nservo\nsetembro\nsetor\nsigilo\nsilhueta\nsilicone\nsimetria\nsimpatia\nsimular\nsinal\nsincero\nsingular\nsinopse\nsintonia\nsirene\nsiri\nsituado\nsoberano\nsobra\nsocorro\nsogro\nsoja\nsolda\nsoletrar\nsolteiro\nsombrio\nsonata\nsondar\nsonegar\nsonhador\nsono\nsoprano\nsoquete\nsorrir\nsorteio\nsossego\nsotaque\nsoterrar\nsovado\nsozinho\nsuavizar\nsubida\nsubmerso\nsubsolo\nsubtrair\nsucata\nsucesso\nsuco\nsudeste\nsufixo\nsugador\nsugerir\nsujeito\nsulfato\nsumir\nsuor\nsuperior\nsuplicar\nsuposto\nsuprimir\nsurdina\nsurfista\nsurpresa\nsurreal\nsurtir\nsuspiro\nsustento\ntabela\ntablete\ntabuada\ntacho\ntagarela\ntalher\ntalo\ntalvez\ntamanho\ntamborim\ntampa\ntangente\ntanto\ntapar\ntapioca\ntardio\ntarefa\ntarja\ntarraxa\ntatuagem\ntaurino\ntaxativo\ntaxista\nteatral\ntecer\ntecido\nteclado\ntedioso\nteia\nteimar\ntelefone\ntelhado\ntempero\ntenente\ntensor\ntentar\ntermal\nterno\nterreno\ntese\ntesoura\ntestado\nteto\ntextura\ntexugo\ntiara\ntigela\ntijolo\ntimbrar\ntimidez\ntingido\ntinteiro\ntiragem\ntitular\ntoalha\ntocha\ntolerar\ntolice\ntomada\ntomilho\ntonel\ntontura\ntopete\ntora\ntorcido\ntorneio\ntorque\ntorrada\ntorto\ntostar\ntouca\ntoupeira\ntoxina\ntrabalho\ntracejar\ntradutor\ntrafegar\ntrajeto\ntrama\ntrancar\ntrapo\ntraseiro\ntratador\ntravar\ntreino\ntremer\ntrepidar\ntrevo\ntriagem\ntribo\ntriciclo\ntridente\ntrilogia\ntrindade\ntriplo\ntriturar\ntriunfal\ntrocar\ntrombeta\ntrova\ntrunfo\ntruque\ntubular\ntucano\ntudo\ntulipa\ntupi\nturbo\nturma\nturquesa\ntutelar\ntutorial\nuivar\numbigo\nunha\nunidade\nuniforme\nurologia\nurso\nurtiga\nurubu\nusado\nusina\nusufruir\nvacina\nvadiar\nvagaroso\nvaidoso\nvala\nvalente\nvalidade\nvalores\nvantagem\nvaqueiro\nvaranda\nvareta\nvarrer\nvascular\nvasilha\nvassoura\nvazar\nvazio\nveado\nvedar\nvegetar\nveicular\nveleiro\nvelhice\nveludo\nvencedor\nvendaval\nvenerar\nventre\nverbal\nverdade\nvereador\nvergonha\nvermelho\nverniz\nversar\nvertente\nvespa\nvestido\nvetorial\nviaduto\nviagem\nviajar\nviatura\nvibrador\nvideira\nvidraria\nviela\nviga\nvigente\nvigiar\nvigorar\nvilarejo\nvinco\nvinheta\nvinil\nvioleta\nvirada\nvirtude\nvisitar\nvisto\nvitral\nviveiro\nvizinho\nvoador\nvoar\nvogal\nvolante\nvoleibol\nvoltagem\nvolumoso\nvontade\nvulto\nvuvuzela\nxadrez\nxarope\nxeque\nxeretar\nxerife\nxingar\nzangado\nzarpar\nzebu\nzelador\nzombar\nzoologia\nzumbido`.split('\\n');\n", "export const wordlist = `\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`.split('\\n');\n", "export const wordlist = `abaco\nabdomen\nabeja\nabierto\nabogado\nabono\naborto\nabrazo\nabrir\nabuelo\nabuso\nacabar\nacademia\nacceso\naccion\naceite\nacelga\nacento\naceptar\nacido\naclarar\nacne\nacoger\nacoso\nactivo\nacto\nactriz\nactuar\nacudir\nacuerdo\nacusar\nadicto\nadmitir\nadoptar\nadorno\naduana\nadulto\naereo\nafectar\naficion\nafinar\nafirmar\nagil\nagitar\nagonia\nagosto\nagotar\nagregar\nagrio\nagua\nagudo\naguila\naguja\nahogo\nahorro\naire\naislar\najedrez\najeno\najuste\nalacran\nalambre\nalarma\nalba\nalbum\nalcalde\naldea\nalegre\nalejar\nalerta\naleta\nalfiler\nalga\nalgodon\naliado\naliento\nalivio\nalma\nalmeja\nalmibar\naltar\nalteza\naltivo\nalto\naltura\nalumno\nalzar\namable\namante\namapola\namargo\namasar\nambar\nambito\nameno\namigo\namistad\namor\namparo\namplio\nancho\nanciano\nancla\nandar\nanden\nanemia\nangulo\nanillo\nanimo\nanis\nanotar\nantena\nantiguo\nantojo\nanual\nanular\nanuncio\nanadir\nanejo\nano\napagar\naparato\napetito\napio\naplicar\napodo\naporte\napoyo\naprender\naprobar\napuesta\napuro\narado\narana\narar\narbitro\narbol\narbusto\narchivo\narco\narder\nardilla\narduo\narea\narido\naries\narmonia\narnes\naroma\narpa\narpon\narreglo\narroz\narruga\narte\nartista\nasa\nasado\nasalto\nascenso\nasegurar\naseo\nasesor\nasiento\nasilo\nasistir\nasno\nasombro\naspero\nastilla\nastro\nastuto\nasumir\nasunto\natajo\nataque\natar\natento\nateo\natico\natleta\natomo\natraer\natroz\natun\naudaz\naudio\nauge\naula\naumento\nausente\nautor\naval\navance\navaro\nave\navellana\navena\navestruz\navion\naviso\nayer\nayuda\nayuno\nazafran\nazar\nazote\nazucar\nazufre\nazul\nbaba\nbabor\nbache\nbahia\nbaile\nbajar\nbalanza\nbalcon\nbalde\nbambu\nbanco\nbanda\nbano\nbarba\nbarco\nbarniz\nbarro\nbascula\nbaston\nbasura\nbatalla\nbateria\nbatir\nbatuta\nbaul\nbazar\nbebe\nbebida\nbello\nbesar\nbeso\nbestia\nbicho\nbien\nbingo\nblanco\nbloque\nblusa\nboa\nbobina\nbobo\nboca\nbocina\nboda\nbodega\nboina\nbola\nbolero\nbolsa\nbomba\nbondad\nbonito\nbono\nbonsai\nborde\nborrar\nbosque\nbote\nbotin\nboveda\nbozal\nbravo\nbrazo\nbrecha\nbreve\nbrillo\nbrinco\nbrisa\nbroca\nbroma\nbronce\nbrote\nbruja\nbrusco\nbruto\nbuceo\nbucle\nbueno\nbuey\nbufanda\nbufon\nbuho\nbuitre\nbulto\nburbuja\nburla\nburro\nbuscar\nbutaca\nbuzon\ncaballo\ncabeza\ncabina\ncabra\ncacao\ncadaver\ncadena\ncaer\ncafe\ncaida\ncaiman\ncaja\ncajon\ncal\ncalamar\ncalcio\ncaldo\ncalidad\ncalle\ncalma\ncalor\ncalvo\ncama\ncambio\ncamello\ncamino\ncampo\ncancer\ncandil\ncanela\ncanguro\ncanica\ncanto\ncana\ncanon\ncaoba\ncaos\ncapaz\ncapitan\ncapote\ncaptar\ncapucha\ncara\ncarbon\ncarcel\ncareta\ncarga\ncarino\ncarne\ncarpeta\ncarro\ncarta\ncasa\ncasco\ncasero\ncaspa\ncastor\ncatorce\ncatre\ncaudal\ncausa\ncazo\ncebolla\nceder\ncedro\ncelda\ncelebre\nceloso\ncelula\ncemento\nceniza\ncentro\ncerca\ncerdo\ncereza\ncero\ncerrar\ncerteza\ncesped\ncetro\nchacal\nchaleco\nchampu\nchancla\nchapa\ncharla\nchico\nchiste\nchivo\nchoque\nchoza\nchuleta\nchupar\nciclon\nciego\ncielo\ncien\ncierto\ncifra\ncigarro\ncima\ncinco\ncine\ncinta\ncipres\ncirco\nciruela\ncisne\ncita\nciudad\nclamor\nclan\nclaro\nclase\nclave\ncliente\nclima\nclinica\ncobre\ncoccion\ncochino\ncocina\ncoco\ncodigo\ncodo\ncofre\ncoger\ncohete\ncojin\ncojo\ncola\ncolcha\ncolegio\ncolgar\ncolina\ncollar\ncolmo\ncolumna\ncombate\ncomer\ncomida\ncomodo\ncompra\nconde\nconejo\nconga\nconocer\nconsejo\ncontar\ncopa\ncopia\ncorazon\ncorbata\ncorcho\ncordon\ncorona\ncorrer\ncoser\ncosmos\ncosta\ncraneo\ncrater\ncrear\ncrecer\ncreido\ncrema\ncria\ncrimen\ncripta\ncrisis\ncromo\ncronica\ncroqueta\ncrudo\ncruz\ncuadro\ncuarto\ncuatro\ncubo\ncubrir\ncuchara\ncuello\ncuento\ncuerda\ncuesta\ncueva\ncuidar\nculebra\nculpa\nculto\ncumbre\ncumplir\ncuna\ncuneta\ncuota\ncupon\ncupula\ncurar\ncurioso\ncurso\ncurva\ncutis\ndama\ndanza\ndar\ndardo\ndatil\ndeber\ndebil\ndecada\ndecir\ndedo\ndefensa\ndefinir\ndejar\ndelfin\ndelgado\ndelito\ndemora\ndenso\ndental\ndeporte\nderecho\nderrota\ndesayuno\ndeseo\ndesfile\ndesnudo\ndestino\ndesvio\ndetalle\ndetener\ndeuda\ndia\ndiablo\ndiadema\ndiamante\ndiana\ndiario\ndibujo\ndictar\ndiente\ndieta\ndiez\ndificil\ndigno\ndilema\ndiluir\ndinero\ndirecto\ndirigir\ndisco\ndiseno\ndisfraz\ndiva\ndivino\ndoble\ndoce\ndolor\ndomingo\ndon\ndonar\ndorado\ndormir\ndorso\ndos\ndosis\ndragon\ndroga\nducha\nduda\nduelo\ndueno\ndulce\nduo\nduque\ndurar\ndureza\nduro\nebano\nebrio\nechar\neco\necuador\nedad\nedicion\nedificio\neditor\neducar\nefecto\neficaz\neje\nejemplo\nelefante\nelegir\nelemento\nelevar\nelipse\nelite\nelixir\nelogio\neludir\nembudo\nemitir\nemocion\nempate\nempeno\nempleo\nempresa\nenano\nencargo\nenchufe\nencia\nenemigo\nenero\nenfado\nenfermo\nengano\nenigma\nenlace\nenorme\nenredo\nensayo\nensenar\nentero\nentrar\nenvase\nenvio\nepoca\nequipo\nerizo\nescala\nescena\nescolar\nescribir\nescudo\nesencia\nesfera\nesfuerzo\nespada\nespejo\nespia\nesposa\nespuma\nesqui\nestar\neste\nestilo\nestufa\netapa\neterno\netica\netnia\nevadir\nevaluar\nevento\nevitar\nexacto\nexamen\nexceso\nexcusa\nexento\nexigir\nexilio\nexistir\nexito\nexperto\nexplicar\nexponer\nextremo\nfabrica\nfabula\nfachada\nfacil\nfactor\nfaena\nfaja\nfalda\nfallo\nfalso\nfaltar\nfama\nfamilia\nfamoso\nfaraon\nfarmacia\nfarol\nfarsa\nfase\nfatiga\nfauna\nfavor\nfax\nfebrero\nfecha\nfeliz\nfeo\nferia\nferoz\nfertil\nfervor\nfestin\nfiable\nfianza\nfiar\nfibra\nficcion\nficha\nfideo\nfiebre\nfiel\nfiera\nfiesta\nfigura\nfijar\nfijo\nfila\nfilete\nfilial\nfiltro\nfin\nfinca\nfingir\nfinito\nfirma\nflaco\nflauta\nflecha\nflor\nflota\nfluir\nflujo\nfluor\nfobia\nfoca\nfogata\nfogon\nfolio\nfolleto\nfondo\nforma\nforro\nfortuna\nforzar\nfosa\nfoto\nfracaso\nfragil\nfranja\nfrase\nfraude\nfreir\nfreno\nfresa\nfrio\nfrito\nfruta\nfuego\nfuente\nfuerza\nfuga\nfumar\nfuncion\nfunda\nfurgon\nfuria\nfusil\nfutbol\nfuturo\ngacela\ngafas\ngaita\ngajo\ngala\ngaleria\ngallo\ngamba\nganar\ngancho\nganga\nganso\ngaraje\ngarza\ngasolina\ngastar\ngato\ngavilan\ngemelo\ngemir\ngen\ngenero\ngenio\ngente\ngeranio\ngerente\ngermen\ngesto\ngigante\ngimnasio\ngirar\ngiro\nglaciar\nglobo\ngloria\ngol\ngolfo\ngoloso\ngolpe\ngoma\ngordo\ngorila\ngorra\ngota\ngoteo\ngozar\ngrada\ngrafico\ngrano\ngrasa\ngratis\ngrave\ngrieta\ngrillo\ngripe\ngris\ngrito\ngrosor\ngrua\ngrueso\ngrumo\ngrupo\nguante\nguapo\nguardia\nguerra\nguia\nguino\nguion\nguiso\nguitarra\ngusano\ngustar\nhaber\nhabil\nhablar\nhacer\nhacha\nhada\nhallar\nhamaca\nharina\nhaz\nhazana\nhebilla\nhebra\nhecho\nhelado\nhelio\nhembra\nherir\nhermano\nheroe\nhervir\nhielo\nhierro\nhigado\nhigiene\nhijo\nhimno\nhistoria\nhocico\nhogar\nhoguera\nhoja\nhombre\nhongo\nhonor\nhonra\nhora\nhormiga\nhorno\nhostil\nhoyo\nhueco\nhuelga\nhuerta\nhueso\nhuevo\nhuida\nhuir\nhumano\nhumedo\nhumilde\nhumo\nhundir\nhuracan\nhurto\nicono\nideal\nidioma\nidolo\niglesia\niglu\nigual\nilegal\nilusion\nimagen\niman\nimitar\nimpar\nimperio\nimponer\nimpulso\nincapaz\nindice\ninerte\ninfiel\ninforme\ningenio\ninicio\ninmenso\ninmune\ninnato\ninsecto\ninstante\ninteres\nintimo\nintuir\ninutil\ninvierno\nira\niris\nironia\nisla\nislote\njabali\njabon\njamon\njarabe\njardin\njarra\njaula\njazmin\njefe\njeringa\njinete\njornada\njoroba\njoven\njoya\njuerga\njueves\njuez\njugador\njugo\njuguete\njuicio\njunco\njungla\njunio\njuntar\njupiter\njurar\njusto\njuvenil\njuzgar\nkilo\nkoala\nlabio\nlacio\nlacra\nlado\nladron\nlagarto\nlagrima\nlaguna\nlaico\nlamer\nlamina\nlampara\nlana\nlancha\nlangosta\nlanza\nlapiz\nlargo\nlarva\nlastima\nlata\nlatex\nlatir\nlaurel\nlavar\nlazo\nleal\nleccion\nleche\nlector\nleer\nlegion\nlegumbre\nlejano\nlengua\nlento\nlena\nleon\nleopardo\nlesion\nletal\nletra\nleve\nleyenda\nlibertad\nlibro\nlicor\nlider\nlidiar\nlienzo\nliga\nligero\nlima\nlimite\nlimon\nlimpio\nlince\nlindo\nlinea\nlingote\nlino\nlinterna\nliquido\nliso\nlista\nlitera\nlitio\nlitro\nllaga\nllama\nllanto\nllave\nllegar\nllenar\nllevar\nllorar\nllover\nlluvia\nlobo\nlocion\nloco\nlocura\nlogica\nlogro\nlombriz\nlomo\nlonja\nlote\nlucha\nlucir\nlugar\nlujo\nluna\nlunes\nlupa\nlustro\nluto\nluz\nmaceta\nmacho\nmadera\nmadre\nmaduro\nmaestro\nmafia\nmagia\nmago\nmaiz\nmaldad\nmaleta\nmalla\nmalo\nmama\nmambo\nmamut\nmanco\nmando\nmanejar\nmanga\nmaniqui\nmanjar\nmano\nmanso\nmanta\nmanana\nmapa\nmaquina\nmar\nmarco\nmarea\nmarfil\nmargen\nmarido\nmarmol\nmarron\nmartes\nmarzo\nmasa\nmascara\nmasivo\nmatar\nmateria\nmatiz\nmatriz\nmaximo\nmayor\nmazorca\nmecha\nmedalla\nmedio\nmedula\nmejilla\nmejor\nmelena\nmelon\nmemoria\nmenor\nmensaje\nmente\nmenu\nmercado\nmerengue\nmerito\nmes\nmeson\nmeta\nmeter\nmetodo\nmetro\nmezcla\nmiedo\nmiel\nmiembro\nmiga\nmil\nmilagro\nmilitar\nmillon\nmimo\nmina\nminero\nminimo\nminuto\nmiope\nmirar\nmisa\nmiseria\nmisil\nmismo\nmitad\nmito\nmochila\nmocion\nmoda\nmodelo\nmoho\nmojar\nmolde\nmoler\nmolino\nmomento\nmomia\nmonarca\nmoneda\nmonja\nmonto\nmono\nmorada\nmorder\nmoreno\nmorir\nmorro\nmorsa\nmortal\nmosca\nmostrar\nmotivo\nmover\nmovil\nmozo\nmucho\nmudar\nmueble\nmuela\nmuerte\nmuestra\nmugre\nmujer\nmula\nmuleta\nmulta\nmundo\nmuneca\nmural\nmuro\nmusculo\nmuseo\nmusgo\nmusica\nmuslo\nnacar\nnacion\nnadar\nnaipe\nnaranja\nnariz\nnarrar\nnasal\nnatal\nnativo\nnatural\nnausea\nnaval\nnave\nnavidad\nnecio\nnectar\nnegar\nnegocio\nnegro\nneon\nnervio\nneto\nneutro\nnevar\nnevera\nnicho\nnido\nniebla\nnieto\nninez\nnino\nnitido\nnivel\nnobleza\nnoche\nnomina\nnoria\nnorma\nnorte\nnota\nnoticia\nnovato\nnovela\nnovio\nnube\nnuca\nnucleo\nnudillo\nnudo\nnuera\nnueve\nnuez\nnulo\nnumero\nnutria\noasis\nobeso\nobispo\nobjeto\nobra\nobrero\nobservar\nobtener\nobvio\noca\nocaso\noceano\nochenta\nocho\nocio\nocre\noctavo\noctubre\noculto\nocupar\nocurrir\nodiar\nodio\nodisea\noeste\nofensa\noferta\noficio\nofrecer\nogro\noido\noir\nojo\nola\noleada\nolfato\nolivo\nolla\nolmo\nolor\nolvido\nombligo\nonda\nonza\nopaco\nopcion\nopera\nopinar\noponer\noptar\noptica\nopuesto\noracion\norador\noral\norbita\norca\norden\noreja\norgano\norgia\norgullo\noriente\norigen\norilla\noro\norquesta\noruga\nosadia\noscuro\nosezno\noso\nostra\notono\notro\noveja\novulo\noxido\noxigeno\noyente\nozono\npacto\npadre\npaella\npagina\npago\npais\npajaro\npalabra\npalco\npaleta\npalido\npalma\npaloma\npalpar\npan\npanal\npanico\npantera\npanuelo\npapa\npapel\npapilla\npaquete\nparar\nparcela\npared\nparir\nparo\nparpado\nparque\nparrafo\nparte\npasar\npaseo\npasion\npaso\npasta\npata\npatio\npatria\npausa\npauta\npavo\npayaso\npeaton\npecado\npecera\npecho\npedal\npedir\npegar\npeine\npelar\npeldano\npelea\npeligro\npellejo\npelo\npeluca\npena\npensar\npenon\npeon\npeor\npepino\npequeno\npera\npercha\nperder\npereza\nperfil\nperico\nperla\npermiso\nperro\npersona\npesa\npesca\npesimo\npestana\npetalo\npetroleo\npez\npezuna\npicar\npichon\npie\npiedra\npierna\npieza\npijama\npilar\npiloto\npimienta\npino\npintor\npinza\npina\npiojo\npipa\npirata\npisar\npiscina\npiso\npista\npiton\npizca\nplaca\nplan\nplata\nplaya\nplaza\npleito\npleno\nplomo\npluma\nplural\npobre\npoco\npoder\npodio\npoema\npoesia\npoeta\npolen\npolicia\npollo\npolvo\npomada\npomelo\npomo\npompa\nponer\nporcion\nportal\nposada\nposeer\nposible\nposte\npotencia\npotro\npozo\nprado\nprecoz\npregunta\npremio\nprensa\npreso\nprevio\nprimo\nprincipe\nprision\nprivar\nproa\nprobar\nproceso\nproducto\nproeza\nprofesor\nprograma\nprole\npromesa\npronto\npropio\nproximo\nprueba\npublico\npuchero\npudor\npueblo\npuerta\npuesto\npulga\npulir\npulmon\npulpo\npulso\npuma\npunto\npunal\npuno\npupa\npupila\npure\nquedar\nqueja\nquemar\nquerer\nqueso\nquieto\nquimica\nquince\nquitar\nrabano\nrabia\nrabo\nracion\nradical\nraiz\nrama\nrampa\nrancho\nrango\nrapaz\nrapido\nrapto\nrasgo\nraspa\nrato\nrayo\nraza\nrazon\nreaccion\nrealidad\nrebano\nrebote\nrecaer\nreceta\nrechazo\nrecoger\nrecreo\nrecto\nrecurso\nred\nredondo\nreducir\nreflejo\nreforma\nrefran\nrefugio\nregalo\nregir\nregla\nregreso\nrehen\nreino\nreir\nreja\nrelato\nrelevo\nrelieve\nrelleno\nreloj\nremar\nremedio\nremo\nrencor\nrendir\nrenta\nreparto\nrepetir\nreposo\nreptil\nres\nrescate\nresina\nrespeto\nresto\nresumen\nretiro\nretorno\nretrato\nreunir\nreves\nrevista\nrey\nrezar\nrico\nriego\nrienda\nriesgo\nrifa\nrigido\nrigor\nrincon\nrinon\nrio\nriqueza\nrisa\nritmo\nrito\nrizo\nroble\nroce\nrociar\nrodar\nrodeo\nrodilla\nroer\nrojizo\nrojo\nromero\nromper\nron\nronco\nronda\nropa\nropero\nrosa\nrosca\nrostro\nrotar\nrubi\nrubor\nrudo\nrueda\nrugir\nruido\nruina\nruleta\nrulo\nrumbo\nrumor\nruptura\nruta\nrutina\nsabado\nsaber\nsabio\nsable\nsacar\nsagaz\nsagrado\nsala\nsaldo\nsalero\nsalir\nsalmon\nsalon\nsalsa\nsalto\nsalud\nsalvar\nsamba\nsancion\nsandia\nsanear\nsangre\nsanidad\nsano\nsanto\nsapo\nsaque\nsardina\nsarten\nsastre\nsatan\nsauna\nsaxofon\nseccion\nseco\nsecreto\nsecta\nsed\nseguir\nseis\nsello\nselva\nsemana\nsemilla\nsenda\nsensor\nsenal\nsenor\nseparar\nsepia\nsequia\nser\nserie\nsermon\nservir\nsesenta\nsesion\nseta\nsetenta\nsevero\nsexo\nsexto\nsidra\nsiesta\nsiete\nsiglo\nsigno\nsilaba\nsilbar\nsilencio\nsilla\nsimbolo\nsimio\nsirena\nsistema\nsitio\nsituar\nsobre\nsocio\nsodio\nsol\nsolapa\nsoldado\nsoledad\nsolido\nsoltar\nsolucion\nsombra\nsondeo\nsonido\nsonoro\nsonrisa\nsopa\nsoplar\nsoporte\nsordo\nsorpresa\nsorteo\nsosten\nsotano\nsuave\nsubir\nsuceso\nsudor\nsuegra\nsuelo\nsueno\nsuerte\nsufrir\nsujeto\nsultan\nsumar\nsuperar\nsuplir\nsuponer\nsupremo\nsur\nsurco\nsureno\nsurgir\nsusto\nsutil\ntabaco\ntabique\ntabla\ntabu\ntaco\ntacto\ntajo\ntalar\ntalco\ntalento\ntalla\ntalon\ntamano\ntambor\ntango\ntanque\ntapa\ntapete\ntapia\ntapon\ntaquilla\ntarde\ntarea\ntarifa\ntarjeta\ntarot\ntarro\ntarta\ntatuaje\ntauro\ntaza\ntazon\nteatro\ntecho\ntecla\ntecnica\ntejado\ntejer\ntejido\ntela\ntelefono\ntema\ntemor\ntemplo\ntenaz\ntender\ntener\ntenis\ntenso\nteoria\nterapia\nterco\ntermino\nternura\nterror\ntesis\ntesoro\ntestigo\ntetera\ntexto\ntez\ntibio\ntiburon\ntiempo\ntienda\ntierra\ntieso\ntigre\ntijera\ntilde\ntimbre\ntimido\ntimo\ntinta\ntio\ntipico\ntipo\ntira\ntiron\ntitan\ntitere\ntitulo\ntiza\ntoalla\ntobillo\ntocar\ntocino\ntodo\ntoga\ntoldo\ntomar\ntono\ntonto\ntopar\ntope\ntoque\ntorax\ntorero\ntormenta\ntorneo\ntoro\ntorpedo\ntorre\ntorso\ntortuga\ntos\ntosco\ntoser\ntoxico\ntrabajo\ntractor\ntraer\ntrafico\ntrago\ntraje\ntramo\ntrance\ntrato\ntrauma\ntrazar\ntrebol\ntregua\ntreinta\ntren\ntrepar\ntres\ntribu\ntrigo\ntripa\ntriste\ntriunfo\ntrofeo\ntrompa\ntronco\ntropa\ntrote\ntrozo\ntruco\ntrueno\ntrufa\ntuberia\ntubo\ntuerto\ntumba\ntumor\ntunel\ntunica\nturbina\nturismo\nturno\ntutor\nubicar\nulcera\numbral\nunidad\nunir\nuniverso\nuno\nuntar\nuna\nurbano\nurbe\nurgente\nurna\nusar\nusuario\nutil\nutopia\nuva\nvaca\nvacio\nvacuna\nvagar\nvago\nvaina\nvajilla\nvale\nvalido\nvalle\nvalor\nvalvula\nvampiro\nvara\nvariar\nvaron\nvaso\nvecino\nvector\nvehiculo\nveinte\nvejez\nvela\nvelero\nveloz\nvena\nvencer\nvenda\nveneno\nvengar\nvenir\nventa\nvenus\nver\nverano\nverbo\nverde\nvereda\nverja\nverso\nverter\nvia\nviaje\nvibrar\nvicio\nvictima\nvida\nvideo\nvidrio\nviejo\nviernes\nvigor\nvil\nvilla\nvinagre\nvino\nvinedo\nviolin\nviral\nvirgo\nvirtud\nvisor\nvispera\nvista\nvitamina\nviudo\nvivaz\nvivero\nvivir\nvivo\nvolcan\nvolumen\nvolver\nvoraz\nvotar\nvoto\nvoz\nvuelo\nvulgar\nyacer\nyate\nyegua\nyema\nyerno\nyeso\nyodo\nyoga\nyogur\nzafiro\nzanja\nzapato\nzarza\nzona\nzorro\nzumo\nzurdo`.split('\\n');\n", "export const wordlist = `\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n`.split('\\n');\n", "import * as idb from 'idb-keyval'\nimport * as Address from 'ox/Address'\nimport type * as Hex from 'ox/Hex'\nimport * as PublicKey from 'ox/PublicKey'\nimport { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\nimport {\n  createClient,\n  defineChain,\n  type EIP1193Provider,\n  getAddress,\n  type LocalAccount,\n  SwitchChainError,\n} from 'viem'\nimport { generatePrivateKey, privateKeyToAccount } from 'viem/accounts'\nimport {\n  Account,\n  WebAuthnP256,\n  WebCryptoP256,\n  walletNamespaceCompat,\n} from 'viem/tempo'\nimport { ChainNotConfiguredError, createConnector } from 'wagmi'\nimport type { OneOf } from '../internal/types.js'\nimport type * as KeyManager from './KeyManager.js'\n\n/**\n * Connector for a Secp256k1 EOA.\n *\n * WARNING: NOT RECOMMENDED FOR PRODUCTION USAGE.\n * This connector stores private keys in clear text, and are bound to the session\n * length of the storage used.\n *\n * @returns Connector.\n */\nexport function dangerous_secp256k1(\n  options: dangerous_secp256k1.Parameters = {},\n) {\n  let account: LocalAccount | undefined\n\n  type Properties = {\n    connect<withCapabilities extends boolean = false>(parameters: {\n      capabilities?:\n        | OneOf<\n            | {\n                type: 'sign-up'\n              }\n            | {}\n          >\n        | undefined\n      chainId?: number | undefined\n      isReconnecting?: boolean | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: readonly Address.Address[]\n      chainId: number\n    }>\n  }\n  type Provider = Pick<EIP1193Provider, 'request'>\n  type StorageItem = {\n    'secp256k1.activeAddress': Address.Address\n    'secp256k1.lastActiveAddress': Address.Address\n    [key: `secp256k1.${string}.privateKey`]: Hex.Hex\n  }\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'secp256k1',\n    name: 'EOA (Secp256k1)',\n    type: 'secp256k1',\n    async setup() {\n      const address = await config.storage?.getItem('secp256k1.activeAddress')\n      const privateKey = await config.storage?.getItem(\n        `secp256k1.${address}.privateKey`,\n      )\n      if (privateKey) account = privateKeyToAccount(privateKey)\n      else if (\n        address &&\n        options.account &&\n        Address.isEqual(address, options.account.address)\n      )\n        account = options.account\n    },\n    async connect(parameters = {}) {\n      const address = await (async () => {\n        if (\n          'capabilities' in parameters &&\n          parameters.capabilities?.type === 'sign-up'\n        ) {\n          const privateKey = generatePrivateKey()\n          const account = privateKeyToAccount(privateKey)\n          const address = account.address\n          await config.storage?.setItem(\n            `secp256k1.${address}.privateKey`,\n            privateKey,\n          )\n          await config.storage?.setItem('secp256k1.activeAddress', address)\n          await config.storage?.setItem('secp256k1.lastActiveAddress', address)\n          return address\n        }\n\n        const address = await config.storage?.getItem(\n          'secp256k1.lastActiveAddress',\n        )\n        const privateKey = await config.storage?.getItem(\n          `secp256k1.${address}.privateKey`,\n        )\n\n        if (privateKey) account = privateKeyToAccount(privateKey)\n        else if (options.account) {\n          account = options.account\n          await config.storage?.setItem(\n            'secp256k1.lastActiveAddress',\n            account.address,\n          )\n        }\n\n        if (!account) throw new Error('account not found.')\n\n        await config.storage?.setItem(\n          'secp256k1.activeAddress',\n          account.address,\n        )\n        return account.address\n      })()\n\n      const chainId = parameters.chainId ?? config.chains[0]?.id\n      if (!chainId) throw new ChainNotConfiguredError()\n\n      return {\n        accounts: (parameters.withCapabilities\n          ? [{ address }]\n          : [address]) as never,\n        chainId,\n      }\n    },\n    async disconnect() {\n      await config.storage?.removeItem('secp256k1.activeAddress')\n      account = undefined\n    },\n    async getAccounts() {\n      if (!account) return []\n      return [getAddress(account.address)]\n    },\n    async getChainId() {\n      return config.chains[0]?.id!\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch (error) {\n        console.error(\n          'Connector.secp256k1: Failed to check authorization',\n          error,\n        )\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n      return chain\n    },\n    onAccountsChanged() {},\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect() {\n      config.emitter.emit('disconnect')\n      account = undefined\n    },\n    async getClient({ chainId } = {}) {\n      const chain =\n        config.chains.find((x) => x.id === chainId) ?? config.chains[0]\n      if (!chain) throw new ChainNotConfiguredError()\n\n      const transports = config.transports\n      if (!transports) throw new ChainNotConfiguredError()\n\n      const transport = transports[chain.id]\n      if (!transport) throw new ChainNotConfiguredError()\n\n      if (!account) throw new Error('account not found.')\n\n      return createClient({\n        account,\n        chain,\n        transport: walletNamespaceCompat(transport, {\n          account,\n        }),\n      })\n    },\n    async getProvider({ chainId } = {}) {\n      const { request } = await this.getClient!({ chainId })\n      return { request }\n    },\n  }))\n}\n\nexport declare namespace dangerous_secp256k1 {\n  export type Parameters = {\n    account?: LocalAccount | undefined\n  }\n}\n\n/**\n * Connector for a WebAuthn EOA.\n *\n * @returns Connector.\n */\nexport function webAuthn(options: webAuthn.Parameters) {\n  let account: Account.RootAccount | undefined\n  let accessKey: Account.AccessKeyAccount | undefined\n\n  const defaultAccessKeyOptions = {\n    expiry: Math.floor(\n      (Date.now() + 24 * 60 * 60 * 1000) / 1000, // one day\n    ),\n    strict: false,\n  }\n  const accessKeyOptions = (() => {\n    if (typeof options.grantAccessKey === 'object')\n      return { ...defaultAccessKeyOptions, ...options.grantAccessKey }\n    if (options.grantAccessKey === true) return defaultAccessKeyOptions\n    return undefined\n  })()\n\n  type Properties = {\n    connect<withCapabilities extends boolean = false>(parameters: {\n      chainId?: number | undefined\n      capabilities?:\n        | OneOf<\n            | {\n                label?: string | undefined\n                type: 'sign-up'\n              }\n            | {\n                selectAccount?: boolean | undefined\n                type: 'sign-in'\n              }\n            | {}\n          >\n        | undefined\n      isReconnecting?: boolean | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{ accounts: readonly Address.Address[]; chainId: number }>\n  }\n  type Provider = Pick<EIP1193Provider, 'request'>\n  type StorageItem = {\n    [\n      key: `pendingKeyAuthorization:${string}`\n    ]: KeyAuthorization.KeyAuthorization\n    'webAuthn.activeCredential': WebAuthnP256.P256Credential\n    'webAuthn.lastActiveCredential': WebAuthnP256.P256Credential\n  }\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'webAuthn',\n    name: 'EOA (WebAuthn)',\n    type: 'webAuthn',\n    async setup() {\n      const credential = await config.storage?.getItem(\n        'webAuthn.activeCredential',\n      )\n      if (!credential) return\n      account = Account.fromWebAuthnP256(credential)\n    },\n    async connect(parameters = {}) {\n      const capabilities =\n        'capabilities' in parameters ? (parameters.capabilities ?? {}) : {}\n\n      if (\n        accessKeyOptions?.strict &&\n        accessKeyOptions.expiry &&\n        accessKeyOptions.expiry < Date.now() / 1000\n      )\n        throw new Error(\n          `\\`grantAccessKey.expiry = ${accessKeyOptions.expiry}\\` is in the past (${new Date(accessKeyOptions.expiry * 1000).toLocaleString()}). Please provide a valid expiry.`,\n        )\n\n      // We are going to need to find:\n      // - a WebAuthn `credential` to instantiate an account\n      // - optionally, a `keyPair` to use as the access key for the account\n      // - optionally, a signed `keyAuthorization` to provision the access key\n      const { credential, keyAuthorization, keyPair } = await (async () => {\n        // If the connection type is of \"sign-up\", we are going to create a new credential\n        // and provision an access key (if needed).\n        if (capabilities.type === 'sign-up') {\n          // Create credential (sign up)\n          const createOptions_remote = await options.keyManager.getChallenge?.()\n          const label =\n            capabilities.label ??\n            options.createOptions?.label ??\n            new Date().toISOString()\n          const rpId =\n            createOptions_remote?.rp?.id ??\n            options.createOptions?.rpId ??\n            options.rpId\n          const credential = await WebAuthnP256.createCredential({\n            ...(options.createOptions ?? {}),\n            label,\n            rpId,\n            ...(createOptions_remote ?? {}),\n          })\n          await options.keyManager.setPublicKey({\n            credential: credential.raw,\n            publicKey: credential.publicKey,\n          })\n\n          // Get key pair (access key) to use for the account.\n          const keyPair = await (async () => {\n            if (!accessKeyOptions) return undefined\n            return await WebCryptoP256.createKeyPair()\n          })()\n\n          return { credential, keyPair }\n        }\n\n        // If we are not selecting an account, we will check if an active credential is present in\n        // storage and if so, we will use it to instantiate an account.\n        if (!capabilities.selectAccount) {\n          const credential = (await config.storage?.getItem(\n            'webAuthn.activeCredential',\n          )) as WebAuthnP256.getCredential.ReturnValue | undefined\n\n          if (credential) {\n            // Get key pair (access key) to use for the account.\n            const keyPair = await (async () => {\n              if (!accessKeyOptions) return undefined\n              const address = Address.fromPublicKey(\n                PublicKey.fromHex(credential.publicKey),\n              )\n              return await idb.get(`accessKey:${address}`)\n            })()\n\n            // If the access key provisioning is not in strict mode, return the credential and key pair (if exists).\n            if (!accessKeyOptions?.strict) return { credential, keyPair }\n\n            // If a key pair is found, return the credential and key pair.\n            if (keyPair) return { credential, keyPair }\n\n            // If we are reconnecting, throw an error if not found.\n            if (parameters.isReconnecting)\n              throw new Error('credential not found.')\n\n            // Otherwise, we want to continue to sign up or register against new key pair.\n          }\n        }\n\n        // Discover credential\n        {\n          // Get key pair (access key) to use for the account.\n          const keyPair = await (async () => {\n            if (!accessKeyOptions) return undefined\n            return await WebCryptoP256.createKeyPair()\n          })()\n\n          // If we are provisioning an access key, we will need to sign a key authorization.\n          // We will need the hash (digest) to sign, and the address of the access key to construct the key authorization.\n          const { hash, keyAuthorization_unsigned } = await (async () => {\n            if (!keyPair)\n              return { accessKeyAddress: undefined, hash: undefined }\n            const accessKeyAddress = Address.fromPublicKey(keyPair.publicKey)\n            const keyAuthorization_unsigned = KeyAuthorization.from({\n              ...accessKeyOptions,\n              address: accessKeyAddress,\n              type: 'p256',\n            })\n            const hash = KeyAuthorization.getSignPayload(\n              keyAuthorization_unsigned,\n            )\n            return { keyAuthorization_unsigned, hash }\n          })()\n\n          // If no active credential, we will attempt to load the last active credential from storage.\n          const lastActiveCredential = !capabilities.selectAccount\n            ? await config.storage?.getItem('webAuthn.lastActiveCredential')\n            : undefined\n          const credential = await WebAuthnP256.getCredential({\n            ...(options.getOptions ?? {}),\n            credentialId: lastActiveCredential?.id,\n            async getPublicKey(credential) {\n              const publicKey = await options.keyManager.getPublicKey({\n                credential,\n              })\n              if (!publicKey) throw new Error('publicKey not found.')\n              return publicKey\n            },\n            hash,\n            rpId: options.getOptions?.rpId ?? options.rpId,\n          })\n\n          const keyAuthorization = keyAuthorization_unsigned\n            ? KeyAuthorization.from({\n                ...keyAuthorization_unsigned,\n                signature: SignatureEnvelope.from({\n                  metadata: credential.metadata,\n                  signature: credential.signature,\n                  publicKey: PublicKey.fromHex(credential.publicKey),\n                  type: 'webAuthn',\n                }),\n              })\n            : undefined\n\n          return { credential, keyAuthorization, keyPair }\n        }\n      })()\n\n      config.storage?.setItem(\n        'webAuthn.lastActiveCredential',\n        normalizeValue(credential),\n      )\n      config.storage?.setItem(\n        'webAuthn.activeCredential',\n        normalizeValue(credential),\n      )\n\n      account = Account.fromWebAuthnP256(credential)\n\n      if (keyPair) {\n        accessKey = Account.fromWebCryptoP256(keyPair, {\n          access: account,\n        })\n\n        // If we are reconnecting, check if the access key is expired.\n        if (parameters.isReconnecting) {\n          if (\n            'keyAuthorization' in keyPair &&\n            keyPair.keyAuthorization.expiry &&\n            keyPair.keyAuthorization.expiry < Date.now() / 1000\n          ) {\n            // remove any pending key authorizations from storage.\n            await config?.storage?.removeItem(\n              `pendingKeyAuthorization:${account.address.toLowerCase()}`,\n            )\n\n            const message = `Access key expired (on ${new Date(keyPair.keyAuthorization.expiry * 1000).toLocaleString()}).`\n            accessKey = undefined\n\n            // if in strict mode, disconnect and throw an error.\n            if (accessKeyOptions?.strict) {\n              await this.disconnect()\n              throw new Error(message)\n            }\n            // otherwise, fall back to the root account.\n            console.warn(`${message} Falling back to passkey.`)\n          }\n        }\n        // If we are not reconnecting, orchestrate the provisioning of the access key.\n        else {\n          const keyAuth =\n            keyAuthorization ??\n            (await account.signKeyAuthorization(accessKey, accessKeyOptions))\n\n          await config?.storage?.setItem(\n            `pendingKeyAuthorization:${account.address.toLowerCase()}`,\n            keyAuth,\n          )\n          await idb.set(`accessKey:${account.address.toLowerCase()}`, {\n            ...keyPair,\n            keyAuthorization: keyAuth,\n          })\n        }\n        // If we are granting an access key and it is in strict mode, throw an error if the access key is not provisioned.\n      } else if (accessKeyOptions?.strict) {\n        await config.storage?.removeItem('webAuthn.activeCredential')\n        throw new Error('access key not found')\n      }\n\n      const address = getAddress(account.address)\n\n      const chainId = parameters.chainId ?? config.chains[0]?.id\n      if (!chainId) throw new ChainNotConfiguredError()\n\n      return {\n        accounts: (parameters.withCapabilities\n          ? [{ address }]\n          : [address]) as never,\n        chainId,\n      }\n    },\n    async disconnect() {\n      await config.storage?.removeItem('webAuthn.activeCredential')\n      config.emitter.emit('disconnect')\n      account = undefined\n    },\n    async getAccounts() {\n      if (!account) return []\n      return [getAddress(account.address)]\n    },\n    async getChainId() {\n      return config.chains[0]?.id!\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch (error) {\n        console.error(\n          'Connector.webAuthn: Failed to check authorization',\n          error,\n        )\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n      return chain\n    },\n    onAccountsChanged() {},\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect() {\n      config.emitter.emit('disconnect')\n      account = undefined\n    },\n    async getClient({ chainId } = {}) {\n      const chain =\n        config.chains.find((x) => x.id === chainId) ?? config.chains[0]\n      if (!chain) throw new ChainNotConfiguredError()\n\n      const transports = config.transports\n      if (!transports) throw new ChainNotConfiguredError()\n\n      const transport = transports[chain.id]\n      if (!transport) throw new ChainNotConfiguredError()\n\n      const targetAccount = await (async () => {\n        if (!accessKey) return account\n\n        const item = await idb.get(\n          `accessKey:${accessKey.address.toLowerCase()}`,\n        )\n        if (\n          item?.keyAuthorization.expiry &&\n          item.keyAuthorization.expiry < Date.now() / 1000\n        ) {\n          // remove any pending key authorizations from storage.\n          await config?.storage?.removeItem(\n            `pendingKeyAuthorization:${accessKey.address.toLowerCase()}`,\n          )\n\n          const message = `Access key expired (on ${new Date(item.keyAuthorization.expiry * 1000).toLocaleString()}).`\n\n          // if in strict mode, disconnect and throw an error.\n          if (accessKeyOptions?.strict) {\n            await this.disconnect()\n            throw new Error(message)\n          }\n\n          // otherwise, fall back to the root account.\n          console.warn(`${message} Falling back to passkey.`)\n          return account\n        }\n        return accessKey\n      })()\n      if (!targetAccount) throw new Error('account not found.')\n\n      const targetChain = defineChain({\n        ...chain,\n        async prepareTransactionRequest(args, { phase }) {\n          const keyAuthorization = await (async () => {\n            {\n              const keyAuthorization = (\n                args as {\n                  keyAuthorization?:\n                    | KeyAuthorization.KeyAuthorization\n                    | undefined\n                }\n              ).keyAuthorization\n              if (keyAuthorization) return keyAuthorization\n            }\n\n            const keyAuthorization = await config.storage?.getItem(\n              `pendingKeyAuthorization:${targetAccount?.address.toLowerCase()}`,\n            )\n            await config.storage?.removeItem(\n              `pendingKeyAuthorization:${targetAccount?.address.toLowerCase()}`,\n            )\n            return keyAuthorization\n          })()\n\n          const [prepareTransactionRequestFn, options] = (() => {\n            if (!chain.prepareTransactionRequest) return [undefined, undefined]\n            if (typeof chain.prepareTransactionRequest === 'function')\n              return [chain.prepareTransactionRequest, undefined]\n            return chain.prepareTransactionRequest\n          })()\n\n          const request = await (async () => {\n            if (!prepareTransactionRequestFn) return {}\n            if (!options || options?.runAt?.includes(phase))\n              return await prepareTransactionRequestFn(args, { phase })\n            return {}\n          })()\n\n          return {\n            ...args,\n            ...request,\n            keyAuthorization,\n          }\n        },\n      })\n\n      return createClient({\n        account: targetAccount,\n        chain: targetChain,\n        transport: walletNamespaceCompat(transport, {\n          account: targetAccount,\n        }),\n      })\n    },\n    async getProvider({ chainId } = {}) {\n      const { request } = await this.getClient!({ chainId })\n      return { request }\n    },\n  }))\n}\n\nexport namespace webAuthn {\n  export type Parameters = {\n    /** Options for WebAuthn registration. */\n    createOptions?:\n      | Pick<\n          WebAuthnP256.createCredential.Parameters,\n          'createFn' | 'label' | 'rpId' | 'userId' | 'timeout'\n        >\n      | undefined\n    /** Options for WebAuthn authentication. */\n    getOptions?:\n      | Pick<WebAuthnP256.getCredential.Parameters, 'getFn' | 'rpId'>\n      | undefined\n    /**\n     * Whether or not to grant an access key upon connection, and optionally, expiry + limits to assign to the key.\n     */\n    grantAccessKey?:\n      | boolean\n      | (Pick<KeyAuthorization.KeyAuthorization, 'expiry' | 'limits'> & {\n          /** Whether or not to throw an error and disconnect if the access key is not provisioned or is expired. */\n          strict?: boolean | undefined\n        })\n    /** Public key manager. */\n    keyManager: KeyManager.KeyManager\n    /** The RP ID to use for WebAuthn. */\n    rpId?: string | undefined\n  }\n}\n\n/**\n * Normalizes a value into a structured-clone compatible format.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone\n */\nfunction normalizeValue<type>(value: type): type {\n  if (Array.isArray(value)) return value.map(normalizeValue) as never\n  if (typeof value === 'function') return undefined as never\n  if (typeof value !== 'object' || value === null) return value\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    try {\n      return structuredClone(value)\n    } catch {\n      return undefined as never\n    }\n\n  const normalized: Record<string, unknown> = {}\n  for (const [k, v] of Object.entries(value)) normalized[k] = normalizeValue(v)\n  return normalized as never\n}\n", "export * as amm from './amm.js'\nexport * as dex from './dex.js'\nexport * as faucet from './faucet.js'\nexport * as fee from './fee.js'\nexport * as nonce from './nonce.js'\nexport * as policy from './policy.js'\nexport * as reward from './reward.js'\nexport * as token from './token.js'\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useEffect } from 'react'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport {\n  type UseMutationParameters,\n  type UseQueryReturnType,\n  useMutation,\n  useQuery,\n} from 'wagmi/query'\n\nimport type { ExactPartial, UnionCompute } from '../../internal/types.js'\nimport * as Actions from '../Actions/amm.js'\n\n/**\n * Hook for getting the reserves for a liquidity pool.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.amm.usePool({\n *     userToken: '0x...',\n *     validatorToken: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return (\n *     <div>\n *       User Token Reserve: {data?.reserveUserToken.toString()}\n *       Validator Token Reserve: {data?.reserveValidatorToken.toString()}\n *     </div>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the pool reserves.\n */\nexport function usePool<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getPool.ReturnValue,\n>(parameters: usePool.Parameters<config, selectData>) {\n  const { userToken, validatorToken, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getPool.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(\n    userToken !== undefined &&\n      validatorToken !== undefined &&\n      (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace usePool {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getPool.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getPool.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getPool.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<Actions.getPool.queryOptions.Parameters<config, selectData>, 'query'>\n    >\n\n  export type ReturnValue<selectData = Actions.getPool.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting the LP token balance for an account in a specific pool.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data: poolId } = Hooks.amm.usePoolId({\n *     userToken: '0x...',\n *     validatorToken: '0x...',\n *   })\n *\n *   const { data, isLoading } = Hooks.amm.useLiquidityBalance({\n *     poolId,\n *     address: '0x20c...0055',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>LP Balance: {data?.toString()}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the LP token balance.\n */\nexport function useLiquidityBalance<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getLiquidityBalance.ReturnValue,\n>(parameters: useLiquidityBalance.Parameters<config, selectData> = {}) {\n  const { address, poolId, userToken, validatorToken, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getLiquidityBalance.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(\n    address &&\n      (poolId || (userToken !== undefined && validatorToken !== undefined)) &&\n      (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useLiquidityBalance {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getLiquidityBalance.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getLiquidityBalance.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getLiquidityBalance.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getLiquidityBalance.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<\n    selectData = Actions.getLiquidityBalance.ReturnValue,\n  > = UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for performing a rebalance swap from validator token to user token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.amm.useRebalanceSwap()\n *\n *   return (\n *     <button\n *       onClick={() =>\n *         mutate({\n *           userToken: '0x...',\n *           validatorToken: '0x...',\n *           amountOut: 100n,\n *           to: '0x...',\n *         })\n *       }\n *       disabled={isPending}\n *     >\n *       Rebalance Swap\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useRebalanceSwap<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRebalanceSwap.Parameters<config, context> = {},\n): useRebalanceSwap.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.rebalanceSwap(config, variables as never)\n    },\n    mutationKey: ['rebalanceSwap'],\n  }) as never\n}\n\nexport declare namespace useRebalanceSwap {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.rebalanceSwap.ReturnValue,\n          DefaultError,\n          Actions.rebalanceSwap.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.rebalanceSwap.ReturnValue,\n    DefaultError,\n    Actions.rebalanceSwap.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for performing a rebalance swap from validator token to user token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.amm.useRebalanceSwapSync()\n *\n *   return (\n *     <button\n *       onClick={() =>\n *         mutate({\n *           userToken: '0x...',\n *           validatorToken: '0x...',\n *           amountOut: 100n,\n *           to: '0x...',\n *         })\n *       }\n *       disabled={isPending}\n *     >\n *       Rebalance Swap\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useRebalanceSwapSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRebalanceSwapSync.Parameters<config, context> = {},\n): useRebalanceSwapSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.rebalanceSwapSync(config, variables as never)\n    },\n    mutationKey: ['rebalanceSwapSync'],\n  }) as never\n}\n\nexport declare namespace useRebalanceSwapSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.rebalanceSwapSync.ReturnValue,\n          DefaultError,\n          Actions.rebalanceSwapSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.rebalanceSwapSync.ReturnValue,\n    DefaultError,\n    Actions.rebalanceSwapSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for adding liquidity to a pool.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.amm.useMint()\n *\n *   return (\n *     <button\n *       onClick={() =>\n *         mutate({\n *           userTokenAddress: '0x20c0...beef',\n *           validatorTokenAddress: '0x20c0...babe',\n *           validatorTokenAmount: 100n,\n *           to: '0xfeed...fede',\n *         })\n *       }\n *       disabled={isPending}\n *     >\n *       Add Liquidity\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useMint<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useMint.Parameters<config, context> = {},\n): useMint.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.mint(config, variables as never)\n    },\n    mutationKey: ['mint'],\n  }) as never\n}\n\nexport declare namespace useMint {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.mint.ReturnValue,\n          DefaultError,\n          Actions.mint.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.mint.ReturnValue,\n    DefaultError,\n    Actions.mint.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for adding liquidity to a pool.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.amm.useMintSync()\n *\n *   return (\n *     <button\n *       onClick={() =>\n *         mutate({\n *           userTokenAddress: '0x20c0...beef',\n *           validatorTokenAddress: '0x20c0...babe',\n *           validatorTokenAmount: 100n,\n *           to: '0xfeed...fede',\n *         })\n *       }\n *       disabled={isPending}\n *     >\n *       Add Liquidity\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useMintSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useMintSync.Parameters<config, context> = {},\n): useMintSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.mintSync(config, variables as never)\n    },\n    mutationKey: ['mintSync'],\n  }) as never\n}\n\nexport declare namespace useMintSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.mintSync.ReturnValue,\n          DefaultError,\n          Actions.mintSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.mintSync.ReturnValue,\n    DefaultError,\n    Actions.mintSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for removing liquidity from a pool.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.amm.useBurn()\n *\n *   return (\n *     <button\n *       onClick={() =>\n *         mutate({\n *           userToken: '0x20c0...beef',\n *           validatorToken: '0x20c0...babe',\n *           liquidity: 50n,\n *           to: '0xfeed...fede',\n *         })\n *       }\n *       disabled={isPending}\n *     >\n *       Remove Liquidity\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBurn<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBurn.Parameters<config, context> = {},\n): useBurn.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.burn(config, variables as never)\n    },\n    mutationKey: ['burn'],\n  }) as never\n}\n\nexport declare namespace useBurn {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.burn.ReturnValue,\n          DefaultError,\n          Actions.burn.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.burn.ReturnValue,\n    DefaultError,\n    Actions.burn.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for removing liquidity from a pool.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.amm.useBurnSync()\n *\n *   return (\n *     <button\n *       onClick={() =>\n *         mutate({\n *           userToken: '0x20c0...beef',\n *           validatorToken: '0x20c0...babe',\n *           liquidity: 50n,\n *           to: '0xfeed...fede',\n *         })\n *       }\n *       disabled={isPending}\n *     >\n *       Remove Liquidity\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBurnSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBurnSync.Parameters<config, context> = {},\n): useBurnSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.burnSync(config, variables as never)\n    },\n    mutationKey: ['burnSync'],\n  }) as never\n}\n\nexport declare namespace useBurnSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.burnSync.ReturnValue,\n          DefaultError,\n          Actions.burnSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.burnSync.ReturnValue,\n    DefaultError,\n    Actions.burnSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for watching rebalance swap events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.amm.useWatchRebalanceSwap({\n *     onRebalanceSwap(args) {\n *       console.log('Rebalance swap:', args)\n *     },\n *   })\n *\n *   return <div>Watching for rebalance swaps...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchRebalanceSwap<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchRebalanceSwap.Parameters<config> = {}) {\n  const { enabled = true, onRebalanceSwap, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onRebalanceSwap) return\n    return Actions.watchRebalanceSwap(config, {\n      ...rest,\n      chainId,\n      onRebalanceSwap,\n    })\n  }, [config, enabled, onRebalanceSwap, rest, chainId])\n}\n\nexport declare namespace useWatchRebalanceSwap {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchRebalanceSwap.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching fee swap events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.amm.useWatchFeeSwap({\n *     onFeeSwap(args) {\n *       console.log('Fee swap:', args)\n *     },\n *   })\n *\n *   return <div>Watching for fee swaps...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchFeeSwap<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchFeeSwap.Parameters<config> = {}) {\n  const { enabled = true, onFeeSwap, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onFeeSwap) return\n    return Actions.watchFeeSwap(config, {\n      ...rest,\n      chainId,\n      onFeeSwap,\n    })\n  }, [config, enabled, onFeeSwap, rest, chainId])\n}\n\nexport declare namespace useWatchFeeSwap {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchFeeSwap.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching liquidity mint events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.amm.useWatchMint({\n *     onMint(args) {\n *       console.log('Liquidity added:', args)\n *     },\n *   })\n *\n *   return <div>Watching for liquidity additions...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchMint<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchMint.Parameters<config> = {}) {\n  const { enabled = true, onMint, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onMint) return\n    return Actions.watchMint(config, {\n      ...rest,\n      chainId,\n      onMint,\n    })\n  }, [config, enabled, onMint, rest, chainId])\n}\n\nexport declare namespace useWatchMint {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchMint.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching liquidity burn events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.amm.useWatchBurn({\n *     onBurn(args) {\n *       console.log('Liquidity removed:', args)\n *     },\n *   })\n *\n *   return <div>Watching for liquidity removals...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchBurn<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchBurn.Parameters<config> = {}) {\n  const { enabled = true, onBurn, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onBurn) return\n    return Actions.watchBurn(config, {\n      ...rest,\n      chainId,\n      onBurn,\n    })\n  }, [config, enabled, onBurn, rest, chainId])\n}\n\nexport declare namespace useWatchBurn {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchBurn.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useEffect } from 'react'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport {\n  type UseMutationParameters,\n  type UseQueryReturnType,\n  useMutation,\n  useQuery,\n} from 'wagmi/query'\nimport type { ExactPartial, UnionCompute } from '../../internal/types.js'\n\nimport {\n  buy,\n  buySync,\n  cancel,\n  cancelSync,\n  createPair,\n  createPairSync,\n  getBalance,\n  getBuyQuote,\n  getOrder,\n  getOrderbook,\n  getSellQuote,\n  getTickLevel,\n  place,\n  placeFlip,\n  placeFlipSync,\n  placeSync,\n  sell,\n  sellSync,\n  watchFlipOrderPlaced,\n  watchOrderCancelled,\n  watchOrderFilled,\n  watchOrderPlaced,\n  withdraw,\n  withdrawSync,\n} from '../Actions/dex.js'\n\n/**\n * Hook for buying a specific amount of tokens.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useBuy()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         tokenIn: '0x20c...11',\n *         tokenOut: '0x20c...20',\n *         amountOut: parseUnits('100', 6),\n *         maxAmountIn: parseUnits('105', 6),\n *       })}\n *       disabled={isPending}\n *     >\n *       Buy Tokens\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBuy<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBuy.Parameters<config, context> = {},\n): useBuy.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return buy(config, variables as never)\n    },\n    mutationKey: ['buy'],\n  }) as never\n}\n\nexport declare namespace useBuy {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          buy.ReturnValue,\n          buy.ErrorType,\n          buy.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    buy.ReturnValue,\n    buy.ErrorType,\n    buy.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for buying a specific amount of tokens.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useBuySync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         tokenIn: '0x20c...11',\n *         tokenOut: '0x20c...20',\n *         amountOut: parseUnits('100', 6),\n *         maxAmountIn: parseUnits('105', 6),\n *       })}\n *       disabled={isPending}\n *     >\n *       Buy Tokens\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBuySync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBuySync.Parameters<config, context> = {},\n): useBuySync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return buySync(config, variables as never)\n    },\n    mutationKey: ['buySync'],\n  }) as never\n}\n\nexport declare namespace useBuySync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          buySync.ReturnValue,\n          buySync.ErrorType,\n          buySync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    buySync.ReturnValue,\n    buySync.ErrorType,\n    buySync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for canceling an order from the orderbook.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useCancel()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ orderId: 123n })}\n *       disabled={isPending}\n *     >\n *       Cancel Order\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCancel<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCancel.Parameters<config, context> = {},\n): useCancel.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return cancel(config, variables as never)\n    },\n    mutationKey: ['cancel'],\n  }) as never\n}\n\nexport declare namespace useCancel {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          cancel.ReturnValue,\n          cancel.ErrorType,\n          cancel.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    cancel.ReturnValue,\n    cancel.ErrorType,\n    cancel.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for canceling an order from the orderbook.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useCancelSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ orderId: 123n })}\n *       disabled={isPending}\n *     >\n *       Cancel Order\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCancelSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCancelSync.Parameters<config, context> = {},\n): useCancelSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return cancelSync(config, variables as never)\n    },\n    mutationKey: ['cancelSync'],\n  }) as never\n}\n\nexport declare namespace useCancelSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          cancelSync.ReturnValue,\n          cancelSync.ErrorType,\n          cancelSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    cancelSync.ReturnValue,\n    cancelSync.ErrorType,\n    cancelSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for creating a new trading pair on the DEX.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useCreatePair()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ base: '0x20c...11' })}\n *       disabled={isPending}\n *     >\n *       Create Pair\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCreatePair<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCreatePair.Parameters<config, context> = {},\n): useCreatePair.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return createPair(config, variables as never)\n    },\n    mutationKey: ['createPair'],\n  }) as never\n}\n\nexport declare namespace useCreatePair {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          createPair.ReturnValue,\n          createPair.ErrorType,\n          createPair.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    createPair.ReturnValue,\n    createPair.ErrorType,\n    createPair.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for creating a new trading pair on the DEX.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useCreatePairSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ base: '0x20c...11' })}\n *       disabled={isPending}\n *     >\n *       Create Pair\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCreatePairSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCreatePairSync.Parameters<config, context> = {},\n): useCreatePairSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return createPairSync(config, variables as never)\n    },\n    mutationKey: ['createPairSync'],\n  }) as never\n}\n\nexport declare namespace useCreatePairSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          createPairSync.ReturnValue,\n          createPairSync.ErrorType,\n          createPairSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    createPairSync.ReturnValue,\n    createPairSync.ErrorType,\n    createPairSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for getting a user's token balance on the DEX.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.dex.useBalance({\n *     account: '0x...',\n *     token: '0x20c...11',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Balance: {data}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the user's token balance on the DEX.\n */\nexport function useBalance<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getBalance.ReturnValue,\n>(parameters: useBalance.Parameters<config, selectData>) {\n  const { account, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getBalance.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(account && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useBalance {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getBalance.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getBalance.ReturnValue,\n      DefaultError,\n      selectData,\n      getBalance.QueryKey<config>\n    > &\n    Omit<getBalance.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getBalance.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting the quote for buying a specific amount of tokens.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.dex.useBuyQuote({\n *     amountOut: parseUnits('100', 6),\n *     tokenIn: '0x20c...11',\n *     tokenOut: '0x20c...20',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Required Input: {data}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the amount of tokenIn needed.\n */\nexport function useBuyQuote<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getBuyQuote.ReturnValue,\n>(parameters: useBuyQuote.Parameters<config, selectData>) {\n  const { query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getBuyQuote.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(\n    parameters.tokenIn &&\n      parameters.tokenOut &&\n      parameters.amountOut &&\n      (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useBuyQuote {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getBuyQuote.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getBuyQuote.ReturnValue,\n      DefaultError,\n      selectData,\n      getBuyQuote.QueryKey<config>\n    > &\n    Omit<getBuyQuote.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getBuyQuote.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting an order's details from the orderbook.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.dex.useOrder({\n *     orderId: 123n,\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Order: {JSON.stringify(data)}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the order details.\n */\nexport function useOrder<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getOrder.ReturnValue,\n>(parameters: useOrder.Parameters<config, selectData>) {\n  const { query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getOrder.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(\n    parameters.orderId !== undefined && (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useOrder {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getOrder.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getOrder.ReturnValue,\n      DefaultError,\n      selectData,\n      getOrder.QueryKey<config>\n    > &\n    Omit<getOrder.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getOrder.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting orderbook information for a trading pair.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.dex.useOrderbook({\n *     base: '0x20c...11',\n *     quote: '0x20c...20',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Orderbook: {JSON.stringify(data)}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the orderbook information.\n */\nexport function useOrderbook<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getOrderbook.ReturnValue,\n>(parameters: useOrderbook.Parameters<config, selectData>) {\n  const { query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getOrderbook.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(\n    parameters.base && parameters.quote && (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useOrderbook {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getOrderbook.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getOrderbook.ReturnValue,\n      DefaultError,\n      selectData,\n      getOrderbook.QueryKey<config>\n    > &\n    Omit<getOrderbook.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getOrderbook.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting the price level information at a specific tick.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.dex.usePriceLevel({\n *     base: '0x20c...11',\n *     tick: Tick.fromPrice('1.001'),\n *     isBid: true,\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Price Level: {JSON.stringify(data)}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the price level information.\n */\nexport function usePriceLevel<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getTickLevel.ReturnValue,\n>(parameters: usePriceLevel.Parameters<config, selectData>) {\n  const { query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getTickLevel.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(\n    parameters.base &&\n      parameters.tick !== undefined &&\n      parameters.isBid !== undefined &&\n      (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace usePriceLevel {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getTickLevel.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getTickLevel.ReturnValue,\n      DefaultError,\n      selectData,\n      getTickLevel.QueryKey<config>\n    > &\n    Omit<getTickLevel.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getTickLevel.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting the quote for selling a specific amount of tokens.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.dex.useSellQuote({\n *     amountIn: parseUnits('100', 6),\n *     tokenIn: '0x20c...11',\n *     tokenOut: '0x20c...20',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Expected Output: {data}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with the amount of tokenOut received.\n */\nexport function useSellQuote<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getSellQuote.ReturnValue,\n>(parameters: useSellQuote.Parameters<config, selectData>) {\n  const { query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getSellQuote.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(\n    parameters.tokenIn &&\n      parameters.tokenOut &&\n      parameters.amountIn &&\n      (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useSellQuote {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getSellQuote.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getSellQuote.ReturnValue,\n      DefaultError,\n      selectData,\n      getSellQuote.QueryKey<config>\n    > &\n    Omit<getSellQuote.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getSellQuote.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for placing a limit order on the orderbook.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.usePlace()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amount: parseUnits('100', 6),\n *         tick: Tick.fromPrice('0.99'),\n *         token: '0x20c...11',\n *         type: 'buy',\n *       })}\n *       disabled={isPending}\n *     >\n *       Place Order\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePlace<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePlace.Parameters<config, context> = {},\n): usePlace.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return place(config, variables as never)\n    },\n    mutationKey: ['place'],\n  }) as never\n}\n\nexport declare namespace usePlace {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          place.ReturnValue,\n          place.ErrorType,\n          place.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    place.ReturnValue,\n    place.ErrorType,\n    place.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for placing a flip order that automatically flips when filled.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.usePlaceFlip()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amount: parseUnits('100', 6),\n *         flipTick: Tick.fromPrice('1.01'),\n *         tick: Tick.fromPrice('0.99'),\n *         token: '0x20c...11',\n *         type: 'buy',\n *       })}\n *       disabled={isPending}\n *     >\n *       Place Flip Order\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePlaceFlip<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePlaceFlip.Parameters<config, context> = {},\n): usePlaceFlip.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return placeFlip(config, variables as never)\n    },\n    mutationKey: ['placeFlip'],\n  }) as never\n}\n\nexport declare namespace usePlaceFlip {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          placeFlip.ReturnValue,\n          placeFlip.ErrorType,\n          placeFlip.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    placeFlip.ReturnValue,\n    placeFlip.ErrorType,\n    placeFlip.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for placing a flip order that automatically flips when filled.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.usePlaceFlipSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amount: parseUnits('100', 6),\n *         flipTick: Tick.fromPrice('1.01'),\n *         tick: Tick.fromPrice('0.99'),\n *         token: '0x20c...11',\n *         type: 'buy',\n *       })}\n *       disabled={isPending}\n *     >\n *       Place Flip Order\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePlaceFlipSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePlaceFlipSync.Parameters<config, context> = {},\n): usePlaceFlipSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return placeFlipSync(config, variables as never)\n    },\n    mutationKey: ['placeFlipSync'],\n  }) as never\n}\n\nexport declare namespace usePlaceFlipSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          placeFlipSync.ReturnValue,\n          placeFlipSync.ErrorType,\n          placeFlipSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    placeFlipSync.ReturnValue,\n    placeFlipSync.ErrorType,\n    placeFlipSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for placing a limit order on the orderbook.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.usePlaceSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amount: parseUnits('100', 6),\n *         tick: Tick.fromPrice('0.99'),\n *         token: '0x20c...11',\n *         type: 'buy',\n *       })}\n *       disabled={isPending}\n *     >\n *       Place Order\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePlaceSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePlaceSync.Parameters<config, context> = {},\n): usePlaceSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return placeSync(config, variables as never)\n    },\n    mutationKey: ['placeSync'],\n  }) as never\n}\n\nexport declare namespace usePlaceSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          placeSync.ReturnValue,\n          placeSync.ErrorType,\n          placeSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    placeSync.ReturnValue,\n    placeSync.ErrorType,\n    placeSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for selling a specific amount of tokens.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useSell()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amountIn: parseUnits('100', 6),\n *         minAmountOut: parseUnits('95', 6),\n *         tokenIn: '0x20c...11',\n *         tokenOut: '0x20c...20',\n *       })}\n *       disabled={isPending}\n *     >\n *       Sell Tokens\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSell<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSell.Parameters<config, context> = {},\n): useSell.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return sell(config, variables as never)\n    },\n    mutationKey: ['sell'],\n  }) as never\n}\n\nexport declare namespace useSell {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          sell.ReturnValue,\n          sell.ErrorType,\n          sell.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    sell.ReturnValue,\n    sell.ErrorType,\n    sell.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for selling a specific amount of tokens.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useSellSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amountIn: parseUnits('100', 6),\n *         minAmountOut: parseUnits('95', 6),\n *         tokenIn: '0x20c...11',\n *         tokenOut: '0x20c...20',\n *       })}\n *       disabled={isPending}\n *     >\n *       Sell Tokens\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSellSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSellSync.Parameters<config, context> = {},\n): useSellSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return sellSync(config, variables as never)\n    },\n    mutationKey: ['sellSync'],\n  }) as never\n}\n\nexport declare namespace useSellSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          sellSync.ReturnValue,\n          sellSync.ErrorType,\n          sellSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    sellSync.ReturnValue,\n    sellSync.ErrorType,\n    sellSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for withdrawing tokens from the DEX to the caller's wallet.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useWithdraw()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amount: 100n,\n *         token: '0x20c...11',\n *       })}\n *       disabled={isPending}\n *     >\n *       Withdraw\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useWithdraw<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useWithdraw.Parameters<config, context> = {},\n): useWithdraw.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return withdraw(config, variables as never)\n    },\n    mutationKey: ['withdraw'],\n  }) as never\n}\n\nexport declare namespace useWithdraw {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          withdraw.ReturnValue,\n          withdraw.ErrorType,\n          withdraw.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    withdraw.ReturnValue,\n    withdraw.ErrorType,\n    withdraw.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for withdrawing tokens from the DEX to the caller's wallet.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.dex.useWithdrawSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({\n *         amount: 100n,\n *         token: '0x20c...11',\n *       })}\n *       disabled={isPending}\n *     >\n *       Withdraw\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useWithdrawSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useWithdrawSync.Parameters<config, context> = {},\n): useWithdrawSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return withdrawSync(config, variables as never)\n    },\n    mutationKey: ['withdrawSync'],\n  }) as never\n}\n\nexport declare namespace useWithdrawSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          withdrawSync.ReturnValue,\n          withdrawSync.ErrorType,\n          withdrawSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    withdrawSync.ReturnValue,\n    withdrawSync.ErrorType,\n    withdrawSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for watching flip order placement events on the DEX.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.dex.useWatchFlipOrderPlaced({\n *     onFlipOrderPlaced(args) {\n *       console.log('Flip order placed:', args)\n *     },\n *   })\n *\n *   return <div>Watching for flip order placements...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchFlipOrderPlaced<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchFlipOrderPlaced.Parameters<config> = {}) {\n  const { enabled = true, onFlipOrderPlaced, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onFlipOrderPlaced) return\n    return watchFlipOrderPlaced(config, {\n      ...rest,\n      chainId,\n      onFlipOrderPlaced,\n    })\n  }, [config, enabled, onFlipOrderPlaced, rest, chainId])\n}\n\nexport declare namespace useWatchFlipOrderPlaced {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<watchFlipOrderPlaced.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching order cancellation events on the DEX.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.dex.useWatchOrderCancelled({\n *     onOrderCancelled(args) {\n *       console.log('Order cancelled:', args)\n *     },\n *   })\n *\n *   return <div>Watching for order cancellations...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchOrderCancelled<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchOrderCancelled.Parameters<config> = {}) {\n  const { enabled = true, onOrderCancelled, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onOrderCancelled) return\n    return watchOrderCancelled(config, {\n      ...rest,\n      chainId,\n      onOrderCancelled,\n    })\n  }, [config, enabled, onOrderCancelled, rest, chainId])\n}\n\nexport declare namespace useWatchOrderCancelled {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<watchOrderCancelled.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching order filled events on the DEX.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.dex.useWatchOrderFilled({\n *     onOrderFilled(args) {\n *       console.log('Order filled:', args)\n *     },\n *   })\n *\n *   return <div>Watching for order fills...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchOrderFilled<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchOrderFilled.Parameters<config> = {}) {\n  const { enabled = true, onOrderFilled, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onOrderFilled) return\n    return watchOrderFilled(config, {\n      ...rest,\n      chainId,\n      onOrderFilled,\n    })\n  }, [config, enabled, onOrderFilled, rest, chainId])\n}\n\nexport declare namespace useWatchOrderFilled {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<watchOrderFilled.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching order placement events on the DEX.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.dex.useWatchOrderPlaced({\n *     onOrderPlaced(args) {\n *       console.log('Order placed:', args)\n *     },\n *   })\n *\n *   return <div>Watching for order placements...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchOrderPlaced<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchOrderPlaced.Parameters<config> = {}) {\n  const { enabled = true, onOrderPlaced, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onOrderPlaced) return\n    return watchOrderPlaced(config, {\n      ...rest,\n      chainId,\n      onOrderPlaced,\n    })\n  }, [config, enabled, onOrderPlaced, rest, chainId])\n}\n\nexport declare namespace useWatchOrderPlaced {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<watchOrderPlaced.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n", "import type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport type { BaseErrorType } from 'viem'\nimport { useConfig } from 'wagmi'\nimport type { ConfigParameter } from 'wagmi/internal'\nimport { type UseMutationParameters, useMutation } from 'wagmi/query'\n\nimport { fund, fundSync } from '../Actions/faucet.js'\n\n/**\n * Hook for funding an account with an initial amount of set token(s)\n * on Tempo's testnet.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.faucet.useFund()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ account: '0xdeadbeef...' })}\n *       disabled={isPending}\n *     >\n *       Fund Account\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useFund<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useFund.Parameters<config, context> = {},\n): useFund.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return fund(config, variables)\n    },\n    mutationKey: ['fund'],\n  })\n}\n\nexport declare namespace useFund {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          fund.ReturnValue,\n          BaseErrorType,\n          fund.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    fund.ReturnValue,\n    BaseErrorType,\n    fund.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for funding an account with an initial amount of set token(s)\n * on Tempo's testnet. Returns the transaction receipts.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.faucet.useFundSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ account: '0xdeadbeef...' })}\n *       disabled={isPending}\n *     >\n *       Fund Account\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useFundSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useFundSync.Parameters<config, context> = {},\n): useFundSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return fundSync(config, variables)\n    },\n    mutationKey: ['fundSync'],\n  })\n}\n\nexport declare namespace useFundSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          fundSync.ReturnValue,\n          BaseErrorType,\n          fundSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    fundSync.ReturnValue,\n    BaseErrorType,\n    fundSync.Parameters<config>,\n    context\n  >\n}\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport {\n  type UseMutationParameters,\n  type UseQueryReturnType,\n  useMutation,\n  useQuery,\n} from 'wagmi/query'\n\nimport { getUserToken, setUserToken, setUserTokenSync } from '../Actions/fee.js'\n\n/**\n * Hook for getting the user's default fee token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.fee.useUserToken({\n *     account: '0x20c...0055',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Token: {data?.address}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with token address and ID.\n */\nexport function useUserToken<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getUserToken.ReturnValue,\n>(parameters: useUserToken.Parameters<config, selectData>) {\n  const { account, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getUserToken.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(account && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useUserToken {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getUserToken.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getUserToken.ReturnValue,\n      DefaultError,\n      selectData,\n      getUserToken.QueryKey<config>\n    > &\n    Omit<getUserToken.queryOptions.Parameters<config, selectData>, 'query'>\n\n  export type ReturnValue<selectData = getUserToken.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for setting the user's default fee token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.fee.useSetUserToken()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x20c...0055' })}\n *       disabled={isPending}\n *     >\n *       Set Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetUserToken<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetUserToken.Parameters<config, context> = {},\n): useSetUserToken.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return setUserToken(config, variables as never)\n    },\n    mutationKey: ['setUserTokenSync'],\n  }) as never\n}\n\nexport declare namespace useSetUserToken {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          setUserToken.ReturnValue,\n          setUserToken.ErrorType,\n          setUserToken.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    setUserToken.ReturnValue,\n    setUserToken.ErrorType,\n    setUserToken.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the user's default fee token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.fee.useSetUserTokenSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x20c...0055' })}\n *       disabled={isPending}\n *     >\n *       Set Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetUserTokenSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetUserTokenSync.Parameters<config, context> = {},\n): useSetUserTokenSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return setUserTokenSync(config, variables as never)\n    },\n    mutationKey: ['setUserTokenSync'],\n  }) as never\n}\n\nexport declare namespace useSetUserTokenSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          setUserTokenSync.ReturnValue,\n          setUserTokenSync.ErrorType,\n          setUserTokenSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    setUserTokenSync.ReturnValue,\n    setUserTokenSync.ErrorType,\n    setUserTokenSync.Parameters<config>,\n    context\n  >\n}\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useEffect } from 'react'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport { type UseQueryReturnType, useQuery } from 'wagmi/query'\n\nimport type { ExactPartial, UnionCompute } from '../../internal/types.js'\nimport { getNonce, watchNonceIncremented } from '../Actions/nonce.js'\n\n/**\n * Hook for getting the nonce for an account and nonce key.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.nonce.useNonce({\n *     account: '0x...',\n *     nonceKey: 1n,\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Nonce: {data?.toString()}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with nonce value.\n */\nexport function useNonce<\n  config extends Config = ResolvedRegister['config'],\n  selectData = getNonce.ReturnValue,\n>(parameters: useNonce.Parameters<config, selectData> = {}) {\n  const { account, nonceKey, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = getNonce.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  })\n  const enabled = Boolean(\n    account && nonceKey !== undefined && (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useNonce {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = getNonce.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      getNonce.ReturnValue,\n      DefaultError,\n      selectData,\n      getNonce.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<getNonce.queryOptions.Parameters<config, selectData>, 'query'>\n    >\n\n  export type ReturnValue<selectData = getNonce.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for watching nonce incremented events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.nonce.useWatchNonceIncremented({\n *     onNonceIncremented(args, log) {\n *       console.log('Nonce incremented:', args)\n *     },\n *   })\n *\n *   return <div>Watching for nonce increments...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchNonceIncremented<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchNonceIncremented.Parameters<config> = {}) {\n  const { enabled = true, onNonceIncremented, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onNonceIncremented) return\n    return watchNonceIncremented(config, {\n      ...rest,\n      chainId,\n      onNonceIncremented,\n    })\n  }, [config, enabled, onNonceIncremented, chainId, rest])\n}\n\nexport declare namespace useWatchNonceIncremented {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<watchNonceIncremented.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useEffect } from 'react'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport {\n  type UseMutationParameters,\n  type UseQueryReturnType,\n  useMutation,\n  useQuery,\n} from 'wagmi/query'\n\nimport type { ExactPartial, UnionCompute } from '../../internal/types.js'\nimport * as Actions from '../Actions/policy.js'\n\n/**\n * Hook for creating a new policy.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useCreate()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ type: 'whitelist' })}\n *       disabled={isPending}\n *     >\n *       Create Policy\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCreate<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCreate.Parameters<config, context> = {},\n): useCreate.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.create(config, variables as never)\n    },\n    mutationKey: ['create'],\n  }) as never\n}\n\nexport declare namespace useCreate {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.create.ReturnValue,\n          Actions.create.ErrorType,\n          Actions.create.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.create.ReturnValue,\n    Actions.create.ErrorType,\n    Actions.create.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for creating a new policy.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useCreateSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ type: 'whitelist' })}\n *       disabled={isPending}\n *     >\n *       Create Policy\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCreateSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCreateSync.Parameters<config, context> = {},\n): useCreateSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.createSync(config, variables as never)\n    },\n    mutationKey: ['createSync'],\n  }) as never\n}\n\nexport declare namespace useCreateSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.createSync.ReturnValue,\n          Actions.createSync.ErrorType,\n          Actions.createSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.createSync.ReturnValue,\n    Actions.createSync.ErrorType,\n    Actions.createSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the admin for a policy.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useSetAdmin()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ policyId: 2n, admin: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Set Admin\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetAdmin<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetAdmin.Parameters<config, context> = {},\n): useSetAdmin.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setAdmin(config, variables as never)\n    },\n    mutationKey: ['setAdmin'],\n  }) as never\n}\n\nexport declare namespace useSetAdmin {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setAdmin.ReturnValue,\n          Actions.setAdmin.ErrorType,\n          Actions.setAdmin.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setAdmin.ReturnValue,\n    Actions.setAdmin.ErrorType,\n    Actions.setAdmin.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the admin for a policy.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useSetAdminSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ policyId: 2n, admin: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Set Admin\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetAdminSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetAdminSync.Parameters<config, context> = {},\n): useSetAdminSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setAdminSync(config, variables as never)\n    },\n    mutationKey: ['setAdminSync'],\n  }) as never\n}\n\nexport declare namespace useSetAdminSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setAdminSync.ReturnValue,\n          Actions.setAdminSync.ErrorType,\n          Actions.setAdminSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setAdminSync.ReturnValue,\n    Actions.setAdminSync.ErrorType,\n    Actions.setAdminSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for modifying a policy whitelist.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useModifyWhitelist()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ policyId: 2n, address: '0x...', allowed: true })}\n *       disabled={isPending}\n *     >\n *       Add to Whitelist\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useModifyWhitelist<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useModifyWhitelist.Parameters<config, context> = {},\n): useModifyWhitelist.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.modifyWhitelist(config, variables as never)\n    },\n    mutationKey: ['modifyWhitelist'],\n  }) as never\n}\n\nexport declare namespace useModifyWhitelist {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.modifyWhitelist.ReturnValue,\n          Actions.modifyWhitelist.ErrorType,\n          Actions.modifyWhitelist.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.modifyWhitelist.ReturnValue,\n    Actions.modifyWhitelist.ErrorType,\n    Actions.modifyWhitelist.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for modifying a policy whitelist.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useModifyWhitelistSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ policyId: 2n, address: '0x...', allowed: true })}\n *       disabled={isPending}\n *     >\n *       Add to Whitelist\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useModifyWhitelistSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useModifyWhitelistSync.Parameters<config, context> = {},\n): useModifyWhitelistSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.modifyWhitelistSync(config, variables as never)\n    },\n    mutationKey: ['modifyWhitelistSync'],\n  }) as never\n}\n\nexport declare namespace useModifyWhitelistSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.modifyWhitelistSync.ReturnValue,\n          Actions.modifyWhitelistSync.ErrorType,\n          Actions.modifyWhitelistSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.modifyWhitelistSync.ReturnValue,\n    Actions.modifyWhitelistSync.ErrorType,\n    Actions.modifyWhitelistSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for modifying a policy blacklist.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useModifyBlacklist()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ policyId: 2n, address: '0x...', restricted: true })}\n *       disabled={isPending}\n *     >\n *       Add to Blacklist\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useModifyBlacklist<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useModifyBlacklist.Parameters<config, context> = {},\n): useModifyBlacklist.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.modifyBlacklist(config, variables as never)\n    },\n    mutationKey: ['modifyBlacklist'],\n  }) as never\n}\n\nexport declare namespace useModifyBlacklist {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.modifyBlacklist.ReturnValue,\n          Actions.modifyBlacklist.ErrorType,\n          Actions.modifyBlacklist.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.modifyBlacklist.ReturnValue,\n    Actions.modifyBlacklist.ErrorType,\n    Actions.modifyBlacklist.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for modifying a policy blacklist.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.policy.useModifyBlacklistSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ policyId: 2n, address: '0x...', restricted: true })}\n *       disabled={isPending}\n *     >\n *       Add to Blacklist\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useModifyBlacklistSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useModifyBlacklistSync.Parameters<config, context> = {},\n): useModifyBlacklistSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.modifyBlacklistSync(config, variables as never)\n    },\n    mutationKey: ['modifyBlacklistSync'],\n  }) as never\n}\n\nexport declare namespace useModifyBlacklistSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.modifyBlacklistSync.ReturnValue,\n          Actions.modifyBlacklistSync.ErrorType,\n          Actions.modifyBlacklistSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.modifyBlacklistSync.ReturnValue,\n    Actions.modifyBlacklistSync.ErrorType,\n    Actions.modifyBlacklistSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for getting policy data.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.policy.useGetData({\n *     policyId: 2n,\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Admin: {data?.admin}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with policy data.\n */\nexport function useGetData<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getData.ReturnValue,\n>(parameters: useGetData.Parameters<config, selectData> = {}) {\n  const { policyId, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getData.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(policyId !== undefined && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useGetData {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getData.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getData.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getData.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<Actions.getData.queryOptions.Parameters<config, selectData>, 'query'>\n    >\n\n  export type ReturnValue<selectData = Actions.getData.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for checking if a user is authorized by a policy.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.policy.useIsAuthorized({\n *     policyId: 2n,\n *     user: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Authorized: {data ? 'Yes' : 'No'}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with authorization status.\n */\nexport function useIsAuthorized<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.isAuthorized.ReturnValue,\n>(parameters: useIsAuthorized.Parameters<config, selectData> = {}) {\n  const { policyId, user, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.isAuthorized.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(\n    policyId !== undefined && user && (query.enabled ?? true),\n  )\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useIsAuthorized {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.isAuthorized.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.isAuthorized.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.isAuthorized.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.isAuthorized.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.isAuthorized.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for watching policy creation events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.policy.useWatchCreate({\n *     onPolicyCreated(args) {\n *       console.log('Policy created:', args)\n *     },\n *   })\n *\n *   return <div>Watching for policy creation...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchCreate<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchCreate.Parameters<config> = {}) {\n  const { enabled = true, onPolicyCreated, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onPolicyCreated) return\n    return Actions.watchCreate(config, {\n      ...rest,\n      chainId,\n      onPolicyCreated,\n    })\n  }, [config, enabled, onPolicyCreated, rest, chainId])\n}\n\nexport declare namespace useWatchCreate {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchCreate.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching policy admin update events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.policy.useWatchAdminUpdated({\n *     onAdminUpdated(args) {\n *       console.log('Policy admin updated:', args)\n *     },\n *   })\n *\n *   return <div>Watching for admin updates...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchAdminUpdated<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchAdminUpdated.Parameters<config> = {}) {\n  const { enabled = true, onAdminUpdated, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onAdminUpdated) return\n    return Actions.watchAdminUpdated(config, {\n      ...rest,\n      chainId,\n      onAdminUpdated,\n    })\n  }, [config, enabled, onAdminUpdated, rest, chainId])\n}\n\nexport declare namespace useWatchAdminUpdated {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchAdminUpdated.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching whitelist update events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.policy.useWatchWhitelistUpdated({\n *     onWhitelistUpdated(args) {\n *       console.log('Whitelist updated:', args)\n *     },\n *   })\n *\n *   return <div>Watching for whitelist updates...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchWhitelistUpdated<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchWhitelistUpdated.Parameters<config> = {}) {\n  const { enabled = true, onWhitelistUpdated, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onWhitelistUpdated) return\n    return Actions.watchWhitelistUpdated(config, {\n      ...rest,\n      chainId,\n      onWhitelistUpdated,\n    })\n  }, [config, enabled, onWhitelistUpdated, rest, chainId])\n}\n\nexport declare namespace useWatchWhitelistUpdated {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchWhitelistUpdated.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching blacklist update events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.policy.useWatchBlacklistUpdated({\n *     onBlacklistUpdated(args) {\n *       console.log('Blacklist updated:', args)\n *     },\n *   })\n *\n *   return <div>Watching for blacklist updates...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchBlacklistUpdated<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchBlacklistUpdated.Parameters<config> = {}) {\n  const { enabled = true, onBlacklistUpdated, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onBlacklistUpdated) return\n    return Actions.watchBlacklistUpdated(config, {\n      ...rest,\n      chainId,\n      onBlacklistUpdated,\n    })\n  }, [config, enabled, onBlacklistUpdated, rest, chainId])\n}\n\nexport declare namespace useWatchBlacklistUpdated {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchBlacklistUpdated.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useEffect } from 'react'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport {\n  type UseMutationParameters,\n  type UseQueryReturnType,\n  useMutation,\n  useQuery,\n} from 'wagmi/query'\nimport type { ExactPartial, UnionCompute } from '../../internal/types.js'\nimport * as Actions from '../Actions/reward.js'\n\n/**\n * Hook for claiming accumulated rewards.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate: claim } = Hooks.reward.useClaim()\n *\n *   return (\n *     <button onClick={() => claim({\n *       token: '0x20c0000000000000000000000000000000000001'\n *     })}>\n *       Claim Rewards\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useClaim<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useClaim.Parameters<config, context> = {},\n): useClaim.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.claim(config, variables as never)\n    },\n    mutationKey: ['claim'],\n  }) as never\n}\n\nexport declare namespace useClaim {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.claim.ReturnValue,\n          Actions.claim.ErrorType,\n          Actions.claim.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.claim.ReturnValue,\n    Actions.claim.ErrorType,\n    Actions.claim.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for claiming accumulated rewards and waiting for confirmation.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate: claimSync } = Hooks.reward.useClaimSync()\n *\n *   return (\n *     <button onClick={() => claimSync({\n *       token: '0x20c0000000000000000000000000000000000001'\n *     })}>\n *       Claim Rewards\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useClaimSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useClaimSync.Parameters<config, context> = {},\n): useClaimSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.claimSync(config, variables as never)\n    },\n    mutationKey: ['claimSync'],\n  }) as never\n}\n\nexport declare namespace useClaimSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.claimSync.ReturnValue,\n          Actions.claimSync.ErrorType,\n          Actions.claimSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.claimSync.ReturnValue,\n    Actions.claimSync.ErrorType,\n    Actions.claimSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for getting the total reward per second rate.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.reward.useGetTotalPerSecond({\n *     token: '0x20c0000000000000000000000000000000000001',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Rate: {data?.toString()}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with total reward per second.\n */\nexport function useGetTotalPerSecond<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getTotalPerSecond.ReturnValue,\n>(parameters: useGetTotalPerSecond.Parameters<config, selectData> = {}) {\n  const { query = {}, token } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getTotalPerSecond.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(token && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useGetTotalPerSecond {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getTotalPerSecond.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getTotalPerSecond.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getTotalPerSecond.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getTotalPerSecond.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.getTotalPerSecond.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting the reward information for a specific account.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.reward.useUserRewardInfo({\n *     token: '0x20c0000000000000000000000000000000000001',\n *     account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return (\n *     <div>\n *       <div>Recipient: {data?.rewardRecipient}</div>\n *       <div>Reward per token: {data?.rewardPerToken.toString()}</div>\n *       <div>Reward balance: {data?.rewardBalance.toString()}</div>\n *     </div>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with reward information (recipient, rewardPerToken, rewardBalance).\n */\nexport function useUserRewardInfo<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getUserRewardInfo.ReturnValue,\n>(parameters: useUserRewardInfo.Parameters<config, selectData> = {}) {\n  const { account, query = {}, token } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getUserRewardInfo.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(token && account && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useUserRewardInfo {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getUserRewardInfo.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getUserRewardInfo.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getUserRewardInfo.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getUserRewardInfo.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.getUserRewardInfo.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for setting the reward recipient for a token holder.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate: setRecipient } = Hooks.reward.useSetRecipient()\n *\n *   return (\n *     <button onClick={() => setRecipient({\n *       recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *       token: '0x20c0000000000000000000000000000000000001',\n *     })}>\n *       Set Recipient\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetRecipient<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetRecipient.Parameters<config, context> = {},\n): useSetRecipient.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setRecipient(config, variables as never)\n    },\n    mutationKey: ['setRecipient'],\n  }) as never\n}\n\nexport declare namespace useSetRecipient {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setRecipient.ReturnValue,\n          Actions.setRecipient.ErrorType,\n          Actions.setRecipient.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setRecipient.ReturnValue,\n    Actions.setRecipient.ErrorType,\n    Actions.setRecipient.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the reward recipient and waiting for confirmation.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate: setRecipientSync } = Hooks.reward.useSetRecipientSync()\n *\n *   return (\n *     <button onClick={() => setRecipientSync({\n *       recipient: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *       token: '0x20c0000000000000000000000000000000000001',\n *     })}>\n *       Set Recipient\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetRecipientSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetRecipientSync.Parameters<config, context> = {},\n): useSetRecipientSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setRecipientSync(config, variables as never)\n    },\n    mutationKey: ['setRecipientSync'],\n  }) as never\n}\n\nexport declare namespace useSetRecipientSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setRecipientSync.ReturnValue,\n          Actions.setRecipientSync.ErrorType,\n          Actions.setRecipientSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setRecipientSync.ReturnValue,\n    Actions.setRecipientSync.ErrorType,\n    Actions.setRecipientSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for starting a new reward stream.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate: start } = Hooks.reward.useStart()\n *\n *   return (\n *     <button onClick={() => start({\n *       amount: 100000000000000000000n,\n *       seconds: 86400,\n *       token: '0x20c0000000000000000000000000000000000001',\n *     })}>\n *       Start Reward\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useStart<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useStart.Parameters<config, context> = {},\n): useStart.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.start(config, variables as never)\n    },\n    mutationKey: ['start'],\n  }) as never\n}\n\nexport declare namespace useStart {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.start.ReturnValue,\n          Actions.start.ErrorType,\n          Actions.start.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.start.ReturnValue,\n    Actions.start.ErrorType,\n    Actions.start.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for starting a new reward stream and waiting for confirmation.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate: startSync } = Hooks.reward.useStartSync()\n *\n *   return (\n *     <button onClick={() => startSync({\n *       amount: 100000000000000000000n,\n *       seconds: 86400,\n *       token: '0x20c0000000000000000000000000000000000001',\n *     })}>\n *       Start Reward\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useStartSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useStartSync.Parameters<config, context> = {},\n): useStartSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.startSync(config, variables as never)\n    },\n    mutationKey: ['startSync'],\n  }) as never\n}\n\nexport declare namespace useStartSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.startSync.ReturnValue,\n          Actions.startSync.ErrorType,\n          Actions.startSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.startSync.ReturnValue,\n    Actions.startSync.ErrorType,\n    Actions.startSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for watching reward scheduled events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.reward.useWatchRewardScheduled({\n *     token: '0x20c0000000000000000000000000000000000001',\n *     onRewardScheduled(args) {\n *       console.log('Reward scheduled:', args)\n *     },\n *   })\n *\n *   return <div>Watching for reward scheduled events...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchRewardScheduled<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchRewardScheduled.Parameters<config> = {}) {\n  const { enabled = true, onRewardScheduled, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onRewardScheduled) return\n    if (!token) return\n    return Actions.watchRewardScheduled(config, {\n      ...rest,\n      chainId,\n      onRewardScheduled,\n      token,\n    })\n  }, [config, enabled, onRewardScheduled, rest, chainId, token])\n}\n\nexport declare namespace useWatchRewardScheduled {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchRewardScheduled.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching reward recipient set events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.reward.useWatchRewardRecipientSet({\n *     token: '0x20c0000000000000000000000000000000000001',\n *     onRewardRecipientSet(args) {\n *       console.log('Reward recipient set:', args)\n *     },\n *   })\n *\n *   return <div>Watching for reward recipient set events...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchRewardRecipientSet<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchRewardRecipientSet.Parameters<config> = {}) {\n  const { enabled = true, onRewardRecipientSet, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onRewardRecipientSet) return\n    if (!token) return\n    return Actions.watchRewardRecipientSet(config, {\n      ...rest,\n      chainId,\n      onRewardRecipientSet,\n      token,\n    })\n  }, [config, enabled, onRewardRecipientSet, rest, chainId, token])\n}\n\nexport declare namespace useWatchRewardRecipientSet {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchRewardRecipientSet.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n", "import type { DefaultError } from '@tanstack/query-core'\nimport type { UseMutationResult } from '@tanstack/react-query'\nimport type { Config, ResolvedRegister } from '@wagmi/core'\nimport { useEffect } from 'react'\nimport { useChainId, useConfig } from 'wagmi'\nimport type { ConfigParameter, QueryParameter } from 'wagmi/internal'\nimport {\n  type UseMutationParameters,\n  type UseQueryReturnType,\n  useMutation,\n  useQuery,\n} from 'wagmi/query'\n\nimport type { ExactPartial, UnionCompute } from '../../internal/types.js'\nimport * as Actions from '../Actions/token.js'\n\n/**\n * Hook for approving a spender to transfer TIP20 tokens.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useApprove()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ spender: '0x...', amount: 100n })}\n *       disabled={isPending}\n *     >\n *       Approve\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useApprove<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useApprove.Parameters<config, context> = {},\n): useApprove.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.approve(config, variables as never)\n    },\n    mutationKey: ['approve'],\n  }) as never\n}\n\nexport declare namespace useApprove {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.approve.ReturnValue,\n          Actions.approve.ErrorType,\n          Actions.approve.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.approve.ReturnValue,\n    Actions.approve.ErrorType,\n    Actions.approve.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for approving a spender to transfer TIP20 tokens.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useApproveSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ spender: '0x...', amount: 100n })}\n *       disabled={isPending}\n *     >\n *       Approve\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useApproveSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useApproveSync.Parameters<config, context> = {},\n): useApproveSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.approveSync(config, variables as never)\n    },\n    mutationKey: ['approveSync'],\n  }) as never\n}\n\nexport declare namespace useApproveSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.approveSync.ReturnValue,\n          Actions.approveSync.ErrorType,\n          Actions.approveSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.approveSync.ReturnValue,\n    Actions.approveSync.ErrorType,\n    Actions.approveSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for burning TIP20 tokens from the caller's balance.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useBurn()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ amount: 100n, token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Burn\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBurn<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBurn.Parameters<config, context> = {},\n): useBurn.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.burn(config, variables as never)\n    },\n    mutationKey: ['burn'],\n  }) as never\n}\n\nexport declare namespace useBurn {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.burn.ReturnValue,\n          Actions.burn.ErrorType,\n          Actions.burn.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.burn.ReturnValue,\n    Actions.burn.ErrorType,\n    Actions.burn.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for burning TIP20 tokens from the caller's balance.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useBurnSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ amount: 100n, token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Burn\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBurnSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBurnSync.Parameters<config, context> = {},\n): useBurnSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.burnSync(config, variables as never)\n    },\n    mutationKey: ['burnSync'],\n  }) as never\n}\n\nexport declare namespace useBurnSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.burnSync.ReturnValue,\n          Actions.burnSync.ErrorType,\n          Actions.burnSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.burnSync.ReturnValue,\n    Actions.burnSync.ErrorType,\n    Actions.burnSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for burning TIP20 tokens from a blocked address.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useBurnBlocked()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ from: '0x...', amount: 100n, token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Burn Blocked\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBurnBlocked<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBurnBlocked.Parameters<config, context> = {},\n): useBurnBlocked.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.burnBlocked(config, variables as never)\n    },\n    mutationKey: ['burnBlocked'],\n  }) as never\n}\n\nexport declare namespace useBurnBlocked {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.burnBlocked.ReturnValue,\n          Actions.burnBlocked.ErrorType,\n          Actions.burnBlocked.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.burnBlocked.ReturnValue,\n    Actions.burnBlocked.ErrorType,\n    Actions.burnBlocked.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for burning TIP20 tokens from a blocked address.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useBurnBlockedSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ from: '0x...', amount: 100n, token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Burn Blocked\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useBurnBlockedSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useBurnBlockedSync.Parameters<config, context> = {},\n): useBurnBlockedSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.burnBlockedSync(config, variables as never)\n    },\n    mutationKey: ['burnBlockedSync'],\n  }) as never\n}\n\nexport declare namespace useBurnBlockedSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.burnBlockedSync.ReturnValue,\n          Actions.burnBlockedSync.ErrorType,\n          Actions.burnBlockedSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.burnBlockedSync.ReturnValue,\n    Actions.burnBlockedSync.ErrorType,\n    Actions.burnBlockedSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for changing the transfer policy ID for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useChangeTransferPolicy()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', policyId: 1n })}\n *       disabled={isPending}\n *     >\n *       Change Policy\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useChangeTransferPolicy<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useChangeTransferPolicy.Parameters<config, context> = {},\n): useChangeTransferPolicy.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.changeTransferPolicy(config, variables as never)\n    },\n    mutationKey: ['changeTransferPolicy'],\n  }) as never\n}\n\nexport declare namespace useChangeTransferPolicy {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.changeTransferPolicy.ReturnValue,\n          Actions.changeTransferPolicy.ErrorType,\n          Actions.changeTransferPolicy.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.changeTransferPolicy.ReturnValue,\n    Actions.changeTransferPolicy.ErrorType,\n    Actions.changeTransferPolicy.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for changing the transfer policy ID for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useChangeTransferPolicySync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', policyId: 1n })}\n *       disabled={isPending}\n *     >\n *       Change Policy\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useChangeTransferPolicySync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useChangeTransferPolicySync.Parameters<config, context> = {},\n): useChangeTransferPolicySync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.changeTransferPolicySync(config, variables as never)\n    },\n    mutationKey: ['changeTransferPolicySync'],\n  }) as never\n}\n\nexport declare namespace useChangeTransferPolicySync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.changeTransferPolicySync.ReturnValue,\n          Actions.changeTransferPolicySync.ErrorType,\n          Actions.changeTransferPolicySync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.changeTransferPolicySync.ReturnValue,\n    Actions.changeTransferPolicySync.ErrorType,\n    Actions.changeTransferPolicySync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for creating a new TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useCreate()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ name: 'My Token', symbol: 'MTK', currency: 'USD' })}\n *       disabled={isPending}\n *     >\n *       Create Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCreate<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCreate.Parameters<config, context> = {},\n): useCreate.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.create(config, variables as never)\n    },\n    mutationKey: ['create'],\n  }) as never\n}\n\nexport declare namespace useCreate {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.create.ReturnValue,\n          Actions.create.ErrorType,\n          Actions.create.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.create.ReturnValue,\n    Actions.create.ErrorType,\n    Actions.create.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for creating a new TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useCreateSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ name: 'My Token', symbol: 'MTK', currency: 'USD' })}\n *       disabled={isPending}\n *     >\n *       Create Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useCreateSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useCreateSync.Parameters<config, context> = {},\n): useCreateSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.createSync(config, variables as never)\n    },\n    mutationKey: ['createSync'],\n  }) as never\n}\n\nexport declare namespace useCreateSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.createSync.ReturnValue,\n          Actions.createSync.ErrorType,\n          Actions.createSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.createSync.ReturnValue,\n    Actions.createSync.ErrorType,\n    Actions.createSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for updating the quote token for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useUpdateQuoteToken()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Update Quote Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useUpdateQuoteToken<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useUpdateQuoteToken.Parameters<config, context> = {},\n): useUpdateQuoteToken.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.updateQuoteToken(config, variables as never)\n    },\n    mutationKey: ['updateQuoteToken'],\n  }) as never\n}\n\nexport declare namespace useUpdateQuoteToken {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.updateQuoteToken.ReturnValue,\n          Actions.updateQuoteToken.ErrorType,\n          Actions.updateQuoteToken.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.updateQuoteToken.ReturnValue,\n    Actions.updateQuoteToken.ErrorType,\n    Actions.updateQuoteToken.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for updating the quote token for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useUpdateQuoteTokenSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Update Quote Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useUpdateQuoteTokenSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useUpdateQuoteTokenSync.Parameters<config, context> = {},\n): useUpdateQuoteTokenSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.updateQuoteTokenSync(config, variables as never)\n    },\n    mutationKey: ['updateQuoteTokenSync'],\n  }) as never\n}\n\nexport declare namespace useUpdateQuoteTokenSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.updateQuoteTokenSync.ReturnValue,\n          Actions.updateQuoteTokenSync.ErrorType,\n          Actions.updateQuoteTokenSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.updateQuoteTokenSync.ReturnValue,\n    Actions.updateQuoteTokenSync.ErrorType,\n    Actions.updateQuoteTokenSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for getting TIP20 token allowance.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.token.useGetAllowance({\n *     account: '0x...',\n *     spender: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Allowance: {data?.toString()}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with token allowance.\n */\nexport function useGetAllowance<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getAllowance.ReturnValue,\n>(parameters: useGetAllowance.Parameters<config, selectData> = {}) {\n  const { account, spender, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getAllowance.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(account && spender && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useGetAllowance {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getAllowance.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getAllowance.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getAllowance.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getAllowance.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.getAllowance.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting TIP20 token balance for an address.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.token.useGetBalance({\n *     account: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Balance: {data?.toString()}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with token balance.\n */\nexport function useGetBalance<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getBalance.ReturnValue,\n>(parameters: useGetBalance.Parameters<config, selectData> = {}) {\n  const { account, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getBalance.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(account && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useGetBalance {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getBalance.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getBalance.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getBalance.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getBalance.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.getBalance.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting TIP20 token metadata.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.token.useGetMetadata({\n *     token: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>{data?.name} ({data?.symbol})</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with token metadata.\n */\nexport function useGetMetadata<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getMetadata.ReturnValue,\n>(parameters: useGetMetadata.Parameters<config, selectData> = {}) {\n  const { query = {}, token } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getMetadata.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n    token: token as never,\n  })\n  const enabled = Boolean(token && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useGetMetadata {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getMetadata.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getMetadata.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getMetadata.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getMetadata.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.getMetadata.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for getting the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.token.useGetRoleAdmin({\n *     role: 'issuer',\n *     token: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Admin Role: {data}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with admin role hash.\n */\nexport function useGetRoleAdmin<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.getRoleAdmin.ReturnValue,\n>(parameters: useGetRoleAdmin.Parameters<config, selectData>) {\n  const { query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.getRoleAdmin.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n\n  return useQuery({ ...query, ...options })\n}\n\nexport declare namespace useGetRoleAdmin {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.getRoleAdmin.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.getRoleAdmin.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.getRoleAdmin.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<\n        Actions.getRoleAdmin.queryOptions.Parameters<config, selectData>,\n        'query'\n      >\n    >\n\n  export type ReturnValue<selectData = Actions.getRoleAdmin.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for granting roles for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useGrantRoles()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', to: '0x...', roles: ['issuer'] })}\n *       disabled={isPending}\n *     >\n *       Grant Roles\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useGrantRoles<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useGrantRoles.Parameters<config, context> = {},\n): useGrantRoles.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.grantRoles(config, variables as never)\n    },\n    mutationKey: ['grantRoles'],\n  }) as never\n}\n\nexport declare namespace useGrantRoles {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.grantRoles.ReturnValue,\n          Actions.grantRoles.ErrorType,\n          Actions.grantRoles.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.grantRoles.ReturnValue,\n    Actions.grantRoles.ErrorType,\n    Actions.grantRoles.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for granting roles for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useGrantRolesSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', to: '0x...', roles: ['issuer'] })}\n *       disabled={isPending}\n *     >\n *       Grant Roles\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useGrantRolesSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useGrantRolesSync.Parameters<config, context> = {},\n): useGrantRolesSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.grantRolesSync(config, variables as never)\n    },\n    mutationKey: ['grantRolesSync'],\n  }) as never\n}\n\nexport declare namespace useGrantRolesSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.grantRolesSync.ReturnValue,\n          Actions.grantRolesSync.ErrorType,\n          Actions.grantRolesSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.grantRolesSync.ReturnValue,\n    Actions.grantRolesSync.ErrorType,\n    Actions.grantRolesSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for checking if an account has a specific role for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { data, isLoading } = Hooks.token.useHasRole({\n *     account: '0x...',\n *     role: 'issuer',\n *     token: '0x...',\n *   })\n *\n *   if (isLoading) return <div>Loading...</div>\n *   return <div>Has Role: {data ? 'Yes' : 'No'}</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Query result with boolean indicating if account has role.\n */\nexport function useHasRole<\n  config extends Config = ResolvedRegister['config'],\n  selectData = Actions.hasRole.ReturnValue,\n>(parameters: useHasRole.Parameters<config, selectData>) {\n  const { account, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = Actions.hasRole.queryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n    query: undefined,\n  } as never)\n  const enabled = Boolean(account && (query.enabled ?? true))\n\n  return useQuery({ ...query, ...options, enabled })\n}\n\nexport declare namespace useHasRole {\n  export type Parameters<\n    config extends Config = ResolvedRegister['config'],\n    selectData = Actions.hasRole.ReturnValue,\n  > = ConfigParameter<config> &\n    QueryParameter<\n      Actions.hasRole.ReturnValue,\n      DefaultError,\n      selectData,\n      Actions.hasRole.QueryKey<config>\n    > &\n    ExactPartial<\n      Omit<Actions.hasRole.queryOptions.Parameters<config, selectData>, 'query'>\n    >\n\n  export type ReturnValue<selectData = Actions.hasRole.ReturnValue> =\n    UseQueryReturnType<selectData, Error>\n}\n\n/**\n * Hook for minting TIP20 tokens to an address.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useMint()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ to: '0x...', amount: 100n, token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Mint\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useMint<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useMint.Parameters<config, context> = {},\n): useMint.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.mint(config, variables as never)\n    },\n    mutationKey: ['mint'],\n  }) as never\n}\n\nexport declare namespace useMint {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.mint.ReturnValue,\n          Actions.mint.ErrorType,\n          Actions.mint.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.mint.ReturnValue,\n    Actions.mint.ErrorType,\n    Actions.mint.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for minting TIP20 tokens to an address.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useMintSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ to: '0x...', amount: 100n, token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Mint\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useMintSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useMintSync.Parameters<config, context> = {},\n): useMintSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.mintSync(config, variables as never)\n    },\n    mutationKey: ['mintSync'],\n  }) as never\n}\n\nexport declare namespace useMintSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.mintSync.ReturnValue,\n          Actions.mintSync.ErrorType,\n          Actions.mintSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.mintSync.ReturnValue,\n    Actions.mintSync.ErrorType,\n    Actions.mintSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for pausing a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.usePause()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Pause\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePause<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePause.Parameters<config, context> = {},\n): usePause.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.pause(config, variables as never)\n    },\n    mutationKey: ['pause'],\n  }) as never\n}\n\nexport declare namespace usePause {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.pause.ReturnValue,\n          Actions.pause.ErrorType,\n          Actions.pause.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.pause.ReturnValue,\n    Actions.pause.ErrorType,\n    Actions.pause.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for pausing a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.usePauseSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Pause\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePauseSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePauseSync.Parameters<config, context> = {},\n): usePauseSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.pauseSync(config, variables as never)\n    },\n    mutationKey: ['pauseSync'],\n  }) as never\n}\n\nexport declare namespace usePauseSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.pauseSync.ReturnValue,\n          Actions.pauseSync.ErrorType,\n          Actions.pauseSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.pauseSync.ReturnValue,\n    Actions.pauseSync.ErrorType,\n    Actions.pauseSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for renouncing roles for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useRenounceRoles()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', roles: ['issuer'] })}\n *       disabled={isPending}\n *     >\n *       Renounce Roles\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useRenounceRoles<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRenounceRoles.Parameters<config, context> = {},\n): useRenounceRoles.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.renounceRoles(config, variables as never)\n    },\n    mutationKey: ['renounceRoles'],\n  }) as never\n}\n\nexport declare namespace useRenounceRoles {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.renounceRoles.ReturnValue,\n          Actions.renounceRoles.ErrorType,\n          Actions.renounceRoles.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.renounceRoles.ReturnValue,\n    Actions.renounceRoles.ErrorType,\n    Actions.renounceRoles.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for renouncing roles for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useRenounceRolesSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', roles: ['issuer'] })}\n *       disabled={isPending}\n *     >\n *       Renounce Roles\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useRenounceRolesSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRenounceRolesSync.Parameters<config, context> = {},\n): useRenounceRolesSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.renounceRolesSync(config, variables as never)\n    },\n    mutationKey: ['renounceRolesSync'],\n  }) as never\n}\n\nexport declare namespace useRenounceRolesSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.renounceRolesSync.ReturnValue,\n          Actions.renounceRolesSync.ErrorType,\n          Actions.renounceRolesSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.renounceRolesSync.ReturnValue,\n    Actions.renounceRolesSync.ErrorType,\n    Actions.renounceRolesSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for revoking roles for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useRevokeRoles()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', from: '0x...', roles: ['issuer'] })}\n *       disabled={isPending}\n *     >\n *       Revoke Roles\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useRevokeRoles<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRevokeRoles.Parameters<config, context> = {},\n): useRevokeRoles.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.revokeRoles(config, variables as never)\n    },\n    mutationKey: ['revokeRoles'],\n  }) as never\n}\n\nexport declare namespace useRevokeRoles {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.revokeRoles.ReturnValue,\n          Actions.revokeRoles.ErrorType,\n          Actions.revokeRoles.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.revokeRoles.ReturnValue,\n    Actions.revokeRoles.ErrorType,\n    Actions.revokeRoles.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for revoking roles for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useRevokeRolesSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', from: '0x...', roles: ['issuer'] })}\n *       disabled={isPending}\n *     >\n *       Revoke Roles\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useRevokeRolesSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useRevokeRolesSync.Parameters<config, context> = {},\n): useRevokeRolesSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.revokeRolesSync(config, variables as never)\n    },\n    mutationKey: ['revokeRolesSync'],\n  }) as never\n}\n\nexport declare namespace useRevokeRolesSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.revokeRolesSync.ReturnValue,\n          Actions.revokeRolesSync.ErrorType,\n          Actions.revokeRolesSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.revokeRolesSync.ReturnValue,\n    Actions.revokeRolesSync.ErrorType,\n    Actions.revokeRolesSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the admin role for a specific role in a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useSetRoleAdmin()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', role: 'issuer', adminRole: 'pause' })}\n *       disabled={isPending}\n *     >\n *       Set Role Admin\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetRoleAdmin<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetRoleAdmin.Parameters<config, context> = {},\n): useSetRoleAdmin.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setRoleAdmin(config, variables as never)\n    },\n    mutationKey: ['setRoleAdmin'],\n  }) as never\n}\n\nexport declare namespace useSetRoleAdmin {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setRoleAdmin.ReturnValue,\n          Actions.setRoleAdmin.ErrorType,\n          Actions.setRoleAdmin.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setRoleAdmin.ReturnValue,\n    Actions.setRoleAdmin.ErrorType,\n    Actions.setRoleAdmin.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the admin role for a specific role in a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useSetRoleAdminSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', role: 'issuer', adminRole: 'pause' })}\n *       disabled={isPending}\n *     >\n *       Set Role Admin\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetRoleAdminSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetRoleAdminSync.Parameters<config, context> = {},\n): useSetRoleAdminSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setRoleAdminSync(config, variables as never)\n    },\n    mutationKey: ['setRoleAdminSync'],\n  }) as never\n}\n\nexport declare namespace useSetRoleAdminSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setRoleAdminSync.ReturnValue,\n          Actions.setRoleAdminSync.ErrorType,\n          Actions.setRoleAdminSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setRoleAdminSync.ReturnValue,\n    Actions.setRoleAdminSync.ErrorType,\n    Actions.setRoleAdminSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the supply cap for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useSetSupplyCap()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', supplyCap: 1000000n })}\n *       disabled={isPending}\n *     >\n *       Set Supply Cap\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetSupplyCap<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetSupplyCap.Parameters<config, context> = {},\n): useSetSupplyCap.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setSupplyCap(config, variables as never)\n    },\n    mutationKey: ['setSupplyCap'],\n  }) as never\n}\n\nexport declare namespace useSetSupplyCap {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setSupplyCap.ReturnValue,\n          Actions.setSupplyCap.ErrorType,\n          Actions.setSupplyCap.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setSupplyCap.ReturnValue,\n    Actions.setSupplyCap.ErrorType,\n    Actions.setSupplyCap.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for setting the supply cap for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useSetSupplyCapSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', supplyCap: 1000000n })}\n *       disabled={isPending}\n *     >\n *       Set Supply Cap\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useSetSupplyCapSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useSetSupplyCapSync.Parameters<config, context> = {},\n): useSetSupplyCapSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.setSupplyCapSync(config, variables as never)\n    },\n    mutationKey: ['setSupplyCapSync'],\n  }) as never\n}\n\nexport declare namespace useSetSupplyCapSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.setSupplyCapSync.ReturnValue,\n          Actions.setSupplyCapSync.ErrorType,\n          Actions.setSupplyCapSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.setSupplyCapSync.ReturnValue,\n    Actions.setSupplyCapSync.ErrorType,\n    Actions.setSupplyCapSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for transferring TIP20 tokens to another address.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useTransfer()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ to: '0x...', amount: 100n })}\n *       disabled={isPending}\n *     >\n *       Transfer\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useTransfer<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useTransfer.Parameters<config, context> = {},\n): useTransfer.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.transfer(config, variables as never)\n    },\n    mutationKey: ['transfer'],\n  }) as never\n}\n\nexport declare namespace useTransfer {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.transfer.ReturnValue,\n          Actions.transfer.ErrorType,\n          Actions.transfer.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.transfer.ReturnValue,\n    Actions.transfer.ErrorType,\n    Actions.transfer.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for transferring TIP20 tokens to another address.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useTransferSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ to: '0x...', amount: 100n })}\n *       disabled={isPending}\n *     >\n *       Transfer\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useTransferSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useTransferSync.Parameters<config, context> = {},\n): useTransferSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.transferSync(config, variables as never)\n    },\n    mutationKey: ['transferSync'],\n  }) as never\n}\n\nexport declare namespace useTransferSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.transferSync.ReturnValue,\n          Actions.transferSync.ErrorType,\n          Actions.transferSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.transferSync.ReturnValue,\n    Actions.transferSync.ErrorType,\n    Actions.transferSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for unpausing a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useUnpause()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Unpause\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useUnpause<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useUnpause.Parameters<config, context> = {},\n): useUnpause.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.unpause(config, variables as never)\n    },\n    mutationKey: ['unpause'],\n  }) as never\n}\n\nexport declare namespace useUnpause {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.unpause.ReturnValue,\n          Actions.unpause.ErrorType,\n          Actions.unpause.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.unpause.ReturnValue,\n    Actions.unpause.ErrorType,\n    Actions.unpause.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for unpausing a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.useUnpauseSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Unpause\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function useUnpauseSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: useUnpauseSync.Parameters<config, context> = {},\n): useUnpauseSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.unpauseSync(config, variables as never)\n    },\n    mutationKey: ['unpauseSync'],\n  }) as never\n}\n\nexport declare namespace useUnpauseSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.unpauseSync.ReturnValue,\n          Actions.unpauseSync.ErrorType,\n          Actions.unpauseSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.unpauseSync.ReturnValue,\n    Actions.unpauseSync.ErrorType,\n    Actions.unpauseSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for preparing the quote token update for a TIP20 token.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.usePrepareUpdateQuoteToken()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', quoteToken: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Prepare Update Quote Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePrepareUpdateQuoteToken<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePrepareUpdateQuoteToken.Parameters<config, context> = {},\n): usePrepareUpdateQuoteToken.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.prepareUpdateQuoteToken(config, variables as never)\n    },\n    mutationKey: ['prepareUpdateQuoteToken'],\n  }) as never\n}\n\nexport declare namespace usePrepareUpdateQuoteToken {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.prepareUpdateQuoteToken.ReturnValue,\n          Actions.prepareUpdateQuoteToken.ErrorType,\n          Actions.prepareUpdateQuoteToken.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.prepareUpdateQuoteToken.ReturnValue,\n    Actions.prepareUpdateQuoteToken.ErrorType,\n    Actions.prepareUpdateQuoteToken.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for preparing the quote token update for a TIP20 token.\n *\n * Note: This is a synchronous hook that waits for the transaction\n * to be included on a block before returning a response.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   const { mutate, isPending } = Hooks.token.usePrepareUpdateQuoteTokenSync()\n *\n *   return (\n *     <button\n *       onClick={() => mutate({ token: '0x...', quoteToken: '0x...' })}\n *       disabled={isPending}\n *     >\n *       Prepare Update Quote Token\n *     </button>\n *   )\n * }\n * ```\n *\n * @param parameters - Parameters.\n * @returns Mutation result.\n */\nexport function usePrepareUpdateQuoteTokenSync<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: usePrepareUpdateQuoteTokenSync.Parameters<config, context> = {},\n): usePrepareUpdateQuoteTokenSync.ReturnType<config, context> {\n  const { mutation } = parameters\n  const config = useConfig(parameters)\n  return useMutation({\n    ...mutation,\n    async mutationFn(variables) {\n      return Actions.prepareUpdateQuoteTokenSync(config, variables as never)\n    },\n    mutationKey: ['prepareUpdateQuoteTokenSync'],\n  }) as never\n}\n\nexport declare namespace usePrepareUpdateQuoteTokenSync {\n  type Parameters<\n    config extends Config = Config,\n    context = unknown,\n  > = ConfigParameter<config> & {\n    mutation?:\n      | UseMutationParameters<\n          Actions.prepareUpdateQuoteTokenSync.ReturnValue,\n          Actions.prepareUpdateQuoteTokenSync.ErrorType,\n          Actions.prepareUpdateQuoteTokenSync.Parameters<config>,\n          context\n        >\n      | undefined\n  }\n\n  type ReturnType<\n    config extends Config = Config,\n    context = unknown,\n  > = UseMutationResult<\n    Actions.prepareUpdateQuoteTokenSync.ReturnValue,\n    Actions.prepareUpdateQuoteTokenSync.ErrorType,\n    Actions.prepareUpdateQuoteTokenSync.Parameters<config>,\n    context\n  >\n}\n\n/**\n * Hook for watching TIP20 token role admin updates.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchAdminRole({\n *     onRoleAdminUpdated(args) {\n *       console.log('Role admin updated:', args)\n *     },\n *   })\n *\n *   return <div>Watching for role admin updates...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchAdminRole<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchAdminRole.Parameters<config> = {}) {\n  const { enabled = true, onRoleAdminUpdated, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onRoleAdminUpdated) return\n    if (!token) return\n    return Actions.watchAdminRole(config, {\n      ...rest,\n      chainId,\n      onRoleAdminUpdated,\n      token,\n    })\n  }, [config, enabled, onRoleAdminUpdated, rest])\n}\n\nexport declare namespace useWatchAdminRole {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchAdminRole.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching TIP20 token approval events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchApprove({\n *     onApproval(args) {\n *       console.log('Approval:', args)\n *     },\n *   })\n *\n *   return <div>Watching for approvals...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchApprove<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchApprove.Parameters<config> = {}) {\n  const { enabled = true, onApproval, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onApproval) return\n    if (!token) return\n    return Actions.watchApprove(config, {\n      ...rest,\n      chainId,\n      onApproval,\n      token,\n    })\n  }, [config, enabled, onApproval, rest])\n}\n\nexport declare namespace useWatchApprove {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchApprove.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching TIP20 token burn events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchBurn({\n *     onBurn(args) {\n *       console.log('Burn:', args)\n *     },\n *   })\n *\n *   return <div>Watching for burns...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchBurn<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchBurn.Parameters<config> = {}) {\n  const { enabled = true, onBurn, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onBurn) return\n    if (!token) return\n    return Actions.watchBurn(config, {\n      ...rest,\n      chainId,\n      onBurn,\n      token,\n    })\n  }, [config, enabled, onBurn, rest, token])\n}\n\nexport declare namespace useWatchBurn {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchBurn.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching new TIP20 tokens created.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchCreate({\n *     onTokenCreated(args) {\n *       console.log('Token created:', args)\n *     },\n *   })\n *\n *   return <div>Watching for token creations...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchCreate<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchCreate.Parameters<config> = {}) {\n  const { enabled = true, onTokenCreated, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onTokenCreated) return\n    return Actions.watchCreate(config, {\n      ...rest,\n      chainId,\n      onTokenCreated,\n    })\n  }, [config, enabled, onTokenCreated, rest])\n}\n\nexport declare namespace useWatchCreate {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchCreate.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching TIP20 token mint events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchMint({\n *     onMint(args) {\n *       console.log('Mint:', args)\n *     },\n *   })\n *\n *   return <div>Watching for mints...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchMint<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchMint.Parameters<config> = {}) {\n  const { enabled = true, onMint, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onMint) return\n    if (!token) return\n    return Actions.watchMint(config, {\n      ...rest,\n      chainId,\n      onMint,\n      token,\n    })\n  }, [config, enabled, onMint, rest, token])\n}\n\nexport declare namespace useWatchMint {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchMint.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching TIP20 token role membership updates.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchRole({\n *     onRoleUpdated(args) {\n *       console.log('Role updated:', args)\n *     },\n *   })\n *\n *   return <div>Watching for role updates...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchRole<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchRole.Parameters<config> = {}) {\n  const { enabled = true, onRoleUpdated, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onRoleUpdated) return\n    if (!token) return\n    return Actions.watchRole(config, {\n      ...rest,\n      chainId,\n      onRoleUpdated,\n      token,\n    })\n  }, [config, enabled, onRoleUpdated, rest, token])\n}\n\nexport declare namespace useWatchRole {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchRole.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching TIP20 token transfer events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchTransfer({\n *     onTransfer(args) {\n *       console.log('Transfer:', args)\n *     },\n *   })\n *\n *   return <div>Watching for transfers...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchTransfer<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchTransfer.Parameters<config> = {}) {\n  const { enabled = true, onTransfer, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onTransfer) return\n    if (!token) return\n    return Actions.watchTransfer(config, {\n      ...rest,\n      chainId,\n      onTransfer,\n      token,\n    })\n  }, [config, enabled, onTransfer, rest])\n}\n\nexport declare namespace useWatchTransfer {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchTransfer.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n\n/**\n * Hook for watching TIP20 token quote token update events.\n *\n * @example\n * ```tsx\n * import { Hooks } from 'tempo.ts/wagmi'\n *\n * function App() {\n *   Hooks.token.useWatchUpdateQuoteToken({\n *     onUpdateQuoteToken(args) {\n *       if (args.completed)\n *         console.log('quote token update completed:', args.newQuoteToken)\n *       else\n *         console.log('quote token update proposed:', args.newQuoteToken)\n *     },\n *   })\n *\n *   return <div>Watching for quote token updates...</div>\n * }\n * ```\n *\n * @param parameters - Parameters.\n */\nexport function useWatchUpdateQuoteToken<\n  config extends Config = ResolvedRegister['config'],\n>(parameters: useWatchUpdateQuoteToken.Parameters<config> = {}) {\n  const { enabled = true, onUpdateQuoteToken, token, ...rest } = parameters\n\n  const config = useConfig({ config: parameters.config })\n  const configChainId = useChainId({ config })\n  const chainId = parameters.chainId ?? configChainId\n\n  useEffect(() => {\n    if (!enabled) return\n    if (!onUpdateQuoteToken) return\n    if (!token) return\n    return Actions.watchUpdateQuoteToken(config, {\n      ...rest,\n      chainId,\n      onUpdateQuoteToken,\n      token,\n    })\n  }, [config, enabled, onUpdateQuoteToken, rest, token])\n}\n\nexport declare namespace useWatchUpdateQuoteToken {\n  type Parameters<config extends Config = Config> = UnionCompute<\n    ExactPartial<Actions.watchUpdateQuoteToken.Parameters<config>> &\n      ConfigParameter<config> & { enabled?: boolean | undefined }\n  >\n}\n", "import type * as Hex from 'ox/Hex'\nimport * as Json from 'ox/Json'\nimport {\n  type CreateStorageParameters,\n  createStorage,\n  type Storage,\n} from 'wagmi'\nimport type * as Handler from '../server/Handler.js'\n\nexport type KeyManager = {\n  /** Function to fetch create options for WebAuthn. */\n  getChallenge?:\n    | (() => Promise<Handler.keyManager.ChallengeResponse>)\n    | undefined\n  /** Function to fetch the public key for a credential. */\n  getPublicKey: (\n    parameters: Handler.keyManager.GetPublicKeyParameters,\n  ) => Promise<Hex.Hex>\n  /** Function to set the public key for a credential. */\n  setPublicKey: (\n    parameters: Handler.keyManager.SetPublicKeyParameters,\n  ) => Promise<void>\n}\n\n/** Instantiates a key manager. */\nexport function from<manager extends KeyManager>(manager: manager): manager {\n  return manager\n}\n\n/** Instantiates a key manager from a Storage instance. */\nexport function fromStorage(storage: Storage): KeyManager {\n  return from({\n    async getPublicKey(parameters) {\n      const publicKey = await storage.getItem(parameters.credential.id)\n      if (!publicKey) throw new Error('publicKey not found.')\n      return publicKey as Hex.Hex\n    },\n    async setPublicKey(parameters) {\n      await storage.setItem(parameters.credential.id, parameters.publicKey)\n    },\n  })\n}\n\n/**\n * Instantiates a key manager from a localStorage instance.\n *\n * WARNING: Do not use this in production.\n * This is because we are unable to extract a user's public key after the registration\n * process. If a user clears their storage, or visits the website on a different device,\n * they will not be able to access their account.\n *\n * Instead, we recommend to set up a remote store such as [`KeyManager.http`](#http) to register\n * public keys against their WebAuthn credential.\n *\n * @see {@link http}\n *\n * @deprecated\n */\nexport function localStorage(options: localStorage.Options = {}) {\n  const { key = 'wagmi.keyManager' } = options\n  const storage = createStorage({\n    ...options,\n    key,\n    storage: typeof window !== 'undefined' ? window.localStorage : undefined,\n  })\n  return fromStorage(storage)\n}\n\nexport namespace localStorage {\n  export type Options = Omit<CreateStorageParameters, 'storage'>\n}\n\n/**\n * Instantiates a key manager that uses HTTP endpoints for credential management.\n *\n * @example\n * ```tsx\n * import { KeyManager } from 'tempo.ts/wagmi'\n *\n * const keyManager = KeyManager.http('https://api.example.com')\n * ```\n *\n * @param url - The URL to use for the HTTP endpoints.\n * @param options - Configuration options for HTTP endpoints.\n * @returns A KeyManager instance that uses HTTP for credential operations.\n */\nexport function http(\n  url:\n    | string\n    | {\n        getChallenge?: string | Request | undefined\n        getPublicKey?: string | Request | undefined\n        setPublicKey?: string | Request | undefined\n      },\n  options: http.Options = {},\n): KeyManager {\n  const { fetch: fetchFn = globalThis.fetch } = options\n  const { getChallenge, getPublicKey, setPublicKey } = (() => {\n    const base = typeof url === 'string' ? url : ''\n    const urls = typeof url === 'object' ? url : {}\n    return {\n      getChallenge: urls.getChallenge ?? `${base}/challenge`,\n      getPublicKey: urls.getPublicKey ?? `${base}/:credentialId`,\n      setPublicKey: urls.setPublicKey ?? `${base}/:credentialId`,\n    }\n  })()\n\n  return from({\n    async getChallenge() {\n      const request =\n        getChallenge instanceof Request\n          ? getChallenge\n          : new Request(getChallenge)\n\n      const response = await fetchFn(request)\n\n      if (!response.ok)\n        throw new Error(`Failed to get create options: ${response.statusText}`)\n      return await response.json()\n    },\n\n    async getPublicKey(parameters) {\n      const request =\n        getPublicKey instanceof Request\n          ? getPublicKey\n          : new Request(getPublicKey)\n\n      const response = await fetchFn(\n        new Request(\n          request.url.replace(':credentialId', parameters.credential.id),\n          request,\n        ),\n      )\n\n      if (!response.ok)\n        throw new Error(`Failed to get public key: ${response.statusText}`)\n      const data = await response.json()\n      return data.publicKey as Hex.Hex\n    },\n\n    async setPublicKey(parameters) {\n      const request =\n        setPublicKey instanceof Request\n          ? setPublicKey\n          : new Request(setPublicKey)\n\n      const response = await fetchFn(\n        new Request(\n          request.url.replace(':credentialId', parameters.credential.id),\n          request,\n        ),\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: Json.stringify(parameters),\n        },\n      )\n\n      if (!response.ok)\n        throw new Error(`Failed to set public key: ${response.statusText}`)\n    },\n  })\n}\n\nexport namespace http {\n  export type Options = {\n    /** Custom fetch function. @default `globalThis.fetch`. */\n    fetch?: typeof fetch | undefined\n  }\n}\n"],
  "mappings": "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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MA+/DlB,MAAM,IAAI;;;AC//DT,IAAME,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KA+/DnB,MAAM,IAAI;;;AC//DR,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UA+/Dd,MAAM,IAAI;;;AC//Db,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA+/DjB,MAAM,IAAI;;;AC//DV,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KA+/DnB,MAAM,IAAI;;;AC//DR,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QA+/DhB,MAAM,IAAI;;;AC//DX,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SA+/Df,MAAM,IAAI;;;AC//DZ,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA+/DrB,MAAM,IAAI;;;AC//DN,IAAMC,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA+/DjB,MAAM,IAAI;;;AC//DV,IAAMC,aAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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",
  "names": ["amm_exports", "dex_exports", "faucet_exports", "fee_exports", "nonce_exports", "policy_exports", "reward_exports", "token_exports", "amm_exports", "burn", "burnSync", "getLiquidityBalance", "getPool", "mint", "mintSync", "rebalanceSwap", "rebalanceSwapSync", "watchBurn", "watchFeeSwap", "watchMint", "watchRebalanceSwap", "assert", "from", "fromRpc", "toRpc", "validate", "verify", "p256", "secp256r1", "getPublicKey", "secp256r1", "from", "sign", "extraEntropy", "hash", "secp256r1", "from", "verify", "toHex", "fromBytes", "base64", "fromHex", "base64", "size", "p256", "from", "sha256", "fromString", "concat", "fromHex", "keccak256", "sign", "verify", "hash", "type", "assert", "type", "secp256k1", "p256", "slice", "size", "fromHex", "toBigInt", "from", "fromRpc", "concat", "toHex", "fromString", "toRpc", "validate", "verify", "from", "fromRpc", "nonce", "fromTuple", "nonce", "from", "toTuple", "nonce", "from", "fromRpc", "fromTuple", "getSignPayload", "toRpc", "toTuple", "from", "fromRpc", "toBigInt", "fromTuple", "getSignPayload", "toTuple", "fromHex", "keccak256", "toRpc", "type", "from", "from", "from", "toBigInt", "slice", "assert", "concat", "from", "keccak256", "concat", "serialize", "serialize", "keccak256", "fromString", "toRpcType", "fromRpcType", "fromRpcType", "toRpcType", "fromRpcType", "toRpcType", "assert", "deserialize", "from", "getSignPayload", "hash", "serialize", "validate", "fromTupleList", "assert", "validate", "toTupleList", "InvalidSerializedError", "type", "assert", "deserialize", "toHex", "slice", "nonce", "InvalidSerializedError", "fromTupleList", "validate", "fromTuple", "from", "serialize", "toTupleList", "toTuple", "concat", "fromHex", "getSignPayload", "hash", "keccak256", "from", "sign", "p256", "getType", "type", "serialize", "type", "getType", "nonce", "hash", "feePayerSignature", "from", "concat", "getPublicKey", "from", "hash", "sign", "toHex", "fromHex", "type", "concat", "parameters", "nonce", "address", "serialize", "feeManager", "stablecoinExchange", "tip20Factory", "tip403Registry", "getPool", "feeManager", "getLiquidityBalance", "rebalanceSwap", "call", "mint", "burn", "buy", "call", "stablecoinExchange", "cancel", "createPair", "getBalance", "getBuyQuote", "getOrder", "getOrderbook", "getTickLevel", "getSellQuote", "place", "type", "placeFlip", "sell", "withdraw", "toBigInt", "keccak256", "concat", "hash", "getUserToken", "feeManager", "setUserToken", "call", "getNonce", "getNonceKeyCount", "create", "chain", "type", "call", "tip403Registry", "setAdmin", "modifyWhitelist", "modifyBlacklist", "getData", "isAuthorized", "claim", "call", "getTotalPerSecond", "getUserRewardInfo", "setRecipient", "start", "burn", "burnSync", "create", "createSync", "getBalance", "mint", "mintSync", "watchBurn", "watchCreate", "watchMint", "approve", "call", "burnBlocked", "from", "burn", "burnSync", "changeTransferPolicy", "create", "chain", "tip20Factory", "createSync", "getAllowance", "getBalance", "getRoleAdmin", "hasRole", "grantRoles", "mint", "mintSync", "pause", "renounceRoles", "revokeRoles", "setSupplyCap", "setRoleAdmin", "transfer", "unpause", "prepareUpdateQuoteToken", "updateQuoteToken", "watchBurn", "watchCreate", "watchMint", "type", "BaseError", "SwitchChainError", "from", "keccak256", "fromString", "options", "chain", "from", "hash", "concat", "slice", "WebAuthnP256_exports", "createCredential", "createCredential", "toHex", "sign", "WebCryptoP256_exports", "getPool", "queryKey", "parameters", "getLiquidityBalance", "rebalanceSwap", "rebalanceSwapSync", "mint", "mintSync", "burn", "burnSync", "watchRebalanceSwap", "watchFeeSwap", "watchMint", "watchBurn", "dex_exports", "buy", "buySync", "cancel", "cancelSync", "createPair", "createPairSync", "getBalance", "getBuyQuote", "getOrder", "getOrderbook", "getSellQuote", "getTickLevel", "place", "placeFlip", "placeFlipSync", "placeSync", "sell", "sellSync", "watchFlipOrderPlaced", "watchOrderCancelled", "watchOrderFilled", "watchOrderPlaced", "withdraw", "withdrawSync", "buy", "buySync", "cancel", "cancelSync", "createPair", "createPairSync", "getBalance", "queryKey", "parameters", "getBuyQuote", "getOrder", "getOrderbook", "getTickLevel", "getSellQuote", "place", "placeFlip", "placeFlipSync", "placeSync", "sell", "sellSync", "watchFlipOrderPlaced", "watchOrderCancelled", "watchOrderFilled", "watchOrderPlaced", "withdraw", "withdrawSync", "faucet_exports", "fund", "fundSync", "fund", "fundSync", "fee_exports", "getUserToken", "setUserToken", "setUserTokenSync", "getUserToken", "queryKey", "parameters", "setUserToken", "setUserTokenSync", "nonce_exports", "getNonce", "watchNonceIncremented", "getNonce", "queryKey", "parameters", "watchNonceIncremented", "policy_exports", "create", "createSync", "getData", "isAuthorized", "modifyBlacklist", "modifyBlacklistSync", "modifyWhitelist", "modifyWhitelistSync", "setAdmin", "setAdminSync", "watchAdminUpdated", "watchBlacklistUpdated", "watchCreate", "watchWhitelistUpdated", "create", "createSync", "setAdmin", "setAdminSync", "modifyWhitelist", "modifyWhitelistSync", "modifyBlacklist", "modifyBlacklistSync", "getData", "queryKey", "parameters", "isAuthorized", "watchCreate", "watchAdminUpdated", "watchWhitelistUpdated", "watchBlacklistUpdated", "reward_exports", "claim", "claimSync", "getTotalPerSecond", "getUserRewardInfo", "setRecipient", "setRecipientSync", "start", "startSync", "watchRewardRecipientSet", "watchRewardScheduled", "claim", "claimSync", "getTotalPerSecond", "queryKey", "parameters", "getUserRewardInfo", "setRecipient", "setRecipientSync", "start", "startSync", "watchRewardScheduled", "watchRewardRecipientSet", "token_exports", "approve", "approveSync", "burn", "burnBlocked", "burnBlockedSync", "burnSync", "changeTransferPolicy", "changeTransferPolicySync", "create", "createSync", "getAllowance", "getBalance", "getMetadata", "getRoleAdmin", "grantRoles", "grantRolesSync", "hasRole", "mint", "mintSync", "pause", "pauseSync", "prepareUpdateQuoteToken", "prepareUpdateQuoteTokenSync", "renounceRoles", "renounceRolesSync", "revokeRoles", "revokeRolesSync", "setRoleAdmin", "setRoleAdminSync", "setSupplyCap", "setSupplyCapSync", "transfer", "transferSync", "unpause", "unpauseSync", "updateQuoteToken", "updateQuoteTokenSync", "watchAdminRole", "watchApprove", "watchBurn", "watchCreate", "watchMint", "watchRole", "watchTransfer", "watchUpdateQuoteToken", "approve", "approveSync", "burn", "burnBlocked", "burnBlockedSync", "burnSync", "changeTransferPolicy", "changeTransferPolicySync", "create", "createSync", "updateQuoteToken", "updateQuoteTokenSync", "getAllowance", "queryKey", "parameters", "getBalance", "getMetadata", "getRoleAdmin", "grantRoles", "grantRolesSync", "hasRole", "mint", "mintSync", "pause", "pauseSync", "renounceRoles", "renounceRolesSync", "revokeRoles", "revokeRolesSync", "setRoleAdmin", "setRoleAdminSync", "setSupplyCap", "setSupplyCapSync", "transfer", "transferSync", "unpause", "unpauseSync", "prepareUpdateQuoteToken", "prepareUpdateQuoteTokenSync", "watchAdminRole", "watchApprove", "watchBurn", "watchCreate", "watchMint", "watchRole", "watchTransfer", "watchUpdateQuoteToken", "from", "padding", "checksum", "alphabet", "sha256", "checksum", "extraEntropy", "sign", "hash", "extraEntropy", "nonce", "sign", "sign", "sign", "sign", "nonceManager", "hash", "sign", "wordlist", "wordlist", "wordlist", "wordlist", "wordlist", "wordlist", "wordlist", "wordlist", "wordlist", "privateKey", "account", "address", "chain", "credential", "WebAuthnP256_exports", "keyPair", "WebCryptoP256_exports", "fromHex", "hash", "keyAuthorization_unsigned", "keyAuthorization", "options", "amm_exports", "dex_exports", "faucet_exports", "fee_exports", "nonce_exports", "policy_exports", "reward_exports", "token_exports", "amm_exports", "getPool", "getLiquidityBalance", "rebalanceSwap", "rebalanceSwapSync", "mint", "mintSync", "burn", "burnSync", "watchRebalanceSwap", "watchFeeSwap", "watchMint", "watchBurn", "dex_exports", "import_react", "buy", "buySync", "cancel", "cancelSync", "createPair", "createPairSync", "getBalance", "getBuyQuote", "getOrder", "getOrderbook", "getTickLevel", "getSellQuote", "place", "placeFlip", "placeFlipSync", "placeSync", "sell", "sellSync", "withdraw", "withdrawSync", "watchFlipOrderPlaced", "watchOrderCancelled", "watchOrderFilled", "watchOrderPlaced", "faucet_exports", "fund", "fundSync", "fee_exports", "getUserToken", "setUserToken", "setUserTokenSync", "nonce_exports", "import_react", "getNonce", "watchNonceIncremented", "policy_exports", "import_react", "create", "createSync", "setAdmin", "setAdminSync", "modifyWhitelist", "modifyWhitelistSync", "modifyBlacklist", "modifyBlacklistSync", "getData", "isAuthorized", "watchCreate", "watchAdminUpdated", "watchWhitelistUpdated", "watchBlacklistUpdated", "reward_exports", "import_react", "claim", "claimSync", "getTotalPerSecond", "getUserRewardInfo", "setRecipient", "setRecipientSync", "start", "startSync", "watchRewardScheduled", "watchRewardRecipientSet", "token_exports", "useBurn", "useBurnSync", "useCreate", "useCreateSync", "useMint", "useMintSync", "useWatchBurn", "useWatchCreate", "useWatchMint", "import_react", "approve", "approveSync", "useBurn", "burn", "useBurnSync", "burnSync", "burnBlocked", "burnBlockedSync", "changeTransferPolicy", "changeTransferPolicySync", "useCreate", "create", "useCreateSync", "createSync", "updateQuoteToken", "updateQuoteTokenSync", "getAllowance", "getBalance", "getMetadata", "getRoleAdmin", "grantRoles", "grantRolesSync", "hasRole", "useMint", "mint", "useMintSync", "mintSync", "pause", "pauseSync", "renounceRoles", "renounceRolesSync", "revokeRoles", "revokeRolesSync", "setRoleAdmin", "setRoleAdminSync", "setSupplyCap", "setSupplyCapSync", "transfer", "transferSync", "unpause", "unpauseSync", "prepareUpdateQuoteToken", "prepareUpdateQuoteTokenSync", "watchAdminRole", "watchApprove", "useWatchBurn", "watchBurn", "useWatchCreate", "watchCreate", "useWatchMint", "watchMint", "watchRole", "watchTransfer", "watchUpdateQuoteToken", "from", "from", "getPublicKey"]
}
